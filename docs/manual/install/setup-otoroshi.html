<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Setup Otoroshi · Otoroshi</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='otoroshi-manual'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/cc.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/plugins.js"></script>
<script type="text/javascript" src="../js/ngplugins.js"></script>
<script type="text/javascript" src="../js/expression-language.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>
<link rel="stylesheet" type="text/css" href="../css/plugins.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Otoroshi
</a>
<div class="version-number">
16.4.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../about.html" class="page">About Otoroshi</a></li>
  <li><a href="../architecture.html" class="page">Architecture</a></li>
  <li><a href="../features.html" class="page">Features</a></li>
  <li><a href="../getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../install/index.html" class="page">Install</a>
  <ul>
    <li><a href="../install/get-otoroshi.html" class="page">Get Otoroshi</a></li>
    <li><a href="../install/setup-otoroshi.html" class="active page">Setup Otoroshi</a></li>
    <li><a href="../install/run-otoroshi.html" class="page">Run Otoroshi</a></li>
  </ul></li>
  <li><a href="../entities/index.html" class="page">Main entities</a>
  <ul>
    <li><a href="../entities/routes.html" class="page">Routes</a></li>
    <li><a href="../entities/backends.html" class="page">Backends</a></li>
    <li><a href="../entities/organizations.html" class="page">Organizations</a></li>
    <li><a href="../entities/teams.html" class="page">Teams</a></li>
    <li><a href="../entities/global-config.html" class="page">Global config</a></li>
    <li><a href="../entities/apikeys.html" class="page">Apikeys</a></li>
    <li><a href="../entities/service-groups.html" class="page">Service groups</a></li>
    <li><a href="../entities/auth-modules.html" class="page">Authentication modules</a></li>
    <li><a href="../entities/certificates.html" class="page">Certificates</a></li>
    <li><a href="../entities/jwt-verifiers.html" class="page">JWT verifiers</a></li>
    <li><a href="../entities/data-exporters.html" class="page">Data exporters</a></li>
    <li><a href="../entities/scripts.html" class="page">Scripts</a></li>
    <li><a href="../entities/tcp-services.html" class="page">TCP services</a></li>
    <li><a href="../entities/service-descriptors.html" class="page">Service descriptors</a></li>
  </ul></li>
  <li><a href="../topics/index.html" class="page">Detailed topics</a>
  <ul>
    <li><a href="../topics/engine.html" class="page">Proxy engine</a></li>
    <li><a href="../topics/wasm-usage.html" class="page">Otoroshi and WASM</a></li>
    <li><a href="../topics/chaos-engineering.html" class="page">Chaos engineering with the Snow Monkey</a></li>
    <li><a href="../topics/tls.html" class="page">TLS</a></li>
    <li><a href="../topics/pki.html" class="page">Otoroshi&rsquo;s PKI</a></li>
    <li><a href="../topics/monitoring.html" class="page">Monitoring</a></li>
    <li><a href="../topics/events-and-analytics.html" class="page">Events and analytics</a></li>
    <li><a href="../topics/dev-portal.html" class="page">Developer portal with Daikoku</a></li>
    <li><a href="../topics/sessions-mgmt.html" class="page">Sessions management</a></li>
    <li><a href="../topics/otoroshi-protocol.html" class="page">The Otoroshi communication protocol</a></li>
    <li><a href="../topics/expression-language.html" class="page">Expression language</a></li>
    <li><a href="../topics/user-rights.html" class="page">Otoroshi user rights</a></li>
    <li><a href="../topics/graphql-composer.html" class="page">GraphQL Composer Plugin</a></li>
    <li><a href="../topics/secrets.html" class="page">Secrets management</a></li>
    <li><a href="../topics/tunnels.html" class="page">Otoroshi tunnels</a></li>
    <li><a href="../topics/relay-routing.html" class="page">Relay Routing</a></li>
    <li><a href="../topics/netty-server.html" class="page">Alternative HTTP server</a></li>
    <li><a href="../topics/http3.html" class="page">HTTP3 support</a></li>
    <li><a href="../topics/anonymous-reporting.html" class="page">Anonymous reporting</a></li>
  </ul></li>
  <li><a href="../how-to-s/index.html" class="page">How to&rsquo;s</a>
  <ul>
    <li><a href="../how-to-s/wasm-usage.html" class="page">Using wasm plugins</a></li>
    <li><a href="../how-to-s/wasm-manager-installation.html" class="page">Deploy your own WASM Manager</a></li>
    <li><a href="../how-to-s/tailscale-integration.html" class="page">Tailscale integration</a></li>
    <li><a href="../how-to-s/end-to-end-mtls.html" class="page">End-to-end mTLS</a></li>
    <li><a href="../how-to-s/export-alerts-using-mailgun.html" class="page">Send alerts using mailgun</a></li>
    <li><a href="../how-to-s/export-events-to-elastic.html" class="page">Export events to Elasticsearch</a></li>
    <li><a href="../how-to-s/import-export-otoroshi-datastore.html" class="page">Import and export Otoroshi datastore</a></li>
    <li><a href="../how-to-s/secure-app-with-auth0.html" class="page">Secure an app with Auth0</a></li>
    <li><a href="../how-to-s/secure-app-with-keycloak.html" class="page">Secure an app with Keycloak</a></li>
    <li><a href="../how-to-s/secure-app-with-ldap.html" class="page">Secure an app and/or your Otoroshi UI with LDAP</a></li>
    <li><a href="../how-to-s/secure-with-apikey.html" class="page">Secure an api with api keys</a></li>
    <li><a href="../how-to-s/secure-with-oauth1-client.html" class="page">Secure an app with OAuth1 client flow</a></li>
    <li><a href="../how-to-s/secure-with-oauth2-client-credentials.html" class="page">Secure an app with OAuth2 client_credential flow</a></li>
    <li><a href="../how-to-s/setup-otoroshi-cluster.html" class="page">Setup an Otoroshi cluster</a></li>
    <li><a href="../how-to-s/tls-using-lets-encrypt.html" class="page">TLS termination using Let&rsquo;s Encrypt</a></li>
    <li><a href="../how-to-s/secure-an-app-with-jwt-verifiers.html" class="page">Secure an api with jwt verifiers</a></li>
    <li><a href="../how-to-s/secure-the-communication-between-a-backend-app-and-otoroshi.html" class="page">Secure the communication between a backend app and Otoroshi</a></li>
    <li><a href="../how-to-s/tls-termination-using-own-certificates.html" class="page">TLS termination using your own certificates</a></li>
    <li><a href="../how-to-s/resources-loader.html" class="page">The resources loader</a></li>
    <li><a href="../how-to-s/custom-log-levels.html" class="page">Log levels customization</a></li>
    <li><a href="../how-to-s/custom-initial-state.html" class="page">Initial state customization</a></li>
    <li><a href="../how-to-s/communicate-with-kafka.html" class="page">Communicate with Kafka</a></li>
    <li><a href="../how-to-s/create-custom-auth-module.html" class="page">Create your Authentication module</a></li>
    <li><a href="../how-to-s/working-with-eureka.html" class="page">Working with Eureka</a></li>
    <li><a href="../how-to-s/instanciate-waf-coraza.html" class="page">Instanciate a WAF with Coraza</a></li>
  </ul></li>
  <li><a href="../plugins/index.html" class="page">Otoroshi plugins</a>
  <ul>
    <li><a href="../plugins/plugins.html" class="page">Otoroshi plugins system</a></li>
    <li><a href="../plugins/create-plugins.html" class="page">Create plugins</a></li>
    <li><a href="../plugins/built-in-plugins.html" class="page">Built-in plugins</a></li>
    <li><a href="../plugins/built-in-legacy-plugins.html" class="page">Built-in legacy plugins</a></li>
  </ul></li>
  <li><a href="../api.html" class="page">Admin REST API</a></li>
  <li><a href="../deploy/index.html" class="page">Deploy to production</a>
  <ul>
    <li><a href="../deploy/clustering.html" class="page">Otoroshi clustering</a></li>
    <li><a href="../deploy/kubernetes.html" class="page">Kubernetes</a></li>
    <li><a href="../deploy/clever-cloud.html" class="page">Clever-Cloud</a></li>
    <li><a href="../deploy/aws.html" class="page">AWS - Elastic Beanstalk</a></li>
    <li><a href="../deploy/scaling.html" class="page">Scaling Otoroshi</a></li>
  </ul></li>
  <li><a href="../dev.html" class="page">Developing Otoroshi</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title-wrapper">
<div class="title-logo"></div>
<div class="title"><a href="../index.html">Otoroshi</a></div>
</div>
<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Otoroshi
</a>
<div class="version-number">
16.4.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../about.html" class="page">About Otoroshi</a></li>
  <li><a href="../architecture.html" class="page">Architecture</a></li>
  <li><a href="../features.html" class="page">Features</a></li>
  <li><a href="../getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../install/index.html" class="page">Install</a>
  <ul>
    <li><a href="../install/get-otoroshi.html" class="page">Get Otoroshi</a></li>
    <li><a href="../install/setup-otoroshi.html" class="active page">Setup Otoroshi</a></li>
    <li><a href="../install/run-otoroshi.html" class="page">Run Otoroshi</a></li>
  </ul></li>
  <li><a href="../entities/index.html" class="page">Main entities</a>
  <ul>
    <li><a href="../entities/routes.html" class="page">Routes</a></li>
    <li><a href="../entities/backends.html" class="page">Backends</a></li>
    <li><a href="../entities/organizations.html" class="page">Organizations</a></li>
    <li><a href="../entities/teams.html" class="page">Teams</a></li>
    <li><a href="../entities/global-config.html" class="page">Global config</a></li>
    <li><a href="../entities/apikeys.html" class="page">Apikeys</a></li>
    <li><a href="../entities/service-groups.html" class="page">Service groups</a></li>
    <li><a href="../entities/auth-modules.html" class="page">Authentication modules</a></li>
    <li><a href="../entities/certificates.html" class="page">Certificates</a></li>
    <li><a href="../entities/jwt-verifiers.html" class="page">JWT verifiers</a></li>
    <li><a href="../entities/data-exporters.html" class="page">Data exporters</a></li>
    <li><a href="../entities/scripts.html" class="page">Scripts</a></li>
    <li><a href="../entities/tcp-services.html" class="page">TCP services</a></li>
    <li><a href="../entities/service-descriptors.html" class="page">Service descriptors</a></li>
  </ul></li>
  <li><a href="../topics/index.html" class="page">Detailed topics</a>
  <ul>
    <li><a href="../topics/engine.html" class="page">Proxy engine</a></li>
    <li><a href="../topics/wasm-usage.html" class="page">Otoroshi and WASM</a></li>
    <li><a href="../topics/chaos-engineering.html" class="page">Chaos engineering with the Snow Monkey</a></li>
    <li><a href="../topics/tls.html" class="page">TLS</a></li>
    <li><a href="../topics/pki.html" class="page">Otoroshi&rsquo;s PKI</a></li>
    <li><a href="../topics/monitoring.html" class="page">Monitoring</a></li>
    <li><a href="../topics/events-and-analytics.html" class="page">Events and analytics</a></li>
    <li><a href="../topics/dev-portal.html" class="page">Developer portal with Daikoku</a></li>
    <li><a href="../topics/sessions-mgmt.html" class="page">Sessions management</a></li>
    <li><a href="../topics/otoroshi-protocol.html" class="page">The Otoroshi communication protocol</a></li>
    <li><a href="../topics/expression-language.html" class="page">Expression language</a></li>
    <li><a href="../topics/user-rights.html" class="page">Otoroshi user rights</a></li>
    <li><a href="../topics/graphql-composer.html" class="page">GraphQL Composer Plugin</a></li>
    <li><a href="../topics/secrets.html" class="page">Secrets management</a></li>
    <li><a href="../topics/tunnels.html" class="page">Otoroshi tunnels</a></li>
    <li><a href="../topics/relay-routing.html" class="page">Relay Routing</a></li>
    <li><a href="../topics/netty-server.html" class="page">Alternative HTTP server</a></li>
    <li><a href="../topics/http3.html" class="page">HTTP3 support</a></li>
    <li><a href="../topics/anonymous-reporting.html" class="page">Anonymous reporting</a></li>
  </ul></li>
  <li><a href="../how-to-s/index.html" class="page">How to&rsquo;s</a>
  <ul>
    <li><a href="../how-to-s/wasm-usage.html" class="page">Using wasm plugins</a></li>
    <li><a href="../how-to-s/wasm-manager-installation.html" class="page">Deploy your own WASM Manager</a></li>
    <li><a href="../how-to-s/tailscale-integration.html" class="page">Tailscale integration</a></li>
    <li><a href="../how-to-s/end-to-end-mtls.html" class="page">End-to-end mTLS</a></li>
    <li><a href="../how-to-s/export-alerts-using-mailgun.html" class="page">Send alerts using mailgun</a></li>
    <li><a href="../how-to-s/export-events-to-elastic.html" class="page">Export events to Elasticsearch</a></li>
    <li><a href="../how-to-s/import-export-otoroshi-datastore.html" class="page">Import and export Otoroshi datastore</a></li>
    <li><a href="../how-to-s/secure-app-with-auth0.html" class="page">Secure an app with Auth0</a></li>
    <li><a href="../how-to-s/secure-app-with-keycloak.html" class="page">Secure an app with Keycloak</a></li>
    <li><a href="../how-to-s/secure-app-with-ldap.html" class="page">Secure an app and/or your Otoroshi UI with LDAP</a></li>
    <li><a href="../how-to-s/secure-with-apikey.html" class="page">Secure an api with api keys</a></li>
    <li><a href="../how-to-s/secure-with-oauth1-client.html" class="page">Secure an app with OAuth1 client flow</a></li>
    <li><a href="../how-to-s/secure-with-oauth2-client-credentials.html" class="page">Secure an app with OAuth2 client_credential flow</a></li>
    <li><a href="../how-to-s/setup-otoroshi-cluster.html" class="page">Setup an Otoroshi cluster</a></li>
    <li><a href="../how-to-s/tls-using-lets-encrypt.html" class="page">TLS termination using Let&rsquo;s Encrypt</a></li>
    <li><a href="../how-to-s/secure-an-app-with-jwt-verifiers.html" class="page">Secure an api with jwt verifiers</a></li>
    <li><a href="../how-to-s/secure-the-communication-between-a-backend-app-and-otoroshi.html" class="page">Secure the communication between a backend app and Otoroshi</a></li>
    <li><a href="../how-to-s/tls-termination-using-own-certificates.html" class="page">TLS termination using your own certificates</a></li>
    <li><a href="../how-to-s/resources-loader.html" class="page">The resources loader</a></li>
    <li><a href="../how-to-s/custom-log-levels.html" class="page">Log levels customization</a></li>
    <li><a href="../how-to-s/custom-initial-state.html" class="page">Initial state customization</a></li>
    <li><a href="../how-to-s/communicate-with-kafka.html" class="page">Communicate with Kafka</a></li>
    <li><a href="../how-to-s/create-custom-auth-module.html" class="page">Create your Authentication module</a></li>
    <li><a href="../how-to-s/working-with-eureka.html" class="page">Working with Eureka</a></li>
    <li><a href="../how-to-s/instanciate-waf-coraza.html" class="page">Instanciate a WAF with Coraza</a></li>
  </ul></li>
  <li><a href="../plugins/index.html" class="page">Otoroshi plugins</a>
  <ul>
    <li><a href="../plugins/plugins.html" class="page">Otoroshi plugins system</a></li>
    <li><a href="../plugins/create-plugins.html" class="page">Create plugins</a></li>
    <li><a href="../plugins/built-in-plugins.html" class="page">Built-in plugins</a></li>
    <li><a href="../plugins/built-in-legacy-plugins.html" class="page">Built-in legacy plugins</a></li>
  </ul></li>
  <li><a href="../api.html" class="page">Admin REST API</a></li>
  <li><a href="../deploy/index.html" class="page">Deploy to production</a>
  <ul>
    <li><a href="../deploy/clustering.html" class="page">Otoroshi clustering</a></li>
    <li><a href="../deploy/kubernetes.html" class="page">Kubernetes</a></li>
    <li><a href="../deploy/clever-cloud.html" class="page">Clever-Cloud</a></li>
    <li><a href="../deploy/aws.html" class="page">AWS - Elastic Beanstalk</a></li>
    <li><a href="../deploy/scaling.html" class="page">Scaling Otoroshi</a></li>
  </ul></li>
  <li><a href="../dev.html" class="page">Developing Otoroshi</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">Otoroshi</a></li>
  <li><a href="../install/index.html">Install</a></li>
  <li>Setup Otoroshi</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#setup-otoroshi" name="setup-otoroshi" class="anchor"><span class="anchor-link"></span></a>Setup Otoroshi</h1>
<p>in this section we are going to configure otoroshi before running it for the first time</p>
<h2><a href="#setup-the-database" name="setup-the-database" class="anchor"><span class="anchor-link"></span></a>Setup the database</h2>
<p>Right now, Otoroshi supports multiple datastore. You can choose one datastore over another depending on your use case.</p><div class="plugin platform">
<div style="font-size: 22px; font-weight: bold;">Redis</div>
<div class="element-tag recommended-tag">Recommended</div>
<p>The <strong>redis</strong> datastore is quite nice when you want to easily deploy several Otoroshi instances.</p>
<img src="../imgs/redis.png" />
<p><a href="https://redis.io/topics/quickstart" title="Documentation">Documentation</a></p></div><div class="plugin platform">
<div style="font-size: 22px; font-weight: bold;">In memory</div>
<p>The <strong>in-memory</strong> datastore is kind of interesting. It can be used for testing purposes, but it is also a good candidate for production because of its fastness.</p>
<img src="../imgs/inmemory.png" />
<p><a href="../getting-started.html">Start with</a></p></div><div class="plugin platform">
<div style="font-size: 22px; font-weight: bold;">Cassandra</div>
<div class="element-tag cluster-tag">Clustering</div>
<p>Experimental support, should be used in cluster mode for leaders</p>
<img src="../imgs/cassandra.png" />
<p><a href="https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html" title="Documentation">Documentation</a></p></div><div class="plugin platform">
<div style="font-size: 22px; font-weight: bold;">Postgresql</div>
<div class="element-tag cluster-tag">Clustering</div>
<p>Or any postgresql compatible databse like cockroachdb for instance (experimental support, should be used in cluster mode for leaders)</p>
<img src="../imgs/postgres.png" />
<p><a href="https://www.postgresql.org/docs/10/tutorial-install.html" title="Documentation">Documentation</a></p></div><div class="plugin platform">
<div style="font-size: 22px; font-weight: bold;">FileDB</div>
<p>The <strong>filedb</strong> datastore is pretty handy for testing purposes, but is not supposed to be used in production mode. Not suitable for production usage.</p>
<img src="../imgs/filedb.png" /></div><div class="centered-img">
<img src="../imgs/datastores.png" /></div>
<p>the first thing to setup is what kind of datastore you want to use with the <code>otoroshi.storage</code> setting</p>
<pre class="prettyprint"><code class="language-conf">otoroshi {
  storage = &quot;inmemory&quot; # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql             
  storage = ${?APP_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql  
  storage = ${?OTOROSHI_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql  
}
</code></pre>
<p>depending on the value you chose, you will be able to configure your datastore with the following configuration</p>
<dl>
  <dt>inmemory</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;inmemory&quot;
  inmemory { # configuration to fetch/store otoroshi state in memory
    windowSize = 99
    windowSize = ${?INMEMORY_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_INMEMORY_WINDOW_SIZE}
    experimental = false
    experimental = ${?INMEMORY_EXPERIMENTAL_STORE}
    experimental = ${?OTOROSHI_INMEMORY_EXPERIMENTAL_STORE}
    optimized = false
    optimized = ${?INMEMORY_OPTIMIZED}
    optimized = ${?OTOROSHI_INMEMORY_OPTIMIZED}
    modern = false
    modern =  ${?INMEMORY_MODERN}
    modern =  ${?OTOROSHI_INMEMORY_MODERN}
  }
}</code></pre></dd>
  <dt>file</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;file&quot;
  filedb { # configuration to fetch/store otoroshi state from a file
    windowSize = 99
    windowSize = ${?FILEDB_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_FILEDB_WINDOW_SIZE}
    path = &quot;./filedb/state.ndjson&quot;
    path = ${?FILEDB_PATH}
    path = ${?OTOROSHI_FILEDB_PATH}
  }
}</code></pre></dd>
  <dt>http</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;http&quot;
  httpdb { # configuration to fetch/store otoroshi state from an http endpoint
    url = &quot;http://127.0.0.1:8888/worker-0/state.json&quot;
    headers = {}
    timeout = 10000
    pollEvery = 10000
  }
}</code></pre></dd>
  <dt>s3</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;s3&quot;
  s3db { # configuration to fetch/store otoroshi state from a S3 bucket
    bucket = &quot;otoroshi-states&quot;
    bucket = ${?OTOROSHI_DB_S3_BUCKET}
    endpoint = &quot;https://otoroshi-states.foo.bar&quot;
    endpoint = ${?OTOROSHI_DB_S3_ENDPOINT}
    region = &quot;eu-west-1&quot;
    region = ${?OTOROSHI_DB_S3_REGION}
    access = &quot;secret&quot;
    access = ${?OTOROSHI_DB_S3_ACCESS}
    secret = &quot;secret&quot;
    secret = ${?OTOROSHI_DB_S3_SECRET}
    key = &quot;/otoroshi/states/state&quot;
    key = ${?OTOROSHI_DB_S3_KEY}
    chunkSize = 8388608
    chunkSize = ${?OTOROSHI_DB_S3_CHUNK_SIZE}
    v4auth = true
    v4auth = ${?OTOROSHI_DB_S3_V4_AUTH}
    writeEvery = 60000 # write interval
    writeEvery = ${?OTOROSHI_DB_S3_WRITE_EVERY} # write interval
    acl = &quot;Private&quot;
    acl = ${?OTOROSHI_DB_S3_ACL}
  }
}</code></pre></dd>
  <dt>redis</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;lettuce&quot;
  redis { 
    lettuce { # configuration to fetch/store otoroshi state from a redis datastore using the lettuce driver (the next default one)
      connection = &quot;default&quot;
      connection = ${?REDIS_LETTUCE_CONNECTION}
      connection = ${?OTOROSHI_REDIS_LETTUCE_CONNECTION}
      uri =  ${?REDIS_LETTUCE_URI}
      uri =  ${?OTOROSHI_REDIS_LETTUCE_URI}
      uri =  ${?REDIS_URL}
      uri =  ${?OTOROSHI_REDIS_URL}
      uris = []
      urisStr = ${?REDIS_LETTUCE_URIS}
      urisStr = ${?OTOROSHI_REDIS_LETTUCE_URIS}
      readFrom = &quot;MASTER_PREFERRED&quot;
      readFrom = ${?REDIS_LETTUCE_READ_FROM}
      readFrom = ${?OTOROSHI_REDIS_LETTUCE_READ_FROM}
      startTLS = false
      startTLS = ${?REDIS_LETTUCE_START_TLS}
      startTLS = ${?OTOROSHI_REDIS_LETTUCE_START_TLS}
      verifyPeers = true
      verifyPeers = ${?REDIS_LETTUCE_VERIFY_PEERS}
      verifyPeers = ${?OTOROSHI_REDIS_LETTUCE_VERIFY_PEERS}
    }
  }
}</code></pre></dd>
  <dt>postgresql</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  # postrgesql settings. everything possible with the client
  # WARNING: this is an experimental support and everything might not work as expected !!!
  storage = &quot;postgresql&quot;
  pg { 
    uri = ${?PG_URI}
    uri = ${?OTOROSHI_PG_URI}
    uri = ${?POSTGRESQL_ADDON_URI}
    uri = ${?OTOROSHI_POSTGRESQL_ADDON_URI}
    poolSize = 20
    poolSize = ${?PG_POOL_SIZE}
    poolSize = ${?OTOROSHI_PG_POOL_SIZE}
    port = 5432
    port = ${?PG_PORT}
    port = ${?OTOROSHI_PG_PORT}
    host = &quot;localhost&quot;
    host = ${?PG_HOST}
    host = ${?OTOROSHI_PG_HOST}
    database = &quot;otoroshi&quot;
    database = ${?PG_DATABASE}
    database = ${?OTOROSHI_PG_DATABASE}
    user = &quot;otoroshi&quot;
    user = ${?PG_USER}
    user = ${?OTOROSHI_PG_USER}
    password = &quot;otoroshi&quot;
    password = ${?PG_PASSWORD}
    password = ${?OTOROSHI_PG_PASSWORD}
    logQueries = ${?PG_DEBUG_QUERIES}
    logQueries = ${?OTOROSHI_PG_DEBUG_QUERIES}
    avoidJsonPath = false
    avoidJsonPath = ${?PG_AVOID_JSON_PATH}
    avoidJsonPath = ${?OTOROSHI_PG_AVOID_JSON_PATH}
    optimized = true
    optimized = ${?PG_OPTIMIZED}
    optimized = ${?OTOROSHI_PG_OPTIMIZED}
    connect-timeout = ${?PG_CONNECT_TIMEOUT}
    connect-timeout = ${?OTOROSHI_PG_CONNECT_TIMEOUT}
    idle-timeout = ${?PG_IDLE_TIMEOUT}
    idle-timeout = ${?OTOROSHI_PG_IDLE_TIMEOUT}
    log-activity = ${?PG_LOG_ACTIVITY}
    log-activity = ${?OTOROSHI_PG_LOG_ACTIVITY}
    pipelining-limit = ${?PG_PIPELINING_LIMIT}
    pipelining-limit = ${?OTOROSHI_PG_PIPELINING_LIMIT}
    ssl {
      enabled = false
      enabled = ${?PG_SSL_ENABLED}
      enabled = ${?OTOROSHI_PG_SSL_ENABLED}
      mode = &quot;verify_ca&quot;
      mode = ${?PG_SSL_MODE}
      mode = ${?OTOROSHI_PG_SSL_MODE}
      trusted-certs-path = []
      trusted-certs = []
      trusted-cert-path = ${?PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert-path = ${?OTOROSHI_PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert = ${?PG_SSL_TRUSTED_CERT}
      trusted-cert = ${?OTOROSHI_PG_SSL_TRUSTED_CERT}
      client-certs-path = []
      client-certs = []
      client-cert-path = ${?PG_SSL_CLIENT_CERT_PATH}
      client-cert-path = ${?OTOROSHI_PG_SSL_CLIENT_CERT_PATH}
      client-cert = ${?PG_SSL_CLIENT_CERT}
      client-cert = ${?OTOROSHI_PG_SSL_CLIENT_CERT}
      trust-all = ${?PG_SSL_TRUST_ALL}
      trust-all = ${?OTOROSHI_PG_SSL_TRUST_ALL}
    }
  }
}</code></pre></dd>
  <dt>cassandra</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">otoroshi {
  storage = &quot;cassandra&quot;
  cassandra { # cassandra settings. everything possible with the client
    windowSize = 99
    windowSize = ${?CASSANDRA_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_CASSANDRA_WINDOW_SIZE}
    host = &quot;127.0.0.1&quot;
    host = ${?CASSANDRA_HOST}
    host = ${?OTOROSHI_CASSANDRA_HOST}
    port = 9042
    port = ${?CASSANDRA_PORT}
    port = ${?OTOROSHI_CASSANDRA_PORT}
    replicationFactor = 1
    replicationFactor = ${?CASSANDRA_REPLICATION_FACTOR}
    replicationFactor = ${?OTOROSHI_CASSANDRA_REPLICATION_FACTOR}
    replicationOptions = ${?CASSANDRA_REPLICATION_OPTIONS}
    replicationOptions = ${?OTOROSHI_CASSANDRA_REPLICATION_OPTIONS}
    durableWrites = true
    durableWrites = ${?CASSANDRA_DURABLE_WRITES}
    durableWrites = ${?OTOROSHI_CASSANDRA_DURABLE_WRITES}
    basic.contact-points = [ ${app.cassandra.host}&quot;:&quot;${app.cassandra.port} ]
    basic.session-name = &quot;otoroshi&quot;
    basic.session-name = ${?OTOROSHI_CASSANDRA_SESSION_NAME}
    basic.session-keyspace = ${?OTOROSHI_CASSANDRA_SESSION_KEYSPACE}
    basic.config-reload-interval = 5 minutes
    basic.request {
      timeout = 10 seconds
      consistency = LOCAL_ONE
      consistency = ${?OTOROSHI_CASSANDRA_CONSISTENCY}
      page-size = 5000
      page-size = ${?OTOROSHI_CASSANDRA_PAGE_SIZE}
      serial-consistency = SERIAL
      serial-consistency = ${?OTOROSHI_CASSANDRA_SERIAL_CONSISTENCY}
      default-idempotence = false
      default-idempotence = ${?OTOROSHI_CASSANDRA_DEFAULT_IDEMPOTENCE}
    }
    basic.load-balancing-policy {
      class = DefaultLoadBalancingPolicy
      local-datacenter = datacenter1
      local-datacenter = ${?OTOROSHI_CASSANDRA_LOCAL_DATACENTER}
      # filter.class=
      slow-replica-avoidance = true
    }
    basic.cloud {
      # secure-connect-bundle = /location/of/secure/connect/bundle
    }
    basic.application {
      # name =
      # version =
    }
    basic.graph {
      # name = your-graph-name
      traversal-source = &quot;g&quot;
      # is-system-query = false
      # read-consistency-level = LOCAL_QUORUM
      # write-consistency-level = LOCAL_ONE
      # timeout = 10 seconds
    }
    advanced.connection {
      connect-timeout = 5 seconds
      init-query-timeout = 500 milliseconds
      set-keyspace-timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      pool {
        local {
          size = 1
        }
        remote {
          size = 1
        }
      }
      max-requests-per-connection = 1024
      max-orphan-requests = 256
      warn-on-init-error = true
    }
    advanced.reconnect-on-init = false
    advanced.reconnection-policy {
      class = ExponentialReconnectionPolicy
      base-delay = 1 second
      max-delay = 60 seconds
    }
    advanced.retry-policy {
      class = DefaultRetryPolicy
    }
    advanced.speculative-execution-policy {
      class = NoSpeculativeExecutionPolicy
      # max-executions = 3
      # delay = 100 milliseconds
    }
    advanced.auth-provider {
      # class = PlainTextAuthProvider
      username = ${?CASSANDRA_USERNAME}
      username = ${?OTOROSHI_CASSANDRA_USERNAME}
      password = ${?CASSANDRA_PASSWORD}
      password = ${?OTOROSHI_CASSANDRA_PASSWORD}
      authorization-id = ${?OTOROSHI_CASSANDRA_AUTHORIZATION_ID}
      //service = &quot;cassandra&quot;
      # login-configuration {
      #   principal = &quot;cassandra@DATASTAX.COM&quot;
      #   useKeyTab = &quot;true&quot;
      #   refreshKrb5Config = &quot;true&quot;
      #   keyTab = &quot;/path/to/keytab/file&quot;
      # }
      # sasl-properties {
      #   javax.security.sasl.qop = &quot;auth-conf&quot;
      # }
    }
    advanced.ssl-engine-factory {
      # class = DefaultSslEngineFactory
      # cipher-suites = [ &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot; ]
      # hostname-validation = true
      # truststore-path = /path/to/client.truststore
      # truststore-password = password123
      # keystore-path = /path/to/client.keystore
      # keystore-password = password123
    }
    advanced.timestamp-generator {
      class = AtomicTimestampGenerator
      drift-warning {
        threshold = 1 second
        interval = 10 seconds
      }
      force-java-clock = false
    }
    advanced.request-tracker {
      class = NoopRequestTracker
      logs {
        # success.enabled = true
        slow {
          # threshold = 1 second
          # enabled = true
        }
        # error.enabled = true
        # max-query-length = 500
        # show-values = true
        # max-value-length = 50
        # max-values = 50
        # show-stack-traces = true
      }
    }
    advanced.throttler {
      class = PassThroughRequestThrottler
      # max-queue-size = 10000
      # max-concurrent-requests = 10000
      # max-requests-per-second = 10000
      # drain-interval = 10 milliseconds
    }
    advanced.node-state-listener.class = NoopNodeStateListener
    advanced.schema-change-listener.class = NoopSchemaChangeListener
    advanced.address-translator {
      class = PassThroughAddressTranslator
    }
    advanced.resolve-contact-points = true
    advanced.protocol {
      version = V4
      version = ${?OTOROSHI_CASSANDRA_PROTOCOL_VERSION}
      compression = lz4
      compression = ${?OTOROSHI_CASSANDRA_PROTOCOL_COMPRESSION}
      max-frame-length = 256 MB
    }
    advanced.request {
      warn-if-set-keyspace = false
      trace {
        attempts = 5
        interval = 3 milliseconds
        consistency = ONE
      }
      log-warnings = true
    }
    advanced.graph {
      # sub-protocol = &quot;graphson-2.0&quot;
      paging-enabled = &quot;AUTO&quot;
      paging-options {
        page-size = ${datastax-java-driver.advanced.continuous-paging.page-size}
        max-pages = ${datastax-java-driver.advanced.continuous-paging.max-pages}
        max-pages-per-second = ${datastax-java-driver.advanced.continuous-paging.max-pages-per-second}
        max-enqueued-pages = ${datastax-java-driver.advanced.continuous-paging.max-enqueued-pages}
      }
    }
    advanced.continuous-paging {
      page-size = ${datastax-java-driver.basic.request.page-size}
      page-size-in-bytes = false
      max-pages = 0
      max-pages-per-second = 0
      max-enqueued-pages = 4
      timeout {
        first-page = 2 seconds
        other-pages = 1 second
      }
    }
    advanced.monitor-reporting {
      enabled = true
    }
    advanced.metrics {
      session {
        enabled = [
          # bytes-sent,
          # bytes-received
          # connected-nodes,
          # cql-requests,
          # cql-client-timeouts,
          # cql-prepared-cache-size,
          # throttling.delay,
          # throttling.queue-size,
          # throttling.errors,
          # continuous-cql-requests,
          # graph-requests,
          # graph-client-timeouts
        ]
        cql-requests {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        throttling.delay {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        continuous-cql-requests {
          highest-latency = 120 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        graph-requests {
          highest-latency = 12 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
      }
      node {
        enabled = [
          # pool.open-connections,
          # pool.available-streams,
          # pool.in-flight,
          # pool.orphaned-streams,
          # bytes-sent,
          # bytes-received,
          # cql-messages,
          # errors.request.unsent,
          # errors.request.aborted,
          # errors.request.write-timeouts,
          # errors.request.read-timeouts,
          # errors.request.unavailables,
          # errors.request.others,
          # retries.total,
          # retries.aborted,
          # retries.read-timeout,
          # retries.write-timeout,
          # retries.unavailable,
          # retries.other,
          # ignores.total,
          # ignores.aborted,
          # ignores.read-timeout,
          # ignores.write-timeout,
          # ignores.unavailable,
          # ignores.other,
          # speculative-executions,
          # errors.connection.init,
          # errors.connection.auth,
          # graph-messages,
        ]
        cql-messages {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        graph-messages {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
      }
    }
    advanced.socket {
      tcp-no-delay = true
      //keep-alive = false
      //reuse-address = true
      //linger-interval = 0
      //receive-buffer-size = 65535
      //send-buffer-size = 65535
    }
    advanced.heartbeat {
      interval = 30 seconds
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
    }
    advanced.metadata {
      topology-event-debouncer {
        window = 1 second
        max-events = 20
      }
      schema {
        enabled = true
        # refreshed-keyspaces = [ &quot;ks1&quot;, &quot;ks2&quot; ]
        request-timeout = ${datastax-java-driver.basic.request.timeout}
        request-page-size = ${datastax-java-driver.basic.request.page-size}
        debouncer {
          window = 1 second
          max-events = 20
        }
      }
      token-map.enabled = true
    }
    advanced.control-connection {
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      schema-agreement {
        interval = 200 milliseconds
        timeout = 10 seconds
        warn-on-failure = true
      }
    }
    advanced.prepared-statements {
      prepare-on-all-nodes = true
      reprepare-on-up {
        enabled = true
        check-system-table = false
        max-statements = 0
        max-parallelism = 100
        timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      }
    }
    advanced.netty {
      daemon = false
      io-group {
        size = 0
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      admin-group {
        size = 2
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      timer {
        tick-duration = 100 milliseconds
        ticks-per-wheel = 2048
      }
    }
    advanced.coalescer {
      max-runs-with-no-work = 5
      reschedule-interval = 10 microseconds
    }
  }
}</code></pre></dd>
</dl>
<h2><a href="#setup-your-hosts-before-running" name="setup-your-hosts-before-running" class="anchor"><span class="anchor-link"></span></a>Setup your hosts before running</h2>
<p>By default, Otoroshi starts with domain <code>oto.tools</code> that automatically targets <code>127.0.0.1</code> with no changes to your <code>/etc/hosts</code> file. Of course you can change the domain value, you have to add the values in your <code>/etc/hosts</code> file according to the setting you put in Otoroshi configuration or define the right ip address at the DNS provider level</p>
<ul>
  <li><code>otoroshi.domain</code> =&gt; <code>mydomain.org</code></li>
  <li><code>otoroshi.backoffice.subdomain</code> =&gt; <code>otoroshi</code></li>
  <li><code>otoroshi.privateapps.subdomain</code> =&gt; <code>privateapps</code></li>
  <li><code>otoroshi.adminapi.exposedSubdomain</code> =&gt; <code>otoroshi-api</code></li>
  <li><code>otoroshi.adminapi.targetSubdomain</code> =&gt; <code>otoroshi-admin-internal-api</code></li>
</ul>
<p>for instance if you want to change the default domain and use something like <code>otoroshi.mydomain.org</code>, then start otoroshi like </p>
<pre class="prettyprint"><code class="language-sh">java -Dotoroshi.domain=mydomain.org -jar otoroshi.jar
</code></pre><div class="callout warning "><div class="callout-title">Warning</div>
<p>Otoroshi cannot be accessed using <code>http://127.0.0.1:8080</code> or <code>http://localhost:8080</code> because Otoroshi uses Otoroshi to serve it&rsquo;s own UI and API. When otoroshi starts with an empty database, it will create a service descriptor for that using <code>otoroshi.domain</code> and the settings listed on this page and in the here that serve Otoroshi API and UI on <code>http://otoroshi-api.${otoroshi.domain}</code> and <code>http://otoroshi.${otoroshi.domain}</code>. Once the descriptor is saved in database, if you want to change <code>otoroshi.domain</code>, you&rsquo;ll have to edit the descriptor in the database or restart Otoroshi with an empty database.</p></div><div class="callout warning "><div class="callout-title">Warning</div>
<p>if your otoroshi instance runs behind a reverse proxy (L4 / L7) or inside a docker container where exposed ports (that you will use to access otoroshi) are not the same that the ones configured in otoroshi (<code>http.port</code> and <code>https.port</code>), you&rsquo;ll have to configure otoroshi exposed port to avoid bad redirection URLs when using authentication modules and other otoroshi tools. To do that, just set the values of the exposed ports in <code>otoroshi.exposed-ports.http = $theExposedHttpPort</code> (OTOROSHI_EXPOSED_PORTS_HTTP) and <code>otoroshi.exposed-ports.https = $theExposedHttpsPort</code> (OTOROSHI_EXPOSED_PORTS_HTTPS)</p></div>
<h2><a href="#setup-your-configuration-file" name="setup-your-configuration-file" class="anchor"><span class="anchor-link"></span></a>Setup your configuration file</h2>
<p>There is a lot of things you can configure in Otoroshi. By default, Otoroshi provides a configuration that should be enough for testing purpose. But you&rsquo;ll likely need to update this configuration when you&rsquo;ll need to move into production.</p>
<p>In this page, any configuration property can be set at runtime using a <code>-D</code> flag when launching Otoroshi like </p>
<pre class="prettyprint"><code class="language-sh">java -Dhttp.port=8080 -jar otoroshi.jar
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-sh">./bin/otoroshi -Dhttp.port=8080 
</code></pre>
<p>if you want to define your own config file and use it on an otoroshi instance, use the following flag</p>
<pre class="prettyprint"><code class="language-sh">java -Dconfig.file=/path/to/otoroshi.conf -jar otoroshi.jar
</code></pre>
<h3><a href="#example-of-a-custom-configuration-file" name="example-of-a-custom-configuration-file" class="anchor"><span class="anchor-link"></span></a>Example of a custom. configuration file</h3>
<pre class="prettyprint"><code class="language-conf">include &quot;application.conf&quot;

http.port = 8080

app {
  storage = &quot;inmemory&quot;
  importFrom = &quot;./my-state.json&quot;
  env = &quot;prod&quot;
  domain = &quot;oto.tools&quot;
  rootScheme = &quot;http&quot;
  snowflake {
    seed = 0
  }
  events {
    maxSize = 1000
  }
  backoffice {
    subdomain = &quot;otoroshi&quot;
    session {
      exp = 86400000
    }
  }
  privateapps {
    subdomain = &quot;privateapps&quot;
    session {
      exp = 86400000
    }
  }
  adminapi {
    targetSubdomain = &quot;otoroshi-admin-internal-api&quot;
    exposedSubdomain = &quot;otoroshi-api&quot;
    defaultValues {
      backOfficeGroupId = &quot;admin-api-group&quot;
      backOfficeApiKeyClientId = &quot;admin-api-apikey-id&quot;
      backOfficeApiKeyClientSecret = &quot;admin-api-apikey-secret&quot;
      backOfficeServiceId = &quot;admin-api-service&quot;
    }
  }
  claim {
    sharedKey = &quot;mysecret&quot;
  }
  filedb {
    path = &quot;./filedb/state.ndjson&quot;
  }
}

play.http {
  session {
    secure = false
    httpOnly = true
    maxAge = 2592000000
    domain = &quot;.oto.tools&quot;
    cookieName = &quot;oto-sess&quot;
  }
}
</code></pre>
<h3><a href="#reference-configuration" name="reference-configuration" class="anchor"><span class="anchor-link"></span></a>Reference configuration</h3>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf"><br/>app {
  storage = &quot;inmemory&quot; # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql
  storage = ${?APP_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql
  storage = ${?OTOROSHI_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql
  storageRoot = &quot;otoroshi&quot; # the prefix used for storage keys
  storageRoot = ${?APP_STORAGE_ROOT} # the prefix used for storage keys
  storageRoot = ${?OTOROSHI_STORAGE_ROOT} # the prefix used for storage keys
  eventsName = &quot;otoroshi&quot; # the name of the event producer
  eventsName = ${?APP_EVENTS_NAME} # the name of the event producer
  eventsName = ${?OTOROSHI_EVENTS_NAME} # the name of the event producer
  importFrom = ${?APP_IMPORT_FROM} # file path to import otoroshi initial configuration
  importFrom = ${?OTOROSHI_IMPORT_FROM} # file path to import otoroshi initial configuration
  env = &quot;prod&quot; # env name, should always be prod except in dev mode
  env = ${?APP_ENV} # env name, should always be prod except in dev mode
  env = ${?OTOROSHI_ENV} # env name, should always be prod except in dev mode
  liveJs = false # enabled live JS loading for dev mode
  domain = &quot;oto.tools&quot; # default domain for basic otoroshi services
  domain = ${?APP_DOMAIN} # default domain for basic otoroshi services
  domain = ${?OTOROSHI_DOMAIN} # default domain for basic otoroshi services
  commitId = &quot;HEAD&quot;
  commitId = ${?COMMIT_ID}
  commitId = ${?OTOROSHI_COMMIT_ID}
  rootScheme = &quot;http&quot; # default root scheme when composing urls
  rootScheme = ${?APP_ROOT_SCHEME} # default root scheme when composing urls
  rootScheme = ${?OTOROSHI_ROOT_SCHEME} # default root scheme when composing urls
  throttlingWindow = 10 # the number of second used to compute throttling number
  throttlingWindow = ${?THROTTLING_WINDOW} # the number of second used to compute throttling number
  throttlingWindow = ${?OTOROSHI_THROTTLING_WINDOW} # the number of second used to compute throttling number
  checkForUpdates = true # enable automatic version update checks
  checkForUpdates = ${?CHECK_FOR_UPDATES} # enable automatic version update checks
  checkForUpdates = ${?OTOROSHI_CHECK_FOR_UPDATES} # enable automatic version update checks
  overheadThreshold = 500.0 # the value threshold (in milliseconds) used to send HighOverheadAlert
  overheadThreshold = ${?OVERHEAD_THRESHOLD} # the value threshold (in milliseconds) used to send HighOverheadAlert
  overheadThreshold = ${?OTOROSHI_OVERHEAD_THRESHOLD} # the value threshold (in milliseconds) used to send HighOverheadAlert
  adminLogin = ${?OTOROSHI_INITIAL_ADMIN_LOGIN} # the initial admin login
  adminPassword = ${?OTOROSHI_INITIAL_ADMIN_PASSWORD} # the initial admin password
  initialCustomization = ${?OTOROSHI_INITIAL_CUSTOMIZATION} # otoroshi inital configuration that will be merged with a new confguration. Shaped like an otoroshi export
  boot {
  	failOnTimeout = false # otoroshi will exit if a subsystem failed its init
  	failOnTimeout = ${?OTOROSHI_BOOT_FAIL_ON_TIMEOUT} # otoroshi will exit if a subsystem failed its init

    globalWait = true # should we wait until everything is setup to accept http requests
    globalWait = ${?OTOROSHI_BOOT_GLOBAL_WAIT} # should we wait until everything is setup to accept http requests
    globalWaitTimeout = 60000 # max wait before accepting requests
    globalWaitTimeout = ${?OTOROSHI_BOOT_GLOBAL_WAIT_TIMEOUT} # max wait before accepting requests

    waitForPluginsSearch = true # should we wait for classpath plugins search before accepting http requests
    waitForPluginsSearch = ${?OTOROSHI_BOOT_WAIT_FOR_PLUGINS_SEARCH} # should we wait for classpath plugins search before accepting http requests
    waitForPluginsSearchTimeout = 20000 # max wait for classpath plugins search before accepting http requests
    waitForPluginsSearchTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_PLUGINS_SEARCH_TIMEOUT} # max wait for classpath plugins search before accepting http requests

    waitForScriptsCompilation = true # should we wait for plugins compilation before accepting http requests
    waitForScriptsCompilation = ${?OTOROSHI_BOOT_WAIT_FOR_SCRIPTS_COMPILATION} # should we wait for plugins compilation before accepting http requests
    waitForScriptsCompilationTimeout = 30000 # max wait for plugins compilation before accepting http requests
    waitForScriptsCompilationTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_SCRIPTS_COMPILATION_TIMEOUT} # max wait for plugins compilation before accepting http requests 

    waitForTlsInit = true # should we wait for first TLS context initialization before accepting http requests
    waitForTlsInit = ${?OTOROSHI_BOOT_WAIT_FOR_TLS_INIT} # should we wait for first TLS context initialization before accepting http requests
    waitForTlsInitTimeout = 10000 # max wait for first TLS context initialization before accepting http requests
    waitForTlsInitTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_TLS_INIT_TIMEOUT} # max wait for first TLS context initialization before accepting http requests

    waitForFirstClusterFetch = true # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterFetch = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_FETCH} # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterFetchTimeout = 10000 # max wait for first cluster initialization before accepting http requests
    waitForFirstClusterFetchTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_TIMEOUT} # max wait for first cluster initialization before accepting http requests

    waitForFirstClusterStateCache = true # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterStateCache = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_STATE_CACHE} # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterStateCacheTimeout = 10000 # max wait for first cluster initialization before accepting http requests
    waitForFirstClusterStateCacheTimeout =  ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_STATE_CACHE_TIMEOUT} # max wait for first cluster initialization before accepting http requests
  }
  instance {
    instanceId = ${?OTOROSHI_INSTANCE_ID} # the instance id
    number = 0 # the instance number. Can be found in otoroshi events
    number =  ${?OTOROSHI_INSTANCE_NUMBER} # the instance number. Can be found in otoroshi events
    number =  ${?INSTANCE_NUMBER} # the instance number. Can be found in otoroshi events
    name = &quot;otoroshi&quot; # instance name
    name = ${?OTOROSHI_INSTANCE_NAME} # instance name
    zone = &quot;local&quot; # instance zone (optional)
    zone = ${?OTOROSHI_INSTANCE_ZONE} # instance zone (optional)
    region = &quot;local&quot; # instance region (optional)
    region = ${?OTOROSHI_INSTANCE_REGION} # instance region (optional)
    dc = &quot;local&quot; # instance dc (optional)
    dc = ${?OTOROSHI_INSTANCE_DATACENTER} # instance dc (optional)
    provider = &quot;local&quot; # instance provider (optional)
    provider = ${?OTOROSHI_INSTANCE_PROVIDER} # instance provider (optional)
    rack = &quot;local&quot; # instance rack (optional)
    rack = ${?OTOROSHI_INSTANCE_RACK} # instance rack (optional)
    title = ${?OTOROSHI_INSTANCE_TITLE} # the title displayed in UI top left
  }
    longRequestTimeout = 10800000
    longRequestTimeout = ${?OTOROSHI_PROXY_LONG_REQUEST_TIMEOUT}
  }
  health {
    limit = 1000  # the value threshold (in milliseconds) used to indicate if an otoroshi instance is healthy or not
    limit = ${?HEALTH_LIMIT} # the value threshold (in milliseconds) used to indicate if an otoroshi instance is healthy or not
    limit = ${?OTOROSHI_HEALTH_LIMIT} # the value threshold (in milliseconds) used to indicate if an otoroshi instance is healthy or not
    accessKey = ${?HEALTH_ACCESS_KEY} # the key to access /health edpoint
    accessKey = ${?OTOROSHI_HEALTH_ACCESS_KEY} # the key to access /health edpoint
  }
  snowflake {
    seed = 0 # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?INSTANCE_NUMBER} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?OTOROSHI_INSTANCE_NUMBER} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?SNOWFLAKE_SEED} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?OTOROSHI_SNOWFLAKE_SEED} # the seed number used to generate unique ids. Should be different for every instances
  }
  events {
    maxSize = 1000 # the amount of event kept in the datastore
    maxSize = ${?MAX_EVENTS_SIZE} # the amount of event kept in the datastore
    maxSize = ${?OTOROSHI_MAX_EVENTS_SIZE} # the amount of event kept in the datastore
  }
  exposed-ports {
    http = ${?APP_EXPOSED_PORTS_HTTP} # the exposed http port for otoroshi (when in a container or behind a proxy)
    http = ${?OTOROSHI_EXPOSED_PORTS_HTTP} # the exposed http port for otoroshi (when in a container or behind a proxy)
    https = ${?APP_EXPOSED_PORTS_HTTPS} # the exposed https port for otoroshi (when in a container or behind a proxy
    https = ${?OTOROSHI_EXPOSED_PORTS_HTTPS} # the exposed https port for otoroshi (when in a container or behind a proxy
  }
  backoffice {
    exposed = true # expose the backoffice ui
    exposed = ${?APP_BACKOFFICE_EXPOSED} # expose the backoffice ui
    exposed = ${?OTOROSHI_BACKOFFICE_EXPOSED} # expose the backoffice ui
    subdomain = &quot;otoroshi&quot; # the backoffice subdomain
    subdomain = ${?APP_BACKOFFICE_SUBDOMAIN} # the backoffice subdomain
    subdomain = ${?OTOROSHI_BACKOFFICE_SUBDOMAIN} # the backoffice subdomain
    domains = []  # the backoffice domains
    domainsStr = ${?APP_BACKOFFICE_DOMAINS} # the backoffice domains
    domainsStr = ${?OTOROSHI_BACKOFFICE_DOMAINS} # the backoffice domains
    useNewEngine = true # avoid backoffice admin api proxy
    useNewEngine = ${?OTOROSHI_BACKOFFICE_USE_NEW_ENGINE} # avoid backoffice admin api proxy
    usePlay = true # avoid backoffice http call for admin api
    usePlay = ${?OTOROSHI_BACKOFFICE_USE_PLAY} # avoid backoffice http call for admin api
    session {
      exp = 86400000 # the backoffice cookie expiration
      exp = ${?APP_BACKOFFICE_SESSION_EXP} # the backoffice cookie expiration
      exp = ${?OTOROSHI_BACKOFFICE_SESSION_EXP} # the backoffice cookie expiration
    }
  }
  privateapps {
    subdomain = &quot;privateapps&quot; # privateapps (proxy sso) domain
    subdomain = ${?APP_PRIVATEAPPS_SUBDOMAIN} # privateapps (proxy sso) domain
    subdomain = ${?OTOROSHI_PRIVATEAPPS_SUBDOMAIN} # privateapps (proxy sso) domain
    domains = []
    domainsStr = ${?APP_PRIVATEAPPS_DOMAINS}
    domainsStr = ${?OTOROSHI_PRIVATEAPPS_DOMAINS}
    session {
      exp = 86400000 # the privateapps cookie expiration
      exp = ${?APP_PRIVATEAPPS_SESSION_EXP} # the privateapps cookie expiration
      exp = ${?OTOROSHI_PRIVATEAPPS_SESSION_EXP} # the privateapps cookie expiration
    }
  }
  adminapi {
    exposed = true # expose the admin api
    exposed = ${?ADMIN_API_EXPOSED} # expose the admin api
    exposed = ${?OTOROSHI_ADMIN_API_EXPOSED} # expose the admin api
    targetSubdomain = &quot;otoroshi-admin-internal-api&quot; # admin api target subdomain as targeted by otoroshi service
    targetSubdomain = ${?ADMIN_API_TARGET_SUBDOMAIN} # admin api target subdomain as targeted by otoroshi service
    targetSubdomain = ${?OTOROSHI_ADMIN_API_TARGET_SUBDOMAIN} # admin api target subdomain as targeted by otoroshi service
    exposedSubdomain = &quot;otoroshi-api&quot; # admin api exposed subdomain as exposed by otoroshi service
    exposedSubdomain = ${?ADMIN_API_EXPOSED_SUBDOMAIN} # admin api exposed subdomain as exposed by otoroshi service
    exposedSubdomain = ${?OTOROSHI_ADMIN_API_EXPOSED_SUBDOMAIN} # admin api exposed subdomain as exposed by otoroshi service
    additionalExposedDomain = ${?ADMIN_API_ADDITIONAL_EXPOSED_DOMAIN} # admin api additional exposed subdomain as exposed by otoroshi service
    additionalExposedDomain = ${?OTOROSHI_ADMIN_API_ADDITIONAL_EXPOSED_DOMAIN} # admin api additional exposed subdomain as exposed by otoroshi service
    domains = []
    domainsStr = ${?ADMIN_API_DOMAINS}
    domainsStr = ${?OTOROSHI_ADMIN_API_DOMAINS}
    exposedDomains = []
    exposedDomainsStr = ${?ADMIN_API_EXPOSED_DOMAINS}
    exposedDomainsStr = ${?OTOROSHI_ADMIN_API_EXPOSED_DOMAINS}
    defaultValues {
      backOfficeGroupId = &quot;admin-api-group&quot; # default value for admin api service group
      backOfficeGroupId = ${?ADMIN_API_GROUP} # default value for admin api service group
      backOfficeGroupId = ${?OTOROSHI_ADMIN_API_GROUP} # default value for admin api service group
      backOfficeApiKeyClientId = &quot;admin-api-apikey-id&quot; # default value for admin api apikey id
      backOfficeApiKeyClientId = ${?ADMIN_API_CLIENT_ID}  # default value for admin api apikey id
      backOfficeApiKeyClientId = ${?OTOROSHI_ADMIN_API_CLIENT_ID}  # default value for admin api apikey id
      backOfficeApiKeyClientSecret = &quot;admin-api-apikey-secret&quot; # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?otoroshi.admin-api-secret} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?OTOROSHI_otoroshi.admin-api-secret} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?ADMIN_API_CLIENT_SECRET} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?OTOROSHI_ADMIN_API_CLIENT_SECRET} # default value for admin api apikey secret
      backOfficeServiceId = &quot;admin-api-service&quot; # default value for admin api service id
      backOfficeServiceId = ${?ADMIN_API_SERVICE_ID} # default value for admin api service id
      backOfficeServiceId = ${?OTOROSHI_ADMIN_API_SERVICE_ID} # default value for admin api service id
    }
    proxy {
      https = false # backoffice proxy admin api over https
      https = ${?ADMIN_API_HTTPS} # backoffice proxy admin api over https
      https = ${?OTOROSHI_ADMIN_API_HTTPS} # backoffice proxy admin api over https
      local = true # backoffice proxy admin api on localhost
      local = ${?ADMIN_API_LOCAL} # backoffice proxy admin api on localhost
      local = ${?OTOROSHI_ADMIN_API_LOCAL} # backoffice proxy admin api on localhost
    }
  }
  claim {
    sharedKey = &quot;secret&quot; # the default secret used to sign otoroshi exchange protocol tokens
    sharedKey = ${?CLAIM_SHAREDKEY} # the default secret used to sign otoroshi exchange protocol tokens
    sharedKey = ${?OTOROSHI_CLAIM_SHAREDKEY} # the default secret used to sign otoroshi exchange protocol tokens
  }
  webhooks {
  }
  redis { # configuration to fetch/store otoroshi state from a redis datastore using rediscala
    host = &quot;localhost&quot;
    host = ${?REDIS_HOST}
    host = ${?OTOROSHI_REDIS_HOST}
    port = 6379
    port = ${?REDIS_PORT}
    port = ${?OTOROSHI_REDIS_PORT}
    password = ${?REDIS_PASSWORD}
    password = ${?OTOROSHI_REDIS_PASSWORD}
    windowSize = 99
    windowSize = ${?REDIS_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_REDIS_WINDOW_SIZE}
    slaves = []
    slavesStr = ${?REDIS_SLAVES}
    slavesStr = ${?OTOROSHI_REDIS_SLAVES}
    slavesStr = ${?REDIS_MEMBERS}
    slavesStr = ${?OTOROSHI_REDIS_MEMBERS}
    useScan = false
    useScan =  ${?REDIS_USE_SCAN}
    useScan =  ${?OTOROSHI_REDIS_USE_SCAN}

    pool {
      members = []
      members = ${?REDIS_POOL_MEMBERS}
      members = ${?OTOROSHI_REDIS_POOL_MEMBERS}
    }

    mpool {
      members = []
      membersStr = ${?REDIS_MPOOL_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_MPOOL_MEMBERS}
    }

    lf {
      master {
        host = ${?REDIS_LF_HOST}
        host = ${?OTOROSHI_REDIS_LF_HOST}
        port = ${?REDIS_LF_PORT}
        port = ${?OTOROSHI_REDIS_LF_PORT}
        password = ${?REDIS_LF_PASSWORD}
        password = ${?OTOROSHI_REDIS_LF_PASSWORD}
      }
      slaves = []
      slavesStr = ${?REDIS_LF_SLAVES}
      slavesStr = ${?OTOROSHI_REDIS_LF_SLAVES}
      slavesStr = ${?REDIS_LF_MEMBERS}
      slavesStr = ${?OTOROSHI_REDIS_LF_MEMBERS}
    }

    sentinels {
      master = ${?REDIS_SENTINELS_MASTER}
      master = ${?OTOROSHI_REDIS_SENTINELS_MASTER}
      password = ${?REDIS_SENTINELS_PASSWORD}
      password = ${?OTOROSHI_REDIS_SENTINELS_PASSWORD}
      db = ${?REDIS_SENTINELS_DB}
      db = ${?OTOROSHI_REDIS_SENTINELS_DB}
      name = ${?REDIS_SENTINELS_NAME}
      name = ${?OTOROSHI_REDIS_SENTINELS_NAME}
      members = []
      membersStr = ${?REDIS_SENTINELS_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_SENTINELS_MEMBERS}

      lf {
        master = ${?REDIS_SENTINELS_LF_MASTER}
        master = ${?OTOROSHI_REDIS_SENTINELS_LF_MASTER}
        members = []
        membersStr = ${?REDIS_SENTINELS_LF_MEMBERS}
        membersStr = ${?OTOROSHI_REDIS_SENTINELS_LF_MEMBERS}
      }
    }

    cluster {
      members = []
      membersStr = ${?REDIS_CLUSTER_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_CLUSTER_MEMBERS}
    }

    lettuce { # configuration to fetch/store otoroshi state from a redis datastore using the lettuce driver (the next default one)
      connection = &quot;default&quot;
      connection = ${?REDIS_LETTUCE_CONNECTION}
      connection = ${?OTOROSHI_REDIS_LETTUCE_CONNECTION}
      uri =  ${?REDIS_LETTUCE_URI}
      uri =  ${?OTOROSHI_REDIS_LETTUCE_URI}
      uri =  ${?REDIS_URL}
      uri =  ${?OTOROSHI_REDIS_URL}
      uris = []
      urisStr = ${?REDIS_LETTUCE_URIS}
      urisStr = ${?OTOROSHI_REDIS_LETTUCE_URIS}
      readFrom = &quot;MASTER_PREFERRED&quot;
      readFrom = ${?REDIS_LETTUCE_READ_FROM}
      readFrom = ${?OTOROSHI_REDIS_LETTUCE_READ_FROM}
      startTLS = false
      startTLS = ${?REDIS_LETTUCE_START_TLS}
      startTLS = ${?OTOROSHI_REDIS_LETTUCE_START_TLS}
      verifyPeers = true
      verifyPeers = ${?REDIS_LETTUCE_VERIFY_PEERS}
      verifyPeers = ${?OTOROSHI_REDIS_LETTUCE_VERIFY_PEERS}
    }
  }
  inmemory { # configuration to fetch/store otoroshi state in memory
    windowSize = 99
    windowSize = ${?INMEMORY_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_INMEMORY_WINDOW_SIZE}
    experimental = false
    experimental = ${?INMEMORY_EXPERIMENTAL_STORE}
    experimental = ${?OTOROSHI_INMEMORY_EXPERIMENTAL_STORE}
    optimized = false
    optimized = ${?INMEMORY_OPTIMIZED}
    optimized = ${?OTOROSHI_INMEMORY_OPTIMIZED}
    modern = false
    modern =  ${?INMEMORY_MODERN}
    modern =  ${?OTOROSHI_INMEMORY_MODERN}
  }
  filedb { # configuration to fetch/store otoroshi state from a file
    windowSize = 99
    windowSize = ${?FILEDB_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_FILEDB_WINDOW_SIZE}
    path = &quot;./filedb/state.ndjson&quot;
    path = ${?FILEDB_PATH}
    path = ${?OTOROSHI_FILEDB_PATH}
  }
  httpdb { # configuration to fetch/store otoroshi state from an http endpoint
    url = &quot;http://127.0.0.1:8888/worker-0/state.json&quot;
    headers = {}
    timeout = 10000
    pollEvery = 10000
  }
  s3db { # configuration to fetch/store otoroshi state from a S3 bucket
    bucket = &quot;otoroshi-states&quot;
    bucket = ${?OTOROSHI_DB_S3_BUCKET}
    endpoint = &quot;https://otoroshi-states.foo.bar&quot;
    endpoint = ${?OTOROSHI_DB_S3_ENDPOINT}
    region = &quot;eu-west-1&quot;
    region = ${?OTOROSHI_DB_S3_REGION}
    access = &quot;secret&quot;
    access = ${?OTOROSHI_DB_S3_ACCESS}
    secret = &quot;secret&quot;
    secret = ${?OTOROSHI_DB_S3_SECRET}
    key = &quot;/otoroshi/states/state&quot;
    key = ${?OTOROSHI_DB_S3_KEY}
    chunkSize = 8388608
    chunkSize = ${?OTOROSHI_DB_S3_CHUNK_SIZE}
    v4auth = true
    v4auth = ${?OTOROSHI_DB_S3_V4_AUTH}
    writeEvery = 60000 # write interval
    writeEvery = ${?OTOROSHI_DB_S3_WRITE_EVERY} # write interval
    acl = &quot;Private&quot;
    acl = ${?OTOROSHI_DB_S3_ACL}
  }
  pg { # postrgesql settings. everything possible with the client
    uri = ${?PG_URI}
    uri = ${?OTOROSHI_PG_URI}
    uri = ${?POSTGRESQL_ADDON_URI}
    uri = ${?OTOROSHI_POSTGRESQL_ADDON_URI}
    poolSize = 20
    poolSize = ${?PG_POOL_SIZE}
    poolSize = ${?OTOROSHI_PG_POOL_SIZE}
    port = 5432
    port = ${?PG_PORT}
    port = ${?OTOROSHI_PG_PORT}
    host = &quot;localhost&quot;
    host = ${?PG_HOST}
    host = ${?OTOROSHI_PG_HOST}
    database = &quot;otoroshi&quot;
    database = ${?PG_DATABASE}
    database = ${?OTOROSHI_PG_DATABASE}
    user = &quot;otoroshi&quot;
    user = ${?PG_USER}
    user = ${?OTOROSHI_PG_USER}
    password = &quot;otoroshi&quot;
    password = ${?PG_PASSWORD}
    password = ${?OTOROSHI_PG_PASSWORD}
    logQueries = ${?PG_DEBUG_QUERIES}
    logQueries = ${?OTOROSHI_PG_DEBUG_QUERIES}
    avoidJsonPath = false
    avoidJsonPath = ${?PG_AVOID_JSON_PATH}
    avoidJsonPath = ${?OTOROSHI_PG_AVOID_JSON_PATH}
    optimized = true
    optimized = ${?PG_OPTIMIZED}
    optimized = ${?OTOROSHI_PG_OPTIMIZED}
    connect-timeout = ${?PG_CONNECT_TIMEOUT}
    connect-timeout = ${?OTOROSHI_PG_CONNECT_TIMEOUT}
    idle-timeout = ${?PG_IDLE_TIMEOUT}
    idle-timeout = ${?OTOROSHI_PG_IDLE_TIMEOUT}
    log-activity = ${?PG_LOG_ACTIVITY}
    log-activity = ${?OTOROSHI_PG_LOG_ACTIVITY}
    pipelining-limit = ${?PG_PIPELINING_LIMIT}
    pipelining-limit = ${?OTOROSHI_PG_PIPELINING_LIMIT}
    ssl {
      enabled = false
      enabled = ${?PG_SSL_ENABLED}
      enabled = ${?OTOROSHI_PG_SSL_ENABLED}
      mode = &quot;verify_ca&quot;
      mode = ${?PG_SSL_MODE}
      mode = ${?OTOROSHI_PG_SSL_MODE}
      trusted-certs-path = []
      trusted-certs = []
      trusted-cert-path = ${?PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert-path = ${?OTOROSHI_PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert = ${?PG_SSL_TRUSTED_CERT}
      trusted-cert = ${?OTOROSHI_PG_SSL_TRUSTED_CERT}
      client-certs-path = []
      client-certs = []
      client-cert-path = ${?PG_SSL_CLIENT_CERT_PATH}
      client-cert-path = ${?OTOROSHI_PG_SSL_CLIENT_CERT_PATH}
      client-cert = ${?PG_SSL_CLIENT_CERT}
      client-cert = ${?OTOROSHI_PG_SSL_CLIENT_CERT}
      trust-all = ${?PG_SSL_TRUST_ALL}
      trust-all = ${?OTOROSHI_PG_SSL_TRUST_ALL}
    }
  }
  cassandra { # cassandra settings. everything possible with the client
    windowSize = 99
    windowSize = ${?CASSANDRA_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_CASSANDRA_WINDOW_SIZE}
    host = &quot;127.0.0.1&quot;
    host = ${?CASSANDRA_HOST}
    host = ${?OTOROSHI_CASSANDRA_HOST}
    port = 9042
    port = ${?CASSANDRA_PORT}
    port = ${?OTOROSHI_CASSANDRA_PORT}
    replicationFactor = 1
    replicationFactor = ${?CASSANDRA_REPLICATION_FACTOR}
    replicationFactor = ${?OTOROSHI_CASSANDRA_REPLICATION_FACTOR}
    replicationOptions = ${?CASSANDRA_REPLICATION_OPTIONS}
    replicationOptions = ${?OTOROSHI_CASSANDRA_REPLICATION_OPTIONS}
    durableWrites = true
    durableWrites = ${?CASSANDRA_DURABLE_WRITES}
    durableWrites = ${?OTOROSHI_CASSANDRA_DURABLE_WRITES}
    basic.contact-points = [ ${app.cassandra.host}&quot;:&quot;${app.cassandra.port} ]
    basic.session-name = &quot;otoroshi&quot;
    basic.session-name = ${?OTOROSHI_CASSANDRA_SESSION_NAME}
    basic.session-keyspace = ${?OTOROSHI_CASSANDRA_SESSION_KEYSPACE}
    basic.config-reload-interval = 5 minutes
    basic.request {
      timeout = 10 seconds
      consistency = LOCAL_ONE
      consistency = ${?OTOROSHI_CASSANDRA_CONSISTENCY}
      page-size = 5000
      page-size = ${?OTOROSHI_CASSANDRA_PAGE_SIZE}
      serial-consistency = SERIAL
      serial-consistency = ${?OTOROSHI_CASSANDRA_SERIAL_CONSISTENCY}
      default-idempotence = false
      default-idempotence = ${?OTOROSHI_CASSANDRA_DEFAULT_IDEMPOTENCE}
    }
    basic.load-balancing-policy {
      class = DefaultLoadBalancingPolicy
      local-datacenter = datacenter1
      local-datacenter = ${?OTOROSHI_CASSANDRA_LOCAL_DATACENTER}
      # filter.class=
      slow-replica-avoidance = true
    }
    basic.cloud {
      # secure-connect-bundle = /location/of/secure/connect/bundle
    }
    basic.application {
      # name =
      # version =
    }
    basic.graph {
      # name = your-graph-name
      traversal-source = &quot;g&quot;
      # is-system-query = false
      # read-consistency-level = LOCAL_QUORUM
      # write-consistency-level = LOCAL_ONE
      # timeout = 10 seconds
    }
    advanced.connection {
      connect-timeout = 5 seconds
      init-query-timeout = 500 milliseconds
      set-keyspace-timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      pool {
        local {
          size = 1
        }
        remote {
          size = 1
        }
      }
      max-requests-per-connection = 1024
      max-orphan-requests = 256
      warn-on-init-error = true
    }
    advanced.reconnect-on-init = false
    advanced.reconnection-policy {
      class = ExponentialReconnectionPolicy
      base-delay = 1 second
      max-delay = 60 seconds
    }
    advanced.retry-policy {
      class = DefaultRetryPolicy
    }
    advanced.speculative-execution-policy {
      class = NoSpeculativeExecutionPolicy
      # max-executions = 3
      # delay = 100 milliseconds
    }
    advanced.auth-provider {
      # class = PlainTextAuthProvider
      username = ${?CASSANDRA_USERNAME}
      username = ${?OTOROSHI_CASSANDRA_USERNAME}
      password = ${?CASSANDRA_PASSWORD}
      password = ${?OTOROSHI_CASSANDRA_PASSWORD}
      authorization-id = ${?OTOROSHI_CASSANDRA_AUTHORIZATION_ID}
      //service = &quot;cassandra&quot;
      # login-configuration {
      #   principal = &quot;cassandra@DATASTAX.COM&quot;
      #   useKeyTab = &quot;true&quot;
      #   refreshKrb5Config = &quot;true&quot;
      #   keyTab = &quot;/path/to/keytab/file&quot;
      # }
      # sasl-properties {
      #   javax.security.sasl.qop = &quot;auth-conf&quot;
      # }
    }
    advanced.ssl-engine-factory {
      # class = DefaultSslEngineFactory
      # cipher-suites = [ &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot; ]
      # hostname-validation = true
      # truststore-path = /path/to/client.truststore
      # truststore-password = password123
      # keystore-path = /path/to/client.keystore
      # keystore-password = password123
    }
    advanced.timestamp-generator {
      class = AtomicTimestampGenerator
      drift-warning {
        threshold = 1 second
        interval = 10 seconds
      }
      force-java-clock = false
    }
    advanced.request-tracker {
      class = NoopRequestTracker
      logs {
        # success.enabled = true
        slow {
          # threshold = 1 second
          # enabled = true
        }
        # error.enabled = true
        # max-query-length = 500
        # show-values = true
        # max-value-length = 50
        # max-values = 50
        # show-stack-traces = true
      }
    }
    advanced.throttler {
      class = PassThroughRequestThrottler
      # max-queue-size = 10000
      # max-concurrent-requests = 10000
      # max-requests-per-second = 10000
      # drain-interval = 10 milliseconds
    }
    advanced.node-state-listener.class = NoopNodeStateListener
    advanced.schema-change-listener.class = NoopSchemaChangeListener
    advanced.address-translator {
      class = PassThroughAddressTranslator
    }
    advanced.resolve-contact-points = true
    advanced.protocol {
      version = V4
      version = ${?OTOROSHI_CASSANDRA_PROTOCOL_VERSION}
      compression = lz4
      compression = ${?OTOROSHI_CASSANDRA_PROTOCOL_COMPRESSION}
      max-frame-length = 256 MB
    }
    advanced.request {
      warn-if-set-keyspace = false
      trace {
        attempts = 5
        interval = 3 milliseconds
        consistency = ONE
      }
      log-warnings = true
    }
    advanced.graph {
      # sub-protocol = &quot;graphson-2.0&quot;
      paging-enabled = &quot;AUTO&quot;
      paging-options {
        page-size = ${datastax-java-driver.advanced.continuous-paging.page-size}
        max-pages = ${datastax-java-driver.advanced.continuous-paging.max-pages}
        max-pages-per-second = ${datastax-java-driver.advanced.continuous-paging.max-pages-per-second}
        max-enqueued-pages = ${datastax-java-driver.advanced.continuous-paging.max-enqueued-pages}
      }
    }
    advanced.continuous-paging {
      page-size = ${datastax-java-driver.basic.request.page-size}
      page-size-in-bytes = false
      max-pages = 0
      max-pages-per-second = 0
      max-enqueued-pages = 4
      timeout {
        first-page = 2 seconds
        other-pages = 1 second
      }
    }
    advanced.monitor-reporting {
      enabled = true
    }
    advanced.metrics {
      session {
        enabled = [
          # bytes-sent,
          # bytes-received
          # connected-nodes,
          # cql-requests,
          # cql-client-timeouts,
          # cql-prepared-cache-size,
          # throttling.delay,
          # throttling.queue-size,
          # throttling.errors,
          # continuous-cql-requests,
          # graph-requests,
          # graph-client-timeouts
        ]
        cql-requests {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        throttling.delay {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        continuous-cql-requests {
          highest-latency = 120 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        graph-requests {
          highest-latency = 12 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
      }
      node {
        enabled = [
          # pool.open-connections,
          # pool.available-streams,
          # pool.in-flight,
          # pool.orphaned-streams,
          # bytes-sent,
          # bytes-received,
          # cql-messages,
          # errors.request.unsent,
          # errors.request.aborted,
          # errors.request.write-timeouts,
          # errors.request.read-timeouts,
          # errors.request.unavailables,
          # errors.request.others,
          # retries.total,
          # retries.aborted,
          # retries.read-timeout,
          # retries.write-timeout,
          # retries.unavailable,
          # retries.other,
          # ignores.total,
          # ignores.aborted,
          # ignores.read-timeout,
          # ignores.write-timeout,
          # ignores.unavailable,
          # ignores.other,
          # speculative-executions,
          # errors.connection.init,
          # errors.connection.auth,
          # graph-messages,
        ]
        cql-messages {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
        graph-messages {
          highest-latency = 3 seconds
          significant-digits = 3
          refresh-interval = 5 minutes
        }
      }
    }
    advanced.socket {
      tcp-no-delay = true
      //keep-alive = false
      //reuse-address = true
      //linger-interval = 0
      //receive-buffer-size = 65535
      //send-buffer-size = 65535
    }
    advanced.heartbeat {
      interval = 30 seconds
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
    }
    advanced.metadata {
      topology-event-debouncer {
        window = 1 second
        max-events = 20
      }
      schema {
        enabled = true
        # refreshed-keyspaces = [ &quot;ks1&quot;, &quot;ks2&quot; ]
        request-timeout = ${datastax-java-driver.basic.request.timeout}
        request-page-size = ${datastax-java-driver.basic.request.page-size}
        debouncer {
          window = 1 second
          max-events = 20
        }
      }
      token-map.enabled = true
    }
    advanced.control-connection {
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      schema-agreement {
        interval = 200 milliseconds
        timeout = 10 seconds
        warn-on-failure = true
      }
    }
    advanced.prepared-statements {
      prepare-on-all-nodes = true
      reprepare-on-up {
        enabled = true
        check-system-table = false
        max-statements = 0
        max-parallelism = 100
        timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      }
    }
    advanced.netty {
      daemon = false
      io-group {
        size = 0
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      admin-group {
        size = 2
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      timer {
        tick-duration = 100 milliseconds
        ticks-per-wheel = 2048
      }
    }
    advanced.coalescer {
      max-runs-with-no-work = 5
      reschedule-interval = 10 microseconds
    }
  }
  actorsystems {
    otoroshi {
      akka { # otoroshi actorsystem configuration
        version = ${akka.version}
        log-dead-letters-during-shutdown = false
        jvm-exit-on-fatal-error = false
        default-dispatcher {
          type = Dispatcher
          executor = &quot;fork-join-executor&quot;
          fork-join-executor {
            parallelism-factor = 4.0
            parallelism-factor = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_FACTOR}
            parallelism-min = 8
            parallelism-min = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_MIN}
            parallelism-max = 128
            parallelism-max = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_MAX}
            task-peeking-mode = &quot;FIFO&quot;
            task-peeking-mode = ${?OTOROSHI_CORE_DISPATCHER_TASK_PEEKING_MODE}
          }
          throughput = 1
          throughput = ${?OTOROSHI_CORE_DISPATCHER_THROUGHPUT}
        }
        http {
          parsing {
            max-uri-length             = 4k
            max-uri-length             = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_URI_LENGTH}
            max-method-length          = 16
            max-method-length          = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_METHOD_LENGTH}
            max-response-reason-length = 64
            max-response-reason-length = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_RESPONSE_REASON_LENGTH}
            max-header-name-length     = 128
            max-header-name-length     = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_NAME_LENGTH}
            max-header-value-length    = 16k
            max-header-value-length    = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_VALUE_LENGTH}
            max-header-count           = 128
            max-header-count           = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_COUNT}
            max-chunk-ext-length       = 256
            max-chunk-ext-length       = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CHUNK_EXT_LENGTH}
            max-chunk-size             = 256m
            max-chunk-size             = ${?AKKA_HTTP_CLIENT_MAX_CHUNK_SIZE}
            max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_CHUNK_SIZE}
            max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CHUNK_SIZE}
            max-content-length         = infinite
            max-content-length         = ${?AKKA_HTTP_CLIENT_MAX_CONTENT_LENGHT}
            max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_CONTENT_LENGHT}
            max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CONTENT_LENGHT}
            max-to-strict-bytes        = infinite
            max-to-strict-bytes        = ${?AKKA_HTTP_CLIENT_MAX_TO_STRICT_BYTES}
            max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_TO_STRICT_BYTES}
            max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_TO_STRICT_BYTES}
          }
        }
      }
    }
    datastore {
      akka {
        version = ${akka.version}
        log-dead-letters-during-shutdown = false
        jvm-exit-on-fatal-error = false
        default-dispatcher {
          type = Dispatcher
          executor = &quot;fork-join-executor&quot;
          fork-join-executor {
            parallelism-factor = 4.0
            parallelism-min = 4
            parallelism-max = 64
            task-peeking-mode = &quot;FIFO&quot;
          }
          throughput = 1
        }
      }
    }
  }
}

otoroshi {
  domain = ${?app.domain}
  maintenanceMode = false # enable global maintenance mode
  maintenanceMode = ${?OTOROSHI_MAINTENANCE_MODE_ENABLED} # enable global maintenance mode
  secret = &quot;verysecretvaluethatyoumustoverwrite&quot; # the secret used to sign sessions
  secret = ${?OTOROSHI_SECRET}  # the secret used to sign sessions
  admin-api-secret = ${?OTOROSHI_ADMIN_API_SECRET}  # the secret for admin api
  next {
    state-sync-interval = 10000
    state-sync-interval = ${?OTOROSHI_NEXT_STATE_SYNC_INTERVAL}
    export-reporting = false
    export-reporting = ${?OTOROSHI_NEXT_EXPORT_REPORTING}
    monitor-proxy-state-size = false
    monitor-proxy-state-size = ${?OTOROSHI_NEXT_MONITOR_PROXY_STATE_SIZE}
    monitor-datastore-size = false
    monitor-datastore-size = ${?OTOROSHI_NEXT_MONITOR_DATASTORE_SIZE}
    plugins {
      merge-sync-steps = true
      merge-sync-steps = ${?OTOROSHI_NEXT_PLUGINS_MERGE_SYNC_STEPS}
      apply-legacy-checks = true
      apply-legacy-checks = ${?OTOROSHI_NEXT_PLUGINS_APPLY_LEGACY_CHECKS}
    }
    experimental {
    	netty-client {
    		wiretap = false
    		wiretap = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_WIRETAP}
    		enforce = false
    		enforce = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_ENFORCE}
    		enforce-akka = false
				enforce-akka = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_ENFORCE_AKKA}
    	}
   		netty-server {
   			enabled = false
   			enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_ENABLED}
   			new-engine-only = false
   			new-engine-only = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NEW_ENGINE_ONLY}
   			host = &quot;0.0.0.0&quot;
   			host = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HOST}
   			http-port = 10049
   			http-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_PORT}
   			exposed-http-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_EXPOSED_HTTP_PORT}
   			https-port = 10048
   			https-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTPS_PORT}
				exposed-https-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_EXPOSED_HTTPS_PORT}
   			wiretap = false
   			wiretap = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_WIRETAP}
   			accesslog = false
   			accesslog = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_ACCESSLOG}
        threads = 0
        threads = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_THREADS}
   			parser {
   				allowDuplicateContentLengths = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_ALLOW_DUPLICATE_CONTENT_LENGTHS}
          validateHeaders = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_VALIDATE_HEADERS}
          h2cMaxContentLength = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_H_2_C_MAX_CONTENT_LENGTH}
          initialBufferSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_INITIAL_BUFFER_SIZE}
          maxHeaderSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_HEADER_SIZE}
          maxInitialLineLength = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_INITIAL_LINE_LENGTH}
          maxChunkSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_CHUNK_SIZE}
   			}
   			http2 {
					enabled = true
					enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP2_ENABLED}
					h2c = true
					h2c = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP2_H2C}
				}
   			http3 {
   				enabled = false
   				enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_ENABLED}
   				port = 10048
   				port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_PORT}
   				exposedPort = 10048
   				exposedPort = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_EXPOSED_PORT}
          initialMaxStreamsBidirectional = 100000
          initialMaxStreamsBidirectional = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAMS_BIDIRECTIONAL}
          initialMaxStreamDataBidirectionalRemote = 1000000
          initialMaxStreamDataBidirectionalRemote = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAM_DATA_BIDIRECTIONAL_REMOTE}
          initialMaxStreamDataBidirectionalLocal = 1000000
          initialMaxStreamDataBidirectionalLocal = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAM_DATA_BIDIRECTIONAL_LOCAL}
          initialMaxData = 10000000
          initialMaxData = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_DATA}
          maxRecvUdpPayloadSize = 1500
          maxRecvUdpPayloadSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_MAX_RECV_UDP_PAYLOAD_SIZE}
          maxSendUdpPayloadSize = 1500
          maxSendUdpPayloadSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_MAX_SEND_UDP_PAYLOAD_SIZE}
          disableQpackDynamicTable = true
          disableQpackDynamicTable = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_DISABLE_QPACK_DYNAMIC_TABLE}
   			}
   			native {
   				enabled = true
   				enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NATIVE_ENABLED}
   				driver = &quot;Auto&quot; # possible values are Auto, Epoll, KQueue, IOUring
   				driver = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NATIVE_DRIVER}
   			}
   		}
    }
  }
  options {
    bypassUserRightsCheck = false
    bypassUserRightsCheck = ${?OTOROSHI_OPTIONS_BYPASSUSERRIGHTSCHECK}
    emptyContentLengthIsChunked = true
    emptyContentLengthIsChunked = ${?OTOROSHI_OPTIONS_EMPTYCONTENTLENGTHISCHUNKED}
    detectApiKeySooner = true
    detectApiKeySooner = ${?OTOROSHI_OPTIONS_DETECTAPIKEYSOONER}
    sendClientChainAsPem = false
    sendClientChainAsPem = ${?OTOROSHI_OPTIONS_SENDCLIENTCHAINASPEM}
    useOldHeadersComposition = false
    useOldHeadersComposition = ${?OTOROSHI_OPTIONS_USEOLDHEADERSCOMPOSITION}
    manualDnsResolve = true
    manualDnsResolve = ${?OTOROSHI_OPTIONS_MANUALDNSRESOLVE}
    useEventStreamForScriptEvents = true
    useEventStreamForScriptEvents = ${?OTOROSHI_OPTIONS_USEEVENTSTREAMFORSCRIPTEVENTS}
    trustXForwarded = true
    trustXForwarded = ${?OTOROSHI_OPTIONS_TRUST_XFORWARDED}
    disableFunnyLogos = false
    disableFunnyLogos = ${?OTOROSHI_OPTIONS_DISABLE_FUNNY_LOGOS}
    staticExposedDomain = ${?OTOROSHI_OPTIONS_STATIC_EXPOSED_DOMAIN}
  }
  wasm {
  	cache {
  		ttl = 10000
  		ttl = ${?OTOROSHI_WASM_CACHE_TTL}
  		size = 100
  		size = ${?OTOROSHI_WASM_CACHE_SIZE}
  	}
  	queue {
  		buffer {
  			size = 2048
  			size = ${?OTOROSHI_WASM_QUEUE_BUFFER_SIZE}
  		}
  	}
  }
  anonymous-reporting {
  	enabled = true
		enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_ENABLED}
  	redirect = false
		url = ${?OTOROSHI_ANONYMOUS_REPORTING_REDIRECT}
  	url = &quot;https://reporting.otoroshi.io/ingest&quot;
  	url = ${?OTOROSHI_ANONYMOUS_REPORTING_URL}
  	timeout = 60000
  	timeout = ${?OTOROSHI_ANONYMOUS_REPORTING_TIMEOUT}
  	tls {
			# certs = []
			# trustedCerts = []
			enabled = false # enable mtls
			enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_ENABLED}  # enable mtls
			loose = false # loose verification
			loose = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_LOOSE}  # loose verification
			trustAll = false # trust any CA
			trustAll = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_ALL} # trust any CA
		}
		proxy {
			enabled = false # enable proxy
			enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_ENABLED}  # enable proxy
			host = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_HOST},
			port = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PORT},
			principal = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PRINCIPAL},
			password = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PASSWORD},
			ntlmDomain = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_DOMAIN},
			encoding = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_ENCODING},
		}
  }
  backoffice {
    flags {
      useAkkaHttpClient = false
      useAkkaHttpClient = ${?OTOROSHI_BACKOFFICE_FLAGS_USE_AKKA_HTTP_CLIENT}
      logUrl = false
      logUrl = ${?OTOROSHI_BACKOFFICE_FLAGS_LOG_URL}
      requestTimeout = 60000
      requestTimeout = ${?OTOROSHI_BACKOFFICE_FLAGS_REQUEST_TIMEOUT}
    }
  }
  sessions {
    secret = ${otoroshi.secret}
    secret = ${?OTOROSHI_SESSIONS_SECRET}
  }
  cache {
    enabled = false
    enabled = ${?USE_CACHE}
    enabled = ${?OTOROSHI_USE_CACHE}
    enabled = ${?OTOROSHI_ENTITIES_CACHE_ENABLED}
    ttl = 2000
    ttl = ${?OTOROSHI_ENTITIES_CACHE_TTL}
  }
  metrics {
    enabled = true
    enabled = ${?OTOROSHI_METRICS_ENABLED}
    every = 30000
    every = ${?OTOROSHI_METRICS_EVERY}
    accessKey = ${?app.health.accessKey}
    accessKey = ${?OTOROSHI_app.health.accessKey}
    accessKey = ${?OTOROSHI_METRICS_ACCESS_KEY}
  }
  plugins {
    packages = []
    packagesStr = ${?OTOROSHI_PLUGINS_SCAN_PACKAGES}
    print = false
    print = ${?OTOROSHI_PLUGINS_PRINT}
  }
  scripts {
    enabled = true # enable scripts
    enabled = ${?OTOROSHI_SCRIPTS_ENABLED} # enable scripts
    static { # settings for statically enabled script/plugins
      enabled = false
      enabled = ${?OTOROSHI_SCRIPTS_STATIC_ENABLED}
      transformersRefs = []
      transformersRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_TRANSFORMER_REFS}
      transformersConfig = {}
      transformersConfigStr= ${?OTOROSHI_SCRIPTS_STATIC_TRANSFORMER_CONFIG}
      validatorRefs = []
      validatorRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_VALIDATOR_REFS}
      validatorConfig = {}
      validatorConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_VALIDATOR_CONFIG}
      preRouteRefs = []
      preRouteRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_PRE_ROUTE_REFS}
      preRouteConfig = {}
      preRouteConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_PRE_ROUTE_CONFIG}
      sinkRefs = []
      sinkRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_SINK_REFS}
      sinkConfig = {}
      sinkConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_SINK_CONFIG}
      jobsRefs = []
      jobsRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_JOBS_REFS}
      jobsConfig = {}
      jobsConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_JOBS_CONFIG}
    }
  }
  tls = ${otoroshi.ssl}
  ssl {
    # the cipher suites used by otoroshi TLS termination
    cipherSuitesJDK11Plus = [&quot;TLS_AES_256_GCM_SHA384&quot;, &quot;TLS_AES_128_GCM_SHA256&quot;, &quot;TLS_CHACHA20_POLY1305_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&quot;]
    cipherSuitesJDK11 = [&quot;TLS_AES_256_GCM_SHA384&quot;, &quot;TLS_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&quot;]
    cipherSuitesJDK8 = [&quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_DHE_DSS_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_DHE_DSS_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;SSL_RSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA&quot;, &quot;SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA&quot;, &quot;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&quot;]
    # cipherSuites = [&quot;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;, &quot;TLS_AES_128_GCM_SHA256&quot;, &quot;TLS_AES_256_GCM_SHA384&quot;]
    cipherSuites = ${otoroshi.ssl.cipherSuitesJDK11}
    # the protocols used by otoroshi TLS termination
    protocolsJDK11 = [&quot;TLSv1.3&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1&quot;]
    protocolsJDK8 = [&quot;SSLv2Hello&quot;, &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;]
    modernProtocols = [&quot;TLSv1.3&quot;, &quot;TLSv1.2&quot;]
    protocols = ${otoroshi.ssl.modernProtocols}
    # the JDK cacert access
    cacert {
      path = &quot;$JAVA_HOME/lib/security/cacerts&quot;
      password = &quot;changeit&quot;
    }
    # the mtls mode
    fromOutside {
      clientAuth = &quot;None&quot;
      clientAuth = ${?SSL_OUTSIDE_CLIENT_AUTH}
      clientAuth = ${?OTOROSHI_SSL_OUTSIDE_CLIENT_AUTH}
    }
    # the default trust mode
    trust {
      all = false
      all = ${?OTOROSHI_SSL_TRUST_ALL}
    }
    rootCa {
    	ca = ${?OTOROSHI_SSL_ROOTCA_CA}
    	cert = ${?OTOROSHI_SSL_ROOTCA_CERT}
    	key = ${?OTOROSHI_SSL_ROOTCA_KEY}
    	importCa = false
			importCa = ${?OTOROSHI_SSL_ROOTCA_IMPORTCA}
    }
    # some initial cacert access, useful to include non standard CA when starting
    initialCacert = ${?CLUSTER_WORKER_INITIAL_CACERT}
    initialCacert = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CACERT}
    initialCacert = ${?INITIAL_CACERT}
    initialCacert = ${?OTOROSHI_INITIAL_CACERT}
    initialCert = ${?CLUSTER_WORKER_INITIAL_CERT}
    initialCert = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CERT}
    initialCert = ${?INITIAL_CERT}
    initialCert = ${?OTOROSHI_INITIAL_CERT}
    initialCertKey = ${?CLUSTER_WORKER_INITIAL_CERT_KEY}
    initialCertKey = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CERT_KEY}
    initialCertKey = ${?INITIAL_CERT_KEY}
    initialCertKey = ${?OTOROSHI_INITIAL_CERT_KEY}
    initialCertImportCa = ${?OTOROSHI_INITIAL_CERT_IMPORTCA}
    # initialCerts = []
  }
  cluster {
    mode = &quot;off&quot; # can be &quot;off&quot;, &quot;leader&quot;, &quot;worker&quot;
    mode = ${?CLUSTER_MODE} # can be &quot;off&quot;, &quot;leader&quot;, &quot;worker&quot;
    mode = ${?OTOROSHI_CLUSTER_MODE} # can be &quot;off&quot;, &quot;leader&quot;, &quot;worker&quot;
    compression = -1 # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9
    compression = ${?CLUSTER_COMPRESSION} # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9
    compression = ${?OTOROSHI_CLUSTER_COMPRESSION} # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9
    retryDelay = 300 # the delay before retrying a request to leader
    retryDelay = ${?CLUSTER_RETRY_DELAY} # the delay before retrying a request to leader
    retryDelay = ${?OTOROSHI_CLUSTER_RETRY_DELAY} # the delay before retrying a request to leader
    retryFactor = 2 # the retry factor to avoid high load on failing nodes
    retryFactor = ${?CLUSTER_RETRY_FACTOR} # the retry factor to avoid high load on failing nodes
    retryFactor = ${?OTOROSHI_CLUSTER_RETRY_FACTOR} # the retry factor to avoid high load on failing nodes
    selfAddress = ${?CLUSTER_SELF_ADDRESS} # the instance ip address
    selfAddress = ${?OTOROSHI_CLUSTER_SELF_ADDRESS} # the instance ip address
    autoUpdateState = true # auto update cluster state with a job (more efficient)
    autoUpdateState = ${?CLUSTER_AUTO_UPDATE_STATE} # auto update cluster state with a job (more efficient
    autoUpdateState = ${?OTOROSHI_CLUSTER_AUTO_UPDATE_STATE} # auto update cluster state with a job (more efficient
    backup {
      enabled = false
      enabled = ${?OTOROSHI_CLUSTER_BACKUP_ENABLED}
			kind = &quot;S3&quot;
			kind = ${?OTOROSHI_CLUSTER_BACKUP_KIND}
			instance {
				can-write = false
				can-write = ${?OTOROSHI_CLUSTER_BACKUP_INSTANCE_CAN_WRITE}
				can-read = false
				can-read = ${?OTOROSHI_CLUSTER_BACKUP_INSTANCE_CAN_READ}
			}
			s3 {
				bucket = ${?OTOROSHI_CLUSTER_BACKUP_S3_BUCKET}
        endpoint = ${?OTOROSHI_CLUSTER_BACKUP_S3_ENDPOINT}
        region = ${?OTOROSHI_CLUSTER_BACKUP_S3_REGION}
        access = ${?OTOROSHI_CLUSTER_BACKUP_S3_ACCESSKEY}
        secret = ${?OTOROSHI_CLUSTER_BACKUP_S3_SECRET}
        path = ${?OTOROSHI_CLUSTER_BACKUP_S3_PATH}
        chunk-size = ${?OTOROSHI_CLUSTER_BACKUP_S3_CHUNK_SIZE}
        v4auth = ${?OTOROSHI_CLUSTER_BACKUP_S3_V4AUTH}
        acl = ${?OTOROSHI_CLUSTER_BACKUP_S3_ACL}
			}
    }
    relay { # relay routing settings
      enabled = false # enable relay routing
      enabled = ${?OTOROSHI_CLUSTER_RELAY_ENABLED} # enable relay routing
      leaderOnly = false
      leaderOnly = ${?OTOROSHI_CLUSTER_RELAY_LEADER_ONLY} # workers always pass through leader for relay routing
      location {
        provider = ${?otoroshi.instance.provider}
        provider = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_PROVIDER}
        zone = ${?otoroshi.instance.zone}
        zone = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_ZONE}
        region = ${?otoroshi.instance.region}
        region = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_REGION}
        datacenter = ${?otoroshi.instance.dc}
        datacenter = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_DATACENTER}
        rack = ${?otoroshi.instance.rack}
        rack = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_RACK}
      }
      exposition {
        url = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_URL}
        urls = []
        urlsStr = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_URLS}
        hostname = &quot;otoroshi-api.oto.tools&quot;
        hostname = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_HOSTNAME}
        clientId = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_CLIENT_ID}
        clientSecret = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_CLIENT_SECRET}
        ipAddress = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_IP_ADDRESS}
      }
    }
    mtls {
      # certs = []
      # trustedCerts = []
      enabled = false # enable mtls
      enabled = ${?CLUSTER_MTLS_ENABLED}  # enable mtls
      enabled = ${?OTOROSHI_CLUSTER_MTLS_ENABLED}  # enable mtls
      loose = false # loose verification
      loose = ${?CLUSTER_MTLS_LOOSE}  # loose verification
      loose = ${?OTOROSHI_CLUSTER_MTLS_LOOSE}  # loose verification
      trustAll = false # trust any CA
      trustAll = ${?CLUSTER_MTLS_TRUST_ALL} # trust any CA
      trustAll = ${?OTOROSHI_CLUSTER_MTLS_TRUST_ALL} # trust any CA
    }
    proxy {
     	enabled = false # enable proxy
			enabled = ${?CLUSTER_PROXY_ENABLED}  # enable proxy
			host = ${?CLUSTER_PROXY_HOST},
			port = ${?CLUSTER_PROXY_PORT},
			principal = ${?CLUSTER_PROXY_PRINCIPAL},
			password = ${?CLUSTER_PROXY_PASSWORD},
			ntlmDomain = ${?CLUSTER_PROXY_NTLM_DOMAIN},
			encoding = ${?CLUSTER_PROXY_ENCODING},
    }
    leader {
      name = ${?CLUSTER_LEADER_NAME} # the leader name
      name = ${?OTOROSHI_CLUSTER_LEADER_NAME} # the leader name
      urls = [&quot;http://127.0.0.1:8080&quot;] # the leader urls
      urlsStr = ${?CLUSTER_LEADER_URLS} # the leader urls
      urlsStr = ${?OTOROSHI_CLUSTER_LEADER_URLS} # the leader urls
      url = ${?CLUSTER_LEADER_URL} # the leader url
      url = ${?OTOROSHI_CLUSTER_LEADER_URL} # the leader url
      host = &quot;otoroshi-api.oto.tools&quot; # the leaders api hostname
      host = ${?CLUSTER_LEADER_HOST} # the leaders api hostname
      host = ${?OTOROSHI_CLUSTER_LEADER_HOST} # the leaders api hostname
      clientId = &quot;admin-api-apikey-id&quot; # the leaders apikey id to access otoroshi admin api
      clientId = ${?CLUSTER_LEADER_CLIENT_ID} # the leaders apikey id to access otoroshi admin api
      clientId = ${?OTOROSHI_CLUSTER_LEADER_CLIENT_ID} # the leaders apikey id to access otoroshi admin api
      clientSecret = &quot;admin-api-apikey-secret&quot; # the leaders apikey secret to access otoroshi admin api
      clientSecret = ${?CLUSTER_LEADER_CLIENT_SECRET} # the leaders apikey secret to access otoroshi admin api
      clientSecret = ${?OTOROSHI_CLUSTER_LEADER_CLIENT_SECRET} # the leaders apikey secret to access otoroshi admin api
      groupingBy = 50 # items grouping when streaming state
      groupingBy = ${?CLUSTER_LEADER_GROUP_BY} # items grouping when streaming state
      groupingBy = ${?OTOROSHI_CLUSTER_LEADER_GROUP_BY} # items grouping when streaming state
      cacheStateFor = 10000 # the ttl for local state cache
      cacheStateFor = ${?CLUSTER_LEADER_CACHE_STATE_FOR} # the ttl for local state cache
      cacheStateFor = ${?OTOROSHI_CLUSTER_LEADER_CACHE_STATE_FOR} # the ttl for local state cache
      stateDumpPath = ${?CLUSTER_LEADER_DUMP_PATH} # eventually a dump state path for debugging purpose
      stateDumpPath = ${?OTOROSHI_CLUSTER_LEADER_DUMP_PATH} # eventually a dump state path for debugging purpose
    }
    worker {
      name = ${?CLUSTER_WORKER_NAME} # the workers name
      name = ${?OTOROSHI_CLUSTER_WORKER_NAME} # the workers name
      retries = 3 # the number of retries when pushing quotas/pulling state
      retries = ${?CLUSTER_WORKER_RETRIES} # the number of retries when pushing quotas/pulling state
      retries = ${?OTOROSHI_CLUSTER_WORKER_RETRIES} # the number of retries when pushing quotas/pulling state
      timeout = 10000 # the workers timeout when interacting with leaders
      timeout = ${?CLUSTER_WORKER_TIMEOUT} # the workers timeout when interacting with leaders
      timeout = ${?OTOROSHI_CLUSTER_WORKER_TIMEOUT} # the workers timeout when interacting with leaders
      tenants = [] # the list of organization served by this worker. If none, it&#39;s all
      tenantsStr = ${?CLUSTER_WORKER_TENANTS} # the list (coma separated) of organization served by this worker. If none, it&#39;s all
      tenantsStr = ${?OTOROSHI_CLUSTER_WORKER_TENANTS} # the list (coma separated) of organization served by this worker. If none, it&#39;s all
      dbpath = ${?CLUSTER_WORKER_DB_PATH} # state dump path for debugging purpose
      dbpath = ${?OTOROSHI_CLUSTER_WORKER_DB_PATH} # state dump path for debugging purpose
      dataStaleAfter = 600000 # the amount of time needed to consider state is stale
      dataStaleAfter = ${?CLUSTER_WORKER_DATA_STALE_AFTER} # the amount of time needed to consider state is stale
      dataStaleAfter = ${?OTOROSHI_CLUSTER_WORKER_DATA_STALE_AFTER} # the amount of time needed to consider state is stale
      swapStrategy = &quot;Merge&quot; # the internal memory store strategy, can be Replace or Merge
      swapStrategy = ${?CLUSTER_WORKER_SWAP_STRATEGY} # the internal memory store strategy, can be Replace or Merge
      swapStrategy = ${?OTOROSHI_CLUSTER_WORKER_SWAP_STRATEGY} # the internal memory store strategy, can be Replace or Merge
      modern = false # use a modern store implementation
      modern = ${?CLUSTER_WORKER_STORE_MODERN}
      modern = ${?OTOROSHI_CLUSTER_WORKER_STORE_MODERN}
      state {
        retries = ${otoroshi.cluster.worker.retries} # the number of retries when pulling state
        retries = ${?CLUSTER_WORKER_STATE_RETRIES} # the number of retries when pulling state
        retries = ${?OTOROSHI_CLUSTER_WORKER_STATE_RETRIES} # the number of retries when pulling state
        pollEvery = 10000 # polling interval
        pollEvery = ${?CLUSTER_WORKER_POLL_EVERY} # polling interval
        pollEvery = ${?OTOROSHI_CLUSTER_WORKER_POLL_EVERY} # polling interval
        timeout = ${otoroshi.cluster.worker.timeout} # the workers timeout when polling state
        timeout = ${?CLUSTER_WORKER_POLL_TIMEOUT} # the workers timeout when polling state
        timeout = ${?OTOROSHI_CLUSTER_WORKER_POLL_TIMEOUT} # the workers timeout when polling state
      }
      quotas {
        retries = ${otoroshi.cluster.worker.retries} # the number of retries when pushing quotas
        retries = ${?CLUSTER_WORKER_QUOTAS_RETRIES} # the number of retries when pushing quotas
        retries = ${?OTOROSHI_CLUSTER_WORKER_QUOTAS_RETRIES} # the number of retries when pushing quotas
        pushEvery = 10000 # pushing interval
        pushEvery = ${?CLUSTER_WORKER_PUSH_EVERY} # pushing interval
        pushEvery = ${?OTOROSHI_CLUSTER_WORKER_PUSH_EVERY} # pushing interval
        timeout = ${otoroshi.cluster.worker.timeout} # the workers timeout when pushing quotas
        timeout = ${?CLUSTER_WORKER_PUSH_TIMEOUT} # the workers timeout when pushing quotas
        timeout = ${?OTOROSHI_CLUSTER_WORKER_PUSH_TIMEOUT} # the workers timeout when pushing quotas
      }
    }
    analytics { # settings for the analytics actor system which is separated from otoroshi default one for performance reasons
      pressure {
        enabled = true
        enabled = ${?OTOROSHI_ANALYTICS_PRESSURE_ENABLED}
      }
      actorsystem {
        akka {
          version = ${akka.version}
          log-dead-letters-during-shutdown = false
          jvm-exit-on-fatal-error = false
          default-dispatcher {
            type = Dispatcher
            executor = &quot;fork-join-executor&quot;
            fork-join-executor {
              parallelism-factor = 4.0
              parallelism-min = 4
              parallelism-max = 64
              task-peeking-mode = &quot;FIFO&quot;
            }
            throughput = 1
          }
          # http {
          #   parsing {
          #     max-uri-length             = 4k
          #     max-method-length          = 16
          #     max-response-reason-length = 64
          #     max-header-name-length     = 128
          #     max-header-value-length    = 16k
          #     max-header-count           = 128
          #     max-chunk-ext-length       = 256
          #     max-chunk-size             = 256m
          #     max-chunk-size             = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_CHUNK_SIZE}
          #     max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_CHUNK_SIZE}
          #     max-content-length         = infinite
          #     max-content-length         = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_CONTENT_LENGHT}
          #     max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_CONTENT_LENGHT}
          #     max-to-strict-bytes        = infinite
          #     max-to-strict-bytes        = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_TO_STRICT_BYTES}
          #     max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_TO_STRICT_BYTES}
          #   }
          # }
        }
      }
    }
  }
  headers { # the default headers value for specific otoroshi headers
    trace.label = &quot;Otoroshi-Viz-From-Label&quot;
    trace.from = &quot;Otoroshi-Viz-From&quot;
    trace.parent = &quot;Otoroshi-Parent-Request&quot;
    request.adminprofile = &quot;Otoroshi-Admin-Profile&quot;
    request.simpleapiclientid = &quot;x-api-key&quot;
    request.clientid = &quot;Otoroshi-Client-Id&quot;
    request.clientsecret = &quot;Otoroshi-Client-Secret&quot;
    request.id = &quot;Otoroshi-Request-Id&quot;
    request.timestamp = &quot;Otoroshi-Request-Timestamp&quot;
    request.bearer = &quot;Otoroshi-Token&quot;
    request.authorization = &quot;Otoroshi-Authorization&quot;
    response.proxyhost = &quot;Otoroshi-Proxied-Host&quot;
    response.error = &quot;Otoroshi-Error&quot;
    response.errormsg = &quot;Otoroshi-Error-Msg&quot;
    response.errorcause = &quot;Otoroshi-Error-Cause&quot;
    response.proxylatency = &quot;Otoroshi-Proxy-Latency&quot;
    response.upstreamlatency = &quot;Otoroshi-Upstream-Latency&quot;
    response.dailyquota = &quot;Otoroshi-Daily-Calls-Remaining&quot;
    response.monthlyquota = &quot;Otoroshi-Monthly-Calls-Remaining&quot;
    comm.state = &quot;Otoroshi-State&quot;
    comm.stateresp = &quot;Otoroshi-State-Resp&quot;
    comm.claim = &quot;Otoroshi-Claim&quot;
    healthcheck.test = &quot;Otoroshi-Health-Check-Logic-Test&quot;
    healthcheck.testresult = &quot;Otoroshi-Health-Check-Logic-Test-Result&quot;
    jwt.issuer = &quot;Otoroshi&quot;
    canary.tracker = &quot;Otoroshi-Canary-Id&quot;
    client.cert.chain = &quot;Otoroshi-Client-Cert-Chain&quot;

    request.jwtAuthorization = &quot;access_token&quot;
    request.bearerAuthorization = &quot;bearer_auth&quot;
    request.basicAuthorization = &quot;basic_auth&quot;
  }
  requests {
    validate = true
    validate = ${?OTOROSHI_REQUESTS_VALIDATE}
    maxUrlLength = ${akka.http.parsing.max-uri-length}
    maxCookieLength = ${akka.http.parsing.max-header-value-length}
    maxHeaderNameLength = ${akka.http.parsing.max-header-name-length}
    maxHeaderValueLength = ${akka.http.parsing.max-header-value-length}
  }
  jmx {
    enabled = false
    enabled = ${?OTOROSHI_JMX_ENABLED}
    port = 16000
    port = ${?OTOROSHI_JMX_PORT}
  }
  loggers {
  }
  provider {
    dashboardUrl = ${?OTOROSHI_PROVIDER_DASHBOARD_URL}
    jsUrl = ${?OTOROSHI_PROVIDER_JS_URL}
    cssUrl = ${?OTOROSHI_PROVIDER_CSS_URL}
    secret = &quot;secret&quot;
    secret = ${?OTOROSHI_PROVIDER_SECRET}
    title = &quot;Provider&#39;s dashboard&quot;
    title = ${?OTOROSHI_PROVIDER_TITLE}
  }
  healthcheck {
    workers = 4
    workers = ${?OTOROSHI_HEALTHCHECK_WORKERS}
    block-on-red = false
    block-on-red = ${?OTOROSHI_HEALTHCHECK_BLOCK_ON_RED}
    block-on-red = ${?OTOROSHI_HEALTHCHECK_BLOCK_ON_500}
    ttl = 60000
    ttl = ${?OTOROSHI_HEALTHCHECK_TTL}
    ttl-only = true
    ttl-only = ${?OTOROSHI_HEALTHCHECK_TTL_ONLY}
  }
  vaults {
    enabled = false
    enabled = ${?OTOROSHI_VAULTS_ENABLED}
    secrets-ttl = 300000 # 5 minutes between each secret read
    secrets-ttl = ${?OTOROSHI_VAULTS_SECRETS_TTL}
    secrets-error-ttl = 20000 # wait 20000 before retrying on error
    secrets-error-ttl = ${?OTOROSHI_VAULTS_SECRETS_ERROR_TTL}
    cached-secrets = 10000
    cached-secrets = ${?OTOROSHI_VAULTS_CACHED_SECRETS}
		read-ttl = 10000 # 10 seconds
    read-timeout = ${?otoroshi.vaults.read-ttl}
		read-timeout = ${?OTOROSHI_VAULTS_READ_TTL}
		read-timeout = ${?OTOROSHI_VAULTS_READ_TIMEOUT}
    parallel-fetchs = 4
    parallel-fetchs = ${?OTOROSHI_VAULTS_PARALLEL_FETCHS}
    # if enabled, only leader nodes fetches the secrets.
    # entities with secret values filled are then sent to workers when they poll the cluster state.
    # only works if `otoroshi.cluster.autoUpdateState=true`
    leader-fetch-only = false
    leader-fetch-only = ${?OTOROSHI_VAULTS_LEADER_FETCH_ONLY}
    env {
      type = &quot;env&quot;
      prefix = ${?OTOROSHI_VAULTS_ENV_PREFIX}
    }
    local {
    	type = &quot;local&quot;
    	root = ${?OTOROSHI_VAULTS_LOCAL_ROOT}
    }
    # hashicorpvault {
    #   type = &quot;hashicorp-vault&quot;
    #   url = &quot;http://127.0.0.1:8200&quot;
    #   mount = &quot;kv&quot;
    #   kv = &quot;v2&quot;
    #   token = &quot;root&quot;
    # }
  }
  tunnels {
    enabled = true
    enabled = ${?OTOROSHI_TUNNELS_ENABLED}
    worker-ws = true
    worker-ws = ${?OTOROSHI_TUNNELS_WORKER_WS}
    worker-use-internal-ports = false
    worker-use-internal-ports = ${?OTOROSHI_TUNNELS_WORKER_USE_INTERNAL_PORTS}
    worker-use-loadbalancing = false
    worker-use-loadbalancing = ${?OTOROSHI_TUNNELS_WORKER_USE_LOADBALANCING}
    default {
      enabled = false
      enabled = ${?OTOROSHI_TUNNELS_DEFAULT_ENABLED}
      id = &quot;default&quot;
      id = ${?OTOROSHI_TUNNELS_DEFAULT_ID}
      name = &quot;default&quot;
      name = ${?OTOROSHI_TUNNELS_DEFAULT_NAME}
			url = &quot;http://127.0.0.1:8080&quot;
			url = ${?OTOROSHI_TUNNELS_DEFAULT_URL}
			host = &quot;otoroshi-api.oto.tools&quot;
			host = ${?OTOROSHI_TUNNELS_DEFAULT_HOST}
			clientId = &quot;admin-api-apikey-id&quot;
			clientId = ${?OTOROSHI_TUNNELS_DEFAULT_CLIENT_ID}
			clientSecret = &quot;admin-api-apikey-secret&quot;
			clientSecret = ${?OTOROSHI_TUNNELS_DEFAULT_CLIENT_SECRET}
			export-routes = true # send routes information to remote otoroshi instance to facilitate remote route exposition
			export-routes = ${?OTOROSHI_TUNNELS_DEFAULT_EXPORT_ROUTES} # send routes information to remote otoroshi instance to facilitate remote route exposition
			export-routes-tag = ${?OTOROSHI_TUNNELS_DEFAULT_EXPORT_TAG} # only send routes information if the route has this tag
      proxy {
        enabled = false
        host = none
        port = none
        principal = none
        password = none
        nonProxyHosts = []
      }
    }
  }
  admin-extensions {
  	enabled = true
  	enabled = ${?OTOROSHI_ADMIN_EXTENSIONS_ENABLED}
  	configurations {
  		otoroshi_extensions_foo {
  			enabled = false
  		}
  	}
  }
}


http.port = 8080                       # the main http port for the otoroshi server
http.port = ${?otoroshi.http.port}     # the main http port for the otoroshi server
http.port = ${?PORT}                   # the main http port for the otoroshi server
http.port = ${?OTOROSHI_PORT}                   # the main http port for the otoroshi server
http.port = ${?OTOROSHI_HTTP_PORT}                   # the main http port for the otoroshi server
play.server.http.port = ${http.port}   # the main http port for the otoroshi server
play.server.http.port = ${?PORT}       # the main http port for the otoroshi server
play.server.http.port = ${?OTOROSHI_PORT}       # the main http port for the otoroshi server
play.server.http.port = ${?OTOROSHI_HTTP_PORT}       # the main http port for the otoroshi server
https.port = 8443                      # the main https port for the otoroshi server
https.port = ${?otoroshi.https.port}   # the main https port for the otoroshi server
https.port = ${?HTTPS_PORT}            # the main https port for the otoroshi server
https.port = ${?OTOROSHI_HTTPS_PORT}            # the main https port for the otoroshi server

play.server.https.engineProvider = &quot;otoroshi.ssl.DynamicSSLEngineProvider&quot;  # the module to handle TLS connections dynamically
play.server.https.keyStoreDumpPath = ${?HTTPS_KEYSTORE_DUMP_PATH}           # the file path where the TLSContext will be dumped (for debugging purposes only)
play.server.https.keyStoreDumpPath = ${?OTOROSHI_HTTPS_KEYSTORE_DUMP_PATH}           # the file path where the TLSContext will be dumped (for debugging purposes only)

play.http.secret.key = ${otoroshi.secret}       # the secret used to signed session cookies                       
play.http.secret.key = ${?PLAY_CRYPTO_SECRET}   # the secret used to signed session cookies
play.http.secret.key = ${?OTOROSHI_CRYPTO_SECRET}   # the secret used to signed session cookies

play.server.http.idleTimeout = 3600s                              # the default server idle timeout
play.server.http.idleTimeout = ${?PLAY_SERVER_IDLE_TIMEOUT}       # the default server idle timeout
play.server.http.idleTimeout = ${?OTOROSHI_SERVER_IDLE_TIMEOUT}       # the default server idle timeout
play.server.akka.requestTimeout = 3600s                           # the default server idle timeout (for akka server specifically)
play.server.akka.requestTimeout = ${?PLAY_SERVER_REQUEST_TIMEOUT} # the default server idle timeout (for akka server specifically)
play.server.akka.requestTimeout = ${?OTOROSHI_SERVER_REQUEST_TIMEOUT} # the default server idle timeout (for akka server specifically)

http2.enabled = true               # enable HTTP2 support
http2.enabled = ${?otoroshi.http2.enabled}
http2.enabled = ${?HTTP2_ENABLED}  # enable HTTP2 support
http2.enabled = ${?OTOROSHI_HTTP2_ENABLED}  # enable HTTP2 support

play.server.https.keyStore.path=${?HTTPS_KEYSTORE_PATH}         # settings for the default server keystore
play.server.https.keyStore.path=${?OTOROSHI_HTTPS_KEYSTORE_PATH}         # settings for the default server keystore
play.server.https.keyStore.type=${?HTTPS_KEYSTORE_TYPE}         # settings for the default server keystore
play.server.https.keyStore.type=${?OTOROSHI_HTTPS_KEYSTORE_TYPE}         # settings for the default server keystore
play.server.https.keyStore.password=${?HTTPS_KEYSTORE_PASSWORD} # settings for the default server keystore
play.server.https.keyStore.password=${?OTOROSHI_HTTPS_KEYSTORE_PASSWORD} # settings for the default server keystore
play.server.https.keyStore.algorithm=${?HTTPS_KEYSTORE_ALGO}    # settings for the default server keystore
play.server.https.keyStore.algorithm=${?OTOROSHI_HTTPS_KEYSTORE_ALGO}    # settings for the default server keystore
 

play.server.websocket.frame.maxLength = 1024k
play.server.websocket.frame.maxLength = ${?OTOROSHI_WEBSOCKET_FRAME_MAX_LENGTH}



play.application.loader = &quot;otoroshi.loader.OtoroshiLoader&quot;  # the loader used to launch otoroshi

play.http {
  session {
    secure = false                    # the cookie for otoroshi backoffice should be exhanged over https only
    secure = ${?SESSION_SECURE_ONLY}  # the cookie for otoroshi backoffice should be exhanged over https only
    secure = ${?OTOROSHI_SESSION_SECURE_ONLY}  # the cookie for otoroshi backoffice should be exhanged over https only
    httpOnly = true                   # the cookie for otoroshi backoffice is not accessible from javascript
    maxAge = 259200000                # the cookie for otoroshi backoffice max age
    maxAge = ${?SESSION_MAX_AGE}      # the cookie for otoroshi backoffice max age
    maxAge = ${?OTOROSHI_SESSION_MAX_AGE}      # the cookie for otoroshi backoffice max age
    # domain = &quot;.&quot;${?app.domain}         # the cookie for otoroshi backoffice domain
    domain = &quot;.&quot;${otoroshi.domain}    # the cookie for otoroshi backoffice domain
    domain = ${?SESSION_DOMAIN}       # the cookie for otoroshi backoffice domain
    domain = ${?OTOROSHI_SESSION_DOMAIN}       # the cookie for otoroshi backoffice domain
    cookieName = &quot;otoroshi-session&quot;   # the cookie for otoroshi backoffice name
    cookieName = ${?SESSION_NAME}     # the cookie for otoroshi backoffice name
    cookieName = ${?OTOROSHI_SESSION_NAME}     # the cookie for otoroshi backoffice name
  }
}






akka { # akka specific configuration
  version = &quot;2.6.20&quot;
  loglevel = ERROR
  logger-startup-timeout = 60s
  log-dead-letters-during-shutdown = false
  jvm-exit-on-fatal-error = false
  actor {
    default-dispatcher {
      type = Dispatcher
      executor = &quot;fork-join-executor&quot;
      fork-join-executor {     
        parallelism-factor = 4.0
        parallelism-factor = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_FACTOR}
        parallelism-min = 8
        parallelism-min = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_MIN}
        parallelism-max = 64
        parallelism-max = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_MAX}
        task-peeking-mode = &quot;FIFO&quot;
        task-peeking-mode = ${?OTOROSHI_AKKA_DISPATCHER_TASK_PEEKING_MODE}
      }
      throughput = 1
      throughput = ${?OTOROSHI_AKKA_DISPATCHER_THROUGHPUT}
    }
  }
  http {
    server {
      server-header = otoroshi
      max-connections = 2048
      max-connections = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CONNECTIONS}
      remote-address-header = on
      raw-request-uri-header = on
      pipelining-limit = 64
      pipelining-limit = ${?OTOROSHI_AKKA_HTTP_SERVER_PIPELINING_LIMIT}
      backlog = 512
      backlog = ${?OTOROSHI_AKKA_HTTP_SERVER_BACKLOG}
      socket-options {
        so-receive-buffer-size = undefined
        so-send-buffer-size = undefined
        so-reuse-address = undefined
        so-traffic-class = undefined
        tcp-keep-alive = true
        tcp-oob-inline = undefined
        tcp-no-delay = undefined
      }
      http2 {
        request-entity-chunk-size = 65536 b
        incoming-connection-level-buffer-size = 10 MB
        incoming-stream-level-buffer-size = 512kB
      }
    }
    client {
      user-agent-header = Otoroshi-akka
      socket-options {
        so-receive-buffer-size = undefined
        so-send-buffer-size = undefined
        so-reuse-address = undefined
        so-traffic-class = undefined
        tcp-keep-alive = true
        tcp-oob-inline = undefined
        tcp-no-delay = undefined
      }
    }
    host-connection-pool {
      max-connections = 512
      max-connections = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_MAX_CONNECTIONS}
      max-open-requests = 2048
      max-open-requests = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_MAX_OPEN_REQUESTS}
      pipelining-limit = 32
      pipelining-limit = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_PIPELINING_LIMIT}
      client {
        user-agent-header = otoroshi
        socket-options {
          so-receive-buffer-size = undefined
          so-send-buffer-size = undefined
          so-reuse-address = undefined
          so-traffic-class = undefined
          tcp-keep-alive = true
          tcp-oob-inline = undefined
          tcp-no-delay = undefined
        }
      }
    }
    parsing {
      max-uri-length             = 4k
      max-uri-length             = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_URI_LENGTH}
      max-method-length          = 16
      max-method-length          = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_METHOD_LENGTH}
      max-response-reason-length = 128
      max-response-reason-length = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_RESPONSE_REASON_LENGTH}
      max-header-name-length     = 128
      max-header-name-length     = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_NAME_LENGTH}
      max-header-value-length    = 16k
      max-header-value-length    = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_VALUE_LENGTH}
      max-header-count           = 128
      max-header-count           = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_COUNT}
      max-chunk-ext-length       = 256
      max-chunk-ext-length       = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CHUNK_EXT_LENGTH}
      max-chunk-size             = 256m
      max-chunk-size             = ${?AKKA_HTTP_SERVER_MAX_CHUNK_SIZE}
      max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CHUNK_SIZE}
      max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CHUNK_SIZE}
      max-content-length         = infinite
      max-content-length         = ${?AKKA_HTTP_SERVER_MAX_CONTENT_LENGHT}
      max-content-length         = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CONTENT_LENGHT}
      max-content-length         = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CONTENT_LENGHT}
    }
  }
}</code></pre>
<h3><a href="#more-config-options" name="more-config-options" class="anchor"><span class="anchor-link"></span></a>More config. options</h3>
<p>See default configuration at</p>
<ul>
  <li><a href="https://github.com/MAIF/otoroshi/blob/master/otoroshi/conf/base.conf" title="Base configuration" target="_blank" rel="noopener noreferrer">Base configuration</a></li>
  <li><a href="https://github.com/MAIF/otoroshi/blob/master/otoroshi/conf/application.conf" title="Application configuration" target="_blank" rel="noopener noreferrer">Application configuration</a></li>
</ul>
<h2><a href="#configuration-with-env-variables" name="configuration-with-env-variables" class="anchor"><span class="anchor-link"></span></a>Configuration with env. variables</h2>
<p>Eevery property in the configuration file can be overriden by an environment variable if it has env variable override written like <code>${?ENV_VARIABLE}</code>).</p>
<h2><a href="#reference-configuration-for-env-variables" name="reference-configuration-for-env-variables" class="anchor"><span class="anchor-link"></span></a>Reference configuration for env. variables</h2>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><code class="language-conf">app {
  storage = ${?APP_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql
  storage = ${?OTOROSHI_STORAGE} # the storage used by otoroshi. possible values are lettuce (for redis), inmemory, file, http, s3, cassandra, postgresql
  storageRoot = ${?APP_STORAGE_ROOT} # the prefix used for storage keys
  storageRoot = ${?OTOROSHI_STORAGE_ROOT} # the prefix used for storage keys
  eventsName = ${?APP_EVENTS_NAME} # the name of the event producer
  eventsName = ${?OTOROSHI_EVENTS_NAME} # the name of the event producer
  importFrom = ${?APP_IMPORT_FROM} # file path to import otoroshi initial configuration
  importFrom = ${?OTOROSHI_IMPORT_FROM} # file path to import otoroshi initial configuration
  env = ${?APP_ENV} # env name, should always be prod except in dev mode
  env = ${?OTOROSHI_ENV} # env name, should always be prod except in dev mode
  domain = ${?APP_DOMAIN} # default domain for basic otoroshi services
  domain = ${?OTOROSHI_DOMAIN} # default domain for basic otoroshi services
  commitId = ${?COMMIT_ID}
  commitId = ${?OTOROSHI_COMMIT_ID}
  rootScheme = ${?APP_ROOT_SCHEME} # default root scheme when composing urls
  rootScheme = ${?OTOROSHI_ROOT_SCHEME} # default root scheme when composing urls
  throttlingWindow = ${?THROTTLING_WINDOW} # the number of second used to compute throttling number
  throttlingWindow = ${?OTOROSHI_THROTTLING_WINDOW} # the number of second used to compute throttling number
  checkForUpdates = ${?CHECK_FOR_UPDATES} # enable automatic version update checks
  checkForUpdates = ${?OTOROSHI_CHECK_FOR_UPDATES} # enable automatic version update checks
  overheadThreshold = ${?OVERHEAD_THRESHOLD} # the value threshold (in milliseconds) used to send HighOverheadAlert
  overheadThreshold = ${?OTOROSHI_OVERHEAD_THRESHOLD} # the value threshold (in milliseconds) used to send HighOverheadAlert
  adminLogin = ${?OTOROSHI_INITIAL_ADMIN_LOGIN} # the initial admin login
  adminPassword = ${?OTOROSHI_INITIAL_ADMIN_PASSWORD} # the initial admin password
  initialCustomization = ${?OTOROSHI_INITIAL_CUSTOMIZATION} # otoroshi inital configuration that will be merged with a new confguration. Shaped like an otoroshi export
  boot {
  	failOnTimeout = ${?OTOROSHI_BOOT_FAIL_ON_TIMEOUT} # otoroshi will exit if a subsystem failed its init
    globalWait = ${?OTOROSHI_BOOT_GLOBAL_WAIT} # should we wait until everything is setup to accept http requests
    globalWaitTimeout = ${?OTOROSHI_BOOT_GLOBAL_WAIT_TIMEOUT} # max wait before accepting requests
    waitForPluginsSearch = ${?OTOROSHI_BOOT_WAIT_FOR_PLUGINS_SEARCH} # should we wait for classpath plugins search before accepting http requests
    waitForPluginsSearchTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_PLUGINS_SEARCH_TIMEOUT} # max wait for classpath plugins search before accepting http requests
    waitForScriptsCompilation = ${?OTOROSHI_BOOT_WAIT_FOR_SCRIPTS_COMPILATION} # should we wait for plugins compilation before accepting http requests
    waitForScriptsCompilationTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_SCRIPTS_COMPILATION_TIMEOUT} # max wait for plugins compilation before accepting http requests 
    waitForTlsInit = ${?OTOROSHI_BOOT_WAIT_FOR_TLS_INIT} # should we wait for first TLS context initialization before accepting http requests
    waitForTlsInitTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_TLS_INIT_TIMEOUT} # max wait for first TLS context initialization before accepting http requests
    waitForFirstClusterFetch = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_FETCH} # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterFetchTimeout = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_TIMEOUT} # max wait for first cluster initialization before accepting http requests
    waitForFirstClusterStateCache = ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_STATE_CACHE} # should we wait for first cluster initialization before accepting http requests
    waitForFirstClusterStateCacheTimeout =  ${?OTOROSHI_BOOT_WAIT_FOR_FIRST_CLUSTER_STATE_CACHE_TIMEOUT} # max wait for first cluster initialization before accepting http requests
  }
  instance {
    instanceId = ${?OTOROSHI_INSTANCE_ID} # the instance id
    number =  ${?OTOROSHI_INSTANCE_NUMBER} # the instance number. Can be found in otoroshi events
    number =  ${?INSTANCE_NUMBER} # the instance number. Can be found in otoroshi events
    name = ${?OTOROSHI_INSTANCE_NAME} # instance name
    zone = ${?OTOROSHI_INSTANCE_ZONE} # instance zone (optional)
    region = ${?OTOROSHI_INSTANCE_REGION} # instance region (optional)
    dc = ${?OTOROSHI_INSTANCE_DATACENTER} # instance dc (optional)
    provider = ${?OTOROSHI_INSTANCE_PROVIDER} # instance provider (optional)
    rack = ${?OTOROSHI_INSTANCE_RACK} # instance rack (optional)
    title = ${?OTOROSHI_INSTANCE_TITLE} # the title displayed in UI top left
  }
    longRequestTimeout = ${?OTOROSHI_PROXY_LONG_REQUEST_TIMEOUT}
  }
  health {
    limit = ${?HEALTH_LIMIT} # the value threshold (in milliseconds) used to indicate if an otoroshi instance is healthy or not
    limit = ${?OTOROSHI_HEALTH_LIMIT} # the value threshold (in milliseconds) used to indicate if an otoroshi instance is healthy or not
    accessKey = ${?HEALTH_ACCESS_KEY} # the key to access /health edpoint
    accessKey = ${?OTOROSHI_HEALTH_ACCESS_KEY} # the key to access /health edpoint
  }
  snowflake {
    seed = ${?INSTANCE_NUMBER} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?OTOROSHI_INSTANCE_NUMBER} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?SNOWFLAKE_SEED} # the seed number used to generate unique ids. Should be different for every instances
    seed = ${?OTOROSHI_SNOWFLAKE_SEED} # the seed number used to generate unique ids. Should be different for every instances
  }
  events {
    maxSize = ${?MAX_EVENTS_SIZE} # the amount of event kept in the datastore
    maxSize = ${?OTOROSHI_MAX_EVENTS_SIZE} # the amount of event kept in the datastore
  }
  exposed-ports {
    http = ${?APP_EXPOSED_PORTS_HTTP} # the exposed http port for otoroshi (when in a container or behind a proxy)
    http = ${?OTOROSHI_EXPOSED_PORTS_HTTP} # the exposed http port for otoroshi (when in a container or behind a proxy)
    https = ${?APP_EXPOSED_PORTS_HTTPS} # the exposed https port for otoroshi (when in a container or behind a proxy
    https = ${?OTOROSHI_EXPOSED_PORTS_HTTPS} # the exposed https port for otoroshi (when in a container or behind a proxy
  }
  backoffice {
    exposed = ${?APP_BACKOFFICE_EXPOSED} # expose the backoffice ui
    exposed = ${?OTOROSHI_BACKOFFICE_EXPOSED} # expose the backoffice ui
    subdomain = ${?APP_BACKOFFICE_SUBDOMAIN} # the backoffice subdomain
    subdomain = ${?OTOROSHI_BACKOFFICE_SUBDOMAIN} # the backoffice subdomain
    domainsStr = ${?APP_BACKOFFICE_DOMAINS} # the backoffice domains
    domainsStr = ${?OTOROSHI_BACKOFFICE_DOMAINS} # the backoffice domains
    useNewEngine = ${?OTOROSHI_BACKOFFICE_USE_NEW_ENGINE} # avoid backoffice admin api proxy
    usePlay = ${?OTOROSHI_BACKOFFICE_USE_PLAY} # avoid backoffice http call for admin api
    session {
      exp = ${?APP_BACKOFFICE_SESSION_EXP} # the backoffice cookie expiration
      exp = ${?OTOROSHI_BACKOFFICE_SESSION_EXP} # the backoffice cookie expiration
    }
  }
  privateapps {
    subdomain = ${?APP_PRIVATEAPPS_SUBDOMAIN} # privateapps (proxy sso) domain
    subdomain = ${?OTOROSHI_PRIVATEAPPS_SUBDOMAIN} # privateapps (proxy sso) domain
    domainsStr = ${?APP_PRIVATEAPPS_DOMAINS}
    domainsStr = ${?OTOROSHI_PRIVATEAPPS_DOMAINS}
    session {
      exp = ${?APP_PRIVATEAPPS_SESSION_EXP} # the privateapps cookie expiration
      exp = ${?OTOROSHI_PRIVATEAPPS_SESSION_EXP} # the privateapps cookie expiration
    }
  }
  adminapi {
    exposed = ${?ADMIN_API_EXPOSED} # expose the admin api
    exposed = ${?OTOROSHI_ADMIN_API_EXPOSED} # expose the admin api
    targetSubdomain = ${?ADMIN_API_TARGET_SUBDOMAIN} # admin api target subdomain as targeted by otoroshi service
    targetSubdomain = ${?OTOROSHI_ADMIN_API_TARGET_SUBDOMAIN} # admin api target subdomain as targeted by otoroshi service
    exposedSubdomain = ${?ADMIN_API_EXPOSED_SUBDOMAIN} # admin api exposed subdomain as exposed by otoroshi service
    exposedSubdomain = ${?OTOROSHI_ADMIN_API_EXPOSED_SUBDOMAIN} # admin api exposed subdomain as exposed by otoroshi service
    additionalExposedDomain = ${?ADMIN_API_ADDITIONAL_EXPOSED_DOMAIN} # admin api additional exposed subdomain as exposed by otoroshi service
    additionalExposedDomain = ${?OTOROSHI_ADMIN_API_ADDITIONAL_EXPOSED_DOMAIN} # admin api additional exposed subdomain as exposed by otoroshi service
    domainsStr = ${?ADMIN_API_DOMAINS}
    domainsStr = ${?OTOROSHI_ADMIN_API_DOMAINS}
    exposedDomainsStr = ${?ADMIN_API_EXPOSED_DOMAINS}
    exposedDomainsStr = ${?OTOROSHI_ADMIN_API_EXPOSED_DOMAINS}
    defaultValues {
      backOfficeGroupId = ${?ADMIN_API_GROUP} # default value for admin api service group
      backOfficeGroupId = ${?OTOROSHI_ADMIN_API_GROUP} # default value for admin api service group
      backOfficeApiKeyClientId = ${?ADMIN_API_CLIENT_ID}  # default value for admin api apikey id
      backOfficeApiKeyClientId = ${?OTOROSHI_ADMIN_API_CLIENT_ID}  # default value for admin api apikey id
      backOfficeApiKeyClientSecret = ${?otoroshi.admin-api-secret} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?OTOROSHI_otoroshi.admin-api-secret} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?ADMIN_API_CLIENT_SECRET} # default value for admin api apikey secret
      backOfficeApiKeyClientSecret = ${?OTOROSHI_ADMIN_API_CLIENT_SECRET} # default value for admin api apikey secret
      backOfficeServiceId = ${?ADMIN_API_SERVICE_ID} # default value for admin api service id
      backOfficeServiceId = ${?OTOROSHI_ADMIN_API_SERVICE_ID} # default value for admin api service id
    }
    proxy {
      https = ${?ADMIN_API_HTTPS} # backoffice proxy admin api over https
      https = ${?OTOROSHI_ADMIN_API_HTTPS} # backoffice proxy admin api over https
      local = ${?ADMIN_API_LOCAL} # backoffice proxy admin api on localhost
      local = ${?OTOROSHI_ADMIN_API_LOCAL} # backoffice proxy admin api on localhost
    }
  }
  claim {
    sharedKey = ${?CLAIM_SHAREDKEY} # the default secret used to sign otoroshi exchange protocol tokens
    sharedKey = ${?OTOROSHI_CLAIM_SHAREDKEY} # the default secret used to sign otoroshi exchange protocol tokens
  }
  webhooks {
  }
  redis { # configuration to fetch/store otoroshi state from a redis datastore using rediscala
    host = ${?REDIS_HOST}
    host = ${?OTOROSHI_REDIS_HOST}
    port = ${?REDIS_PORT}
    port = ${?OTOROSHI_REDIS_PORT}
    password = ${?REDIS_PASSWORD}
    password = ${?OTOROSHI_REDIS_PASSWORD}
    windowSize = ${?REDIS_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_REDIS_WINDOW_SIZE}
    slavesStr = ${?REDIS_SLAVES}
    slavesStr = ${?OTOROSHI_REDIS_SLAVES}
    slavesStr = ${?REDIS_MEMBERS}
    slavesStr = ${?OTOROSHI_REDIS_MEMBERS}
    useScan =  ${?REDIS_USE_SCAN}
    useScan =  ${?OTOROSHI_REDIS_USE_SCAN}
    pool {
      members = ${?REDIS_POOL_MEMBERS}
      members = ${?OTOROSHI_REDIS_POOL_MEMBERS}
    }
    mpool {
      membersStr = ${?REDIS_MPOOL_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_MPOOL_MEMBERS}
    }
    lf {
      master {
        host = ${?REDIS_LF_HOST}
        host = ${?OTOROSHI_REDIS_LF_HOST}
        port = ${?REDIS_LF_PORT}
        port = ${?OTOROSHI_REDIS_LF_PORT}
        password = ${?REDIS_LF_PASSWORD}
        password = ${?OTOROSHI_REDIS_LF_PASSWORD}
      }
      slavesStr = ${?REDIS_LF_SLAVES}
      slavesStr = ${?OTOROSHI_REDIS_LF_SLAVES}
      slavesStr = ${?REDIS_LF_MEMBERS}
      slavesStr = ${?OTOROSHI_REDIS_LF_MEMBERS}
    }
    sentinels {
      master = ${?REDIS_SENTINELS_MASTER}
      master = ${?OTOROSHI_REDIS_SENTINELS_MASTER}
      password = ${?REDIS_SENTINELS_PASSWORD}
      password = ${?OTOROSHI_REDIS_SENTINELS_PASSWORD}
      db = ${?REDIS_SENTINELS_DB}
      db = ${?OTOROSHI_REDIS_SENTINELS_DB}
      name = ${?REDIS_SENTINELS_NAME}
      name = ${?OTOROSHI_REDIS_SENTINELS_NAME}
      membersStr = ${?REDIS_SENTINELS_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_SENTINELS_MEMBERS}
      lf {
        master = ${?REDIS_SENTINELS_LF_MASTER}
        master = ${?OTOROSHI_REDIS_SENTINELS_LF_MASTER}
        membersStr = ${?REDIS_SENTINELS_LF_MEMBERS}
        membersStr = ${?OTOROSHI_REDIS_SENTINELS_LF_MEMBERS}
      }
    }
    cluster {
      membersStr = ${?REDIS_CLUSTER_MEMBERS}
      membersStr = ${?OTOROSHI_REDIS_CLUSTER_MEMBERS}
    }
    lettuce { # configuration to fetch/store otoroshi state from a redis datastore using the lettuce driver (the next default one)
      connection = ${?REDIS_LETTUCE_CONNECTION}
      connection = ${?OTOROSHI_REDIS_LETTUCE_CONNECTION}
      uri =  ${?REDIS_LETTUCE_URI}
      uri =  ${?OTOROSHI_REDIS_LETTUCE_URI}
      uri =  ${?REDIS_URL}
      uri =  ${?OTOROSHI_REDIS_URL}
      urisStr = ${?REDIS_LETTUCE_URIS}
      urisStr = ${?OTOROSHI_REDIS_LETTUCE_URIS}
      readFrom = ${?REDIS_LETTUCE_READ_FROM}
      readFrom = ${?OTOROSHI_REDIS_LETTUCE_READ_FROM}
      startTLS = ${?REDIS_LETTUCE_START_TLS}
      startTLS = ${?OTOROSHI_REDIS_LETTUCE_START_TLS}
      verifyPeers = ${?REDIS_LETTUCE_VERIFY_PEERS}
      verifyPeers = ${?OTOROSHI_REDIS_LETTUCE_VERIFY_PEERS}
    }
  }
  inmemory { # configuration to fetch/store otoroshi state in memory
    windowSize = ${?INMEMORY_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_INMEMORY_WINDOW_SIZE}
    experimental = ${?INMEMORY_EXPERIMENTAL_STORE}
    experimental = ${?OTOROSHI_INMEMORY_EXPERIMENTAL_STORE}
    optimized = ${?INMEMORY_OPTIMIZED}
    optimized = ${?OTOROSHI_INMEMORY_OPTIMIZED}
    modern =  ${?INMEMORY_MODERN}
    modern =  ${?OTOROSHI_INMEMORY_MODERN}
  }
  filedb { # configuration to fetch/store otoroshi state from a file
    windowSize = ${?FILEDB_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_FILEDB_WINDOW_SIZE}
    path = ${?FILEDB_PATH}
    path = ${?OTOROSHI_FILEDB_PATH}
  }
  httpdb { # configuration to fetch/store otoroshi state from an http endpoint
    headers = {}
  }
  s3db { # configuration to fetch/store otoroshi state from a S3 bucket
    bucket = ${?OTOROSHI_DB_S3_BUCKET}
    endpoint = ${?OTOROSHI_DB_S3_ENDPOINT}
    region = ${?OTOROSHI_DB_S3_REGION}
    access = ${?OTOROSHI_DB_S3_ACCESS}
    secret = ${?OTOROSHI_DB_S3_SECRET}
    key = ${?OTOROSHI_DB_S3_KEY}
    chunkSize = ${?OTOROSHI_DB_S3_CHUNK_SIZE}
    v4auth = ${?OTOROSHI_DB_S3_V4_AUTH}
    writeEvery = ${?OTOROSHI_DB_S3_WRITE_EVERY} # write interval
    acl = ${?OTOROSHI_DB_S3_ACL}
  }
  pg { # postrgesql settings. everything possible with the client
    uri = ${?PG_URI}
    uri = ${?OTOROSHI_PG_URI}
    uri = ${?POSTGRESQL_ADDON_URI}
    uri = ${?OTOROSHI_POSTGRESQL_ADDON_URI}
    poolSize = ${?PG_POOL_SIZE}
    poolSize = ${?OTOROSHI_PG_POOL_SIZE}
    port = ${?PG_PORT}
    port = ${?OTOROSHI_PG_PORT}
    host = ${?PG_HOST}
    host = ${?OTOROSHI_PG_HOST}
    database = ${?PG_DATABASE}
    database = ${?OTOROSHI_PG_DATABASE}
    user = ${?PG_USER}
    user = ${?OTOROSHI_PG_USER}
    password = ${?PG_PASSWORD}
    password = ${?OTOROSHI_PG_PASSWORD}
    logQueries = ${?PG_DEBUG_QUERIES}
    logQueries = ${?OTOROSHI_PG_DEBUG_QUERIES}
    avoidJsonPath = ${?PG_AVOID_JSON_PATH}
    avoidJsonPath = ${?OTOROSHI_PG_AVOID_JSON_PATH}
    optimized = ${?PG_OPTIMIZED}
    optimized = ${?OTOROSHI_PG_OPTIMIZED}
    connect-timeout = ${?PG_CONNECT_TIMEOUT}
    connect-timeout = ${?OTOROSHI_PG_CONNECT_TIMEOUT}
    idle-timeout = ${?PG_IDLE_TIMEOUT}
    idle-timeout = ${?OTOROSHI_PG_IDLE_TIMEOUT}
    log-activity = ${?PG_LOG_ACTIVITY}
    log-activity = ${?OTOROSHI_PG_LOG_ACTIVITY}
    pipelining-limit = ${?PG_PIPELINING_LIMIT}
    pipelining-limit = ${?OTOROSHI_PG_PIPELINING_LIMIT}
    ssl {
      enabled = ${?PG_SSL_ENABLED}
      enabled = ${?OTOROSHI_PG_SSL_ENABLED}
      mode = ${?PG_SSL_MODE}
      mode = ${?OTOROSHI_PG_SSL_MODE}
      trusted-cert-path = ${?PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert-path = ${?OTOROSHI_PG_SSL_TRUSTED_CERT_PATH}
      trusted-cert = ${?PG_SSL_TRUSTED_CERT}
      trusted-cert = ${?OTOROSHI_PG_SSL_TRUSTED_CERT}
      client-cert-path = ${?PG_SSL_CLIENT_CERT_PATH}
      client-cert-path = ${?OTOROSHI_PG_SSL_CLIENT_CERT_PATH}
      client-cert = ${?PG_SSL_CLIENT_CERT}
      client-cert = ${?OTOROSHI_PG_SSL_CLIENT_CERT}
      trust-all = ${?PG_SSL_TRUST_ALL}
      trust-all = ${?OTOROSHI_PG_SSL_TRUST_ALL}
    }
  }
  cassandra { # cassandra settings. everything possible with the client
    windowSize = ${?CASSANDRA_WINDOW_SIZE}
    windowSize = ${?OTOROSHI_CASSANDRA_WINDOW_SIZE}
    host = ${?CASSANDRA_HOST}
    host = ${?OTOROSHI_CASSANDRA_HOST}
    port = ${?CASSANDRA_PORT}
    port = ${?OTOROSHI_CASSANDRA_PORT}
    replicationFactor = ${?CASSANDRA_REPLICATION_FACTOR}
    replicationFactor = ${?OTOROSHI_CASSANDRA_REPLICATION_FACTOR}
    replicationOptions = ${?CASSANDRA_REPLICATION_OPTIONS}
    replicationOptions = ${?OTOROSHI_CASSANDRA_REPLICATION_OPTIONS}
    durableWrites = ${?CASSANDRA_DURABLE_WRITES}
    durableWrites = ${?OTOROSHI_CASSANDRA_DURABLE_WRITES}
    basic.contact-points = [ ${app.cassandra.host}&quot;:&quot;${app.cassandra.port} ]
    basic.session-name = ${?OTOROSHI_CASSANDRA_SESSION_NAME}
    basic.session-keyspace = ${?OTOROSHI_CASSANDRA_SESSION_KEYSPACE}
    basic.request {
      consistency = ${?OTOROSHI_CASSANDRA_CONSISTENCY}
      page-size = ${?OTOROSHI_CASSANDRA_PAGE_SIZE}
      serial-consistency = ${?OTOROSHI_CASSANDRA_SERIAL_CONSISTENCY}
      default-idempotence = ${?OTOROSHI_CASSANDRA_DEFAULT_IDEMPOTENCE}
    }
    basic.load-balancing-policy {
      local-datacenter = ${?OTOROSHI_CASSANDRA_LOCAL_DATACENTER}
    }
    basic.cloud {
    }
    basic.application {
    }
    basic.graph {
    }
    advanced.connection {
      set-keyspace-timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      pool {
        local {
        }
        remote {
        }
      }
    }
    advanced.reconnection-policy {
    }
    advanced.retry-policy {
    }
    advanced.speculative-execution-policy {
    }
    advanced.auth-provider {
      username = ${?CASSANDRA_USERNAME}
      username = ${?OTOROSHI_CASSANDRA_USERNAME}
      password = ${?CASSANDRA_PASSWORD}
      password = ${?OTOROSHI_CASSANDRA_PASSWORD}
      authorization-id = ${?OTOROSHI_CASSANDRA_AUTHORIZATION_ID}
      # login-configuration {
      # }
      # sasl-properties {
      # }
    }
    advanced.ssl-engine-factory {
    }
    advanced.timestamp-generator {
      drift-warning {
      }
    }
    advanced.request-tracker {
      logs {
        slow {
        }
      }
    }
    advanced.throttler {
    }
    advanced.address-translator {
    }
    advanced.protocol {
      version = ${?OTOROSHI_CASSANDRA_PROTOCOL_VERSION}
      compression = ${?OTOROSHI_CASSANDRA_PROTOCOL_COMPRESSION}
    }
    advanced.request {
      trace {
      }
    }
    advanced.graph {
      paging-options {
        page-size = ${datastax-java-driver.advanced.continuous-paging.page-size}
        max-pages = ${datastax-java-driver.advanced.continuous-paging.max-pages}
        max-pages-per-second = ${datastax-java-driver.advanced.continuous-paging.max-pages-per-second}
        max-enqueued-pages = ${datastax-java-driver.advanced.continuous-paging.max-enqueued-pages}
      }
    }
    advanced.continuous-paging {
      page-size = ${datastax-java-driver.basic.request.page-size}
      timeout {
      }
    }
    advanced.monitor-reporting {
    }
    advanced.metrics {
      session {
        cql-requests {
        }
        throttling.delay {
        }
        continuous-cql-requests {
        }
        graph-requests {
        }
      }
      node {
        cql-messages {
        }
        graph-messages {
        }
      }
    }
    advanced.socket {
    }
    advanced.heartbeat {
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
    }
    advanced.metadata {
      topology-event-debouncer {
      }
      schema {
        request-timeout = ${datastax-java-driver.basic.request.timeout}
        request-page-size = ${datastax-java-driver.basic.request.page-size}
        debouncer {
        }
      }
    }
    advanced.control-connection {
      timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      schema-agreement {
      }
    }
    advanced.prepared-statements {
      reprepare-on-up {
        timeout = ${datastax-java-driver.advanced.connection.init-query-timeout}
      }
    }
    advanced.netty {
      io-group {
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      admin-group {
        shutdown {quiet-period = 2, timeout = 15, unit = SECONDS}
      }
      timer {
      }
    }
    advanced.coalescer {
    }
  }
  actorsystems {
    otoroshi {
      akka { # otoroshi actorsystem configuration
        version = ${akka.version}
        default-dispatcher {
          fork-join-executor {
            parallelism-factor = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_FACTOR}
            parallelism-min = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_MIN}
            parallelism-max = ${?OTOROSHI_CORE_DISPATCHER_PARALLELISM_MAX}
            task-peeking-mode = ${?OTOROSHI_CORE_DISPATCHER_TASK_PEEKING_MODE}
          }
          throughput = ${?OTOROSHI_CORE_DISPATCHER_THROUGHPUT}
        }
        http {
          parsing {
            max-uri-length             = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_URI_LENGTH}
            max-method-length          = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_METHOD_LENGTH}
            max-response-reason-length = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_RESPONSE_REASON_LENGTH}
            max-header-name-length     = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_NAME_LENGTH}
            max-header-value-length    = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_VALUE_LENGTH}
            max-header-count           = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_HEADER_COUNT}
            max-chunk-ext-length       = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CHUNK_EXT_LENGTH}
            max-chunk-size             = ${?AKKA_HTTP_CLIENT_MAX_CHUNK_SIZE}
            max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_CHUNK_SIZE}
            max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CHUNK_SIZE}
            max-content-length         = ${?AKKA_HTTP_CLIENT_MAX_CONTENT_LENGHT}
            max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_CONTENT_LENGHT}
            max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_CONTENT_LENGHT}
            max-to-strict-bytes        = ${?AKKA_HTTP_CLIENT_MAX_TO_STRICT_BYTES}
            max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_MAX_TO_STRICT_BYTES}
            max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_PARSING_MAX_TO_STRICT_BYTES}
          }
        }
      }
    }
    datastore {
      akka {
        version = ${akka.version}
        default-dispatcher {
          fork-join-executor {
          }
        }
      }
    }
  }
}
otoroshi {
  domain = ${?app.domain}
  maintenanceMode = ${?OTOROSHI_MAINTENANCE_MODE_ENABLED} # enable global maintenance mode
  secret = ${?OTOROSHI_SECRET}  # the secret used to sign sessions
  admin-api-secret = ${?OTOROSHI_ADMIN_API_SECRET}  # the secret for admin api
  next {
    state-sync-interval = ${?OTOROSHI_NEXT_STATE_SYNC_INTERVAL}
    export-reporting = ${?OTOROSHI_NEXT_EXPORT_REPORTING}
    monitor-proxy-state-size = ${?OTOROSHI_NEXT_MONITOR_PROXY_STATE_SIZE}
    monitor-datastore-size = ${?OTOROSHI_NEXT_MONITOR_DATASTORE_SIZE}
    plugins {
      merge-sync-steps = ${?OTOROSHI_NEXT_PLUGINS_MERGE_SYNC_STEPS}
      apply-legacy-checks = ${?OTOROSHI_NEXT_PLUGINS_APPLY_LEGACY_CHECKS}
    }
    experimental {
    	netty-client {
    		wiretap = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_WIRETAP}
    		enforce = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_ENFORCE}
				enforce-akka = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_CLIENT_ENFORCE_AKKA}
    	}
   		netty-server {
   			enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_ENABLED}
   			new-engine-only = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NEW_ENGINE_ONLY}
   			host = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HOST}
   			http-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_PORT}
   			exposed-http-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_EXPOSED_HTTP_PORT}
   			https-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTPS_PORT}
				exposed-https-port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_EXPOSED_HTTPS_PORT}
   			wiretap = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_WIRETAP}
   			accesslog = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_ACCESSLOG}
        threads = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_THREADS}
   			parser {
   				allowDuplicateContentLengths = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_ALLOW_DUPLICATE_CONTENT_LENGTHS}
          validateHeaders = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_VALIDATE_HEADERS}
          h2cMaxContentLength = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_H_2_C_MAX_CONTENT_LENGTH}
          initialBufferSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_INITIAL_BUFFER_SIZE}
          maxHeaderSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_HEADER_SIZE}
          maxInitialLineLength = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_INITIAL_LINE_LENGTH}
          maxChunkSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_PARSER_MAX_CHUNK_SIZE}
   			}
   			http2 {
					enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP2_ENABLED}
					h2c = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP2_H2C}
				}
   			http3 {
   				enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_ENABLED}
   				port = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_PORT}
   				exposedPort = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP3_EXPOSED_PORT}
          initialMaxStreamsBidirectional = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAMS_BIDIRECTIONAL}
          initialMaxStreamDataBidirectionalRemote = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAM_DATA_BIDIRECTIONAL_REMOTE}
          initialMaxStreamDataBidirectionalLocal = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_STREAM_DATA_BIDIRECTIONAL_LOCAL}
          initialMaxData = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_INITIAL_MAX_DATA}
          maxRecvUdpPayloadSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_MAX_RECV_UDP_PAYLOAD_SIZE}
          maxSendUdpPayloadSize = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_MAX_SEND_UDP_PAYLOAD_SIZE}
          disableQpackDynamicTable = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_HTTP_3_DISABLE_QPACK_DYNAMIC_TABLE}
   			}
   			native {
   				enabled = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NATIVE_ENABLED}
   				driver = ${?OTOROSHI_NEXT_EXPERIMENTAL_NETTY_SERVER_NATIVE_DRIVER}
   			}
   		}
    }
  }
  options {
    bypassUserRightsCheck = ${?OTOROSHI_OPTIONS_BYPASSUSERRIGHTSCHECK}
    emptyContentLengthIsChunked = ${?OTOROSHI_OPTIONS_EMPTYCONTENTLENGTHISCHUNKED}
    detectApiKeySooner = ${?OTOROSHI_OPTIONS_DETECTAPIKEYSOONER}
    sendClientChainAsPem = ${?OTOROSHI_OPTIONS_SENDCLIENTCHAINASPEM}
    useOldHeadersComposition = ${?OTOROSHI_OPTIONS_USEOLDHEADERSCOMPOSITION}
    manualDnsResolve = ${?OTOROSHI_OPTIONS_MANUALDNSRESOLVE}
    useEventStreamForScriptEvents = ${?OTOROSHI_OPTIONS_USEEVENTSTREAMFORSCRIPTEVENTS}
    trustXForwarded = ${?OTOROSHI_OPTIONS_TRUST_XFORWARDED}
    disableFunnyLogos = ${?OTOROSHI_OPTIONS_DISABLE_FUNNY_LOGOS}
    staticExposedDomain = ${?OTOROSHI_OPTIONS_STATIC_EXPOSED_DOMAIN}
  }
  wasm {
  	cache {
  		ttl = ${?OTOROSHI_WASM_CACHE_TTL}
  		size = ${?OTOROSHI_WASM_CACHE_SIZE}
  	}
  	queue {
  		buffer {
  			size = ${?OTOROSHI_WASM_QUEUE_BUFFER_SIZE}
  		}
  	}
  }
  anonymous-reporting {
		enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_ENABLED}
		url = ${?OTOROSHI_ANONYMOUS_REPORTING_REDIRECT}
  	url = ${?OTOROSHI_ANONYMOUS_REPORTING_URL}
  	timeout = ${?OTOROSHI_ANONYMOUS_REPORTING_TIMEOUT}
  	tls {
			enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_ENABLED}  # enable mtls
			loose = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_LOOSE}  # loose verification
			trustAll = ${?OTOROSHI_ANONYMOUS_REPORTING_TLS_ALL} # trust any CA
		}
		proxy {
			enabled = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_ENABLED}  # enable proxy
			host = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_HOST},
			port = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PORT},
			principal = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PRINCIPAL},
			password = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_PASSWORD},
			ntlmDomain = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_DOMAIN},
			encoding = ${?OTOROSHI_ANONYMOUS_REPORTING_PROXY_ENCODING},
		}
  }
  backoffice {
    flags {
      useAkkaHttpClient = ${?OTOROSHI_BACKOFFICE_FLAGS_USE_AKKA_HTTP_CLIENT}
      logUrl = ${?OTOROSHI_BACKOFFICE_FLAGS_LOG_URL}
      requestTimeout = ${?OTOROSHI_BACKOFFICE_FLAGS_REQUEST_TIMEOUT}
    }
  }
  sessions {
    secret = ${otoroshi.secret}
    secret = ${?OTOROSHI_SESSIONS_SECRET}
  }
  cache {
    enabled = ${?USE_CACHE}
    enabled = ${?OTOROSHI_USE_CACHE}
    enabled = ${?OTOROSHI_ENTITIES_CACHE_ENABLED}
    ttl = ${?OTOROSHI_ENTITIES_CACHE_TTL}
  }
  metrics {
    enabled = ${?OTOROSHI_METRICS_ENABLED}
    every = ${?OTOROSHI_METRICS_EVERY}
    accessKey = ${?app.health.accessKey}
    accessKey = ${?OTOROSHI_app.health.accessKey}
    accessKey = ${?OTOROSHI_METRICS_ACCESS_KEY}
  }
  plugins {
    packagesStr = ${?OTOROSHI_PLUGINS_SCAN_PACKAGES}
    print = ${?OTOROSHI_PLUGINS_PRINT}
  }
  scripts {
    enabled = ${?OTOROSHI_SCRIPTS_ENABLED} # enable scripts
    static { # settings for statically enabled script/plugins
      enabled = ${?OTOROSHI_SCRIPTS_STATIC_ENABLED}
      transformersRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_TRANSFORMER_REFS}
      transformersConfig = {}
      transformersConfigStr= ${?OTOROSHI_SCRIPTS_STATIC_TRANSFORMER_CONFIG}
      validatorRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_VALIDATOR_REFS}
      validatorConfig = {}
      validatorConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_VALIDATOR_CONFIG}
      preRouteRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_PRE_ROUTE_REFS}
      preRouteConfig = {}
      preRouteConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_PRE_ROUTE_CONFIG}
      sinkRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_SINK_REFS}
      sinkConfig = {}
      sinkConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_SINK_CONFIG}
      jobsRefsStr = ${?OTOROSHI_SCRIPTS_STATIC_JOBS_REFS}
      jobsConfig = {}
      jobsConfigStr = ${?OTOROSHI_SCRIPTS_STATIC_JOBS_CONFIG}
    }
  }
  tls = ${otoroshi.ssl}
  ssl {
    cipherSuites = ${otoroshi.ssl.cipherSuitesJDK11}
    protocols = ${otoroshi.ssl.modernProtocols}
    cacert {
    }
    fromOutside {
      clientAuth = ${?SSL_OUTSIDE_CLIENT_AUTH}
      clientAuth = ${?OTOROSHI_SSL_OUTSIDE_CLIENT_AUTH}
    }
    trust {
      all = ${?OTOROSHI_SSL_TRUST_ALL}
    }
    rootCa {
    	ca = ${?OTOROSHI_SSL_ROOTCA_CA}
    	cert = ${?OTOROSHI_SSL_ROOTCA_CERT}
    	key = ${?OTOROSHI_SSL_ROOTCA_KEY}
			importCa = ${?OTOROSHI_SSL_ROOTCA_IMPORTCA}
    }
    initialCacert = ${?CLUSTER_WORKER_INITIAL_CACERT}
    initialCacert = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CACERT}
    initialCacert = ${?INITIAL_CACERT}
    initialCacert = ${?OTOROSHI_INITIAL_CACERT}
    initialCert = ${?CLUSTER_WORKER_INITIAL_CERT}
    initialCert = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CERT}
    initialCert = ${?INITIAL_CERT}
    initialCert = ${?OTOROSHI_INITIAL_CERT}
    initialCertKey = ${?CLUSTER_WORKER_INITIAL_CERT_KEY}
    initialCertKey = ${?OTOROSHI_CLUSTER_WORKER_INITIAL_CERT_KEY}
    initialCertKey = ${?INITIAL_CERT_KEY}
    initialCertKey = ${?OTOROSHI_INITIAL_CERT_KEY}
    initialCertImportCa = ${?OTOROSHI_INITIAL_CERT_IMPORTCA}
  }
  cluster {
    mode = ${?CLUSTER_MODE} # can be &quot;off&quot;, &quot;leader&quot;, &quot;worker&quot;
    mode = ${?OTOROSHI_CLUSTER_MODE} # can be &quot;off&quot;, &quot;leader&quot;, &quot;worker&quot;
    compression = ${?CLUSTER_COMPRESSION} # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9
    compression = ${?OTOROSHI_CLUSTER_COMPRESSION} # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9
    retryDelay = ${?CLUSTER_RETRY_DELAY} # the delay before retrying a request to leader
    retryDelay = ${?OTOROSHI_CLUSTER_RETRY_DELAY} # the delay before retrying a request to leader
    retryFactor = ${?CLUSTER_RETRY_FACTOR} # the retry factor to avoid high load on failing nodes
    retryFactor = ${?OTOROSHI_CLUSTER_RETRY_FACTOR} # the retry factor to avoid high load on failing nodes
    selfAddress = ${?CLUSTER_SELF_ADDRESS} # the instance ip address
    selfAddress = ${?OTOROSHI_CLUSTER_SELF_ADDRESS} # the instance ip address
    autoUpdateState = ${?CLUSTER_AUTO_UPDATE_STATE} # auto update cluster state with a job (more efficient
    autoUpdateState = ${?OTOROSHI_CLUSTER_AUTO_UPDATE_STATE} # auto update cluster state with a job (more efficient
    backup {
      enabled = ${?OTOROSHI_CLUSTER_BACKUP_ENABLED}
			kind = ${?OTOROSHI_CLUSTER_BACKUP_KIND}
			instance {
				can-write = ${?OTOROSHI_CLUSTER_BACKUP_INSTANCE_CAN_WRITE}
				can-read = ${?OTOROSHI_CLUSTER_BACKUP_INSTANCE_CAN_READ}
			}
			s3 {
				bucket = ${?OTOROSHI_CLUSTER_BACKUP_S3_BUCKET}
        endpoint = ${?OTOROSHI_CLUSTER_BACKUP_S3_ENDPOINT}
        region = ${?OTOROSHI_CLUSTER_BACKUP_S3_REGION}
        access = ${?OTOROSHI_CLUSTER_BACKUP_S3_ACCESSKEY}
        secret = ${?OTOROSHI_CLUSTER_BACKUP_S3_SECRET}
        path = ${?OTOROSHI_CLUSTER_BACKUP_S3_PATH}
        chunk-size = ${?OTOROSHI_CLUSTER_BACKUP_S3_CHUNK_SIZE}
        v4auth = ${?OTOROSHI_CLUSTER_BACKUP_S3_V4AUTH}
        acl = ${?OTOROSHI_CLUSTER_BACKUP_S3_ACL}
			}
    }
    relay { # relay routing settings
      enabled = ${?OTOROSHI_CLUSTER_RELAY_ENABLED} # enable relay routing
      leaderOnly = ${?OTOROSHI_CLUSTER_RELAY_LEADER_ONLY} # workers always pass through leader for relay routing
      location {
        provider = ${?otoroshi.instance.provider}
        provider = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_PROVIDER}
        zone = ${?otoroshi.instance.zone}
        zone = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_ZONE}
        region = ${?otoroshi.instance.region}
        region = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_REGION}
        datacenter = ${?otoroshi.instance.dc}
        datacenter = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_DATACENTER}
        rack = ${?otoroshi.instance.rack}
        rack = ${?OTOROSHI_CLUSTER_RELAY_LOCATION_RACK}
      }
      exposition {
        url = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_URL}
        urlsStr = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_URLS}
        hostname = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_HOSTNAME}
        clientId = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_CLIENT_ID}
        clientSecret = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_CLIENT_SECRET}
        ipAddress = ${?OTOROSHI_CLUSTER_RELAY_EXPOSITION_IP_ADDRESS}
      }
    }
    mtls {
      enabled = ${?CLUSTER_MTLS_ENABLED}  # enable mtls
      enabled = ${?OTOROSHI_CLUSTER_MTLS_ENABLED}  # enable mtls
      loose = ${?CLUSTER_MTLS_LOOSE}  # loose verification
      loose = ${?OTOROSHI_CLUSTER_MTLS_LOOSE}  # loose verification
      trustAll = ${?CLUSTER_MTLS_TRUST_ALL} # trust any CA
      trustAll = ${?OTOROSHI_CLUSTER_MTLS_TRUST_ALL} # trust any CA
    }
    proxy {
			enabled = ${?CLUSTER_PROXY_ENABLED}  # enable proxy
			host = ${?CLUSTER_PROXY_HOST},
			port = ${?CLUSTER_PROXY_PORT},
			principal = ${?CLUSTER_PROXY_PRINCIPAL},
			password = ${?CLUSTER_PROXY_PASSWORD},
			ntlmDomain = ${?CLUSTER_PROXY_NTLM_DOMAIN},
			encoding = ${?CLUSTER_PROXY_ENCODING},
    }
    leader {
      name = ${?CLUSTER_LEADER_NAME} # the leader name
      name = ${?OTOROSHI_CLUSTER_LEADER_NAME} # the leader name
      urlsStr = ${?CLUSTER_LEADER_URLS} # the leader urls
      urlsStr = ${?OTOROSHI_CLUSTER_LEADER_URLS} # the leader urls
      url = ${?CLUSTER_LEADER_URL} # the leader url
      url = ${?OTOROSHI_CLUSTER_LEADER_URL} # the leader url
      host = ${?CLUSTER_LEADER_HOST} # the leaders api hostname
      host = ${?OTOROSHI_CLUSTER_LEADER_HOST} # the leaders api hostname
      clientId = ${?CLUSTER_LEADER_CLIENT_ID} # the leaders apikey id to access otoroshi admin api
      clientId = ${?OTOROSHI_CLUSTER_LEADER_CLIENT_ID} # the leaders apikey id to access otoroshi admin api
      clientSecret = ${?CLUSTER_LEADER_CLIENT_SECRET} # the leaders apikey secret to access otoroshi admin api
      clientSecret = ${?OTOROSHI_CLUSTER_LEADER_CLIENT_SECRET} # the leaders apikey secret to access otoroshi admin api
      groupingBy = ${?CLUSTER_LEADER_GROUP_BY} # items grouping when streaming state
      groupingBy = ${?OTOROSHI_CLUSTER_LEADER_GROUP_BY} # items grouping when streaming state
      cacheStateFor = ${?CLUSTER_LEADER_CACHE_STATE_FOR} # the ttl for local state cache
      cacheStateFor = ${?OTOROSHI_CLUSTER_LEADER_CACHE_STATE_FOR} # the ttl for local state cache
      stateDumpPath = ${?CLUSTER_LEADER_DUMP_PATH} # eventually a dump state path for debugging purpose
      stateDumpPath = ${?OTOROSHI_CLUSTER_LEADER_DUMP_PATH} # eventually a dump state path for debugging purpose
    }
    worker {
      name = ${?CLUSTER_WORKER_NAME} # the workers name
      name = ${?OTOROSHI_CLUSTER_WORKER_NAME} # the workers name
      retries = ${?CLUSTER_WORKER_RETRIES} # the number of retries when pushing quotas/pulling state
      retries = ${?OTOROSHI_CLUSTER_WORKER_RETRIES} # the number of retries when pushing quotas/pulling state
      timeout = ${?CLUSTER_WORKER_TIMEOUT} # the workers timeout when interacting with leaders
      timeout = ${?OTOROSHI_CLUSTER_WORKER_TIMEOUT} # the workers timeout when interacting with leaders
      tenantsStr = ${?CLUSTER_WORKER_TENANTS} # the list (coma separated) of organization served by this worker. If none, it&#39;s all
      tenantsStr = ${?OTOROSHI_CLUSTER_WORKER_TENANTS} # the list (coma separated) of organization served by this worker. If none, it&#39;s all
      dbpath = ${?CLUSTER_WORKER_DB_PATH} # state dump path for debugging purpose
      dbpath = ${?OTOROSHI_CLUSTER_WORKER_DB_PATH} # state dump path for debugging purpose
      dataStaleAfter = ${?CLUSTER_WORKER_DATA_STALE_AFTER} # the amount of time needed to consider state is stale
      dataStaleAfter = ${?OTOROSHI_CLUSTER_WORKER_DATA_STALE_AFTER} # the amount of time needed to consider state is stale
      swapStrategy = ${?CLUSTER_WORKER_SWAP_STRATEGY} # the internal memory store strategy, can be Replace or Merge
      swapStrategy = ${?OTOROSHI_CLUSTER_WORKER_SWAP_STRATEGY} # the internal memory store strategy, can be Replace or Merge
      modern = ${?CLUSTER_WORKER_STORE_MODERN}
      modern = ${?OTOROSHI_CLUSTER_WORKER_STORE_MODERN}
      state {
        retries = ${otoroshi.cluster.worker.retries} # the number of retries when pulling state
        retries = ${?CLUSTER_WORKER_STATE_RETRIES} # the number of retries when pulling state
        retries = ${?OTOROSHI_CLUSTER_WORKER_STATE_RETRIES} # the number of retries when pulling state
        pollEvery = ${?CLUSTER_WORKER_POLL_EVERY} # polling interval
        pollEvery = ${?OTOROSHI_CLUSTER_WORKER_POLL_EVERY} # polling interval
        timeout = ${otoroshi.cluster.worker.timeout} # the workers timeout when polling state
        timeout = ${?CLUSTER_WORKER_POLL_TIMEOUT} # the workers timeout when polling state
        timeout = ${?OTOROSHI_CLUSTER_WORKER_POLL_TIMEOUT} # the workers timeout when polling state
      }
      quotas {
        retries = ${otoroshi.cluster.worker.retries} # the number of retries when pushing quotas
        retries = ${?CLUSTER_WORKER_QUOTAS_RETRIES} # the number of retries when pushing quotas
        retries = ${?OTOROSHI_CLUSTER_WORKER_QUOTAS_RETRIES} # the number of retries when pushing quotas
        pushEvery = ${?CLUSTER_WORKER_PUSH_EVERY} # pushing interval
        pushEvery = ${?OTOROSHI_CLUSTER_WORKER_PUSH_EVERY} # pushing interval
        timeout = ${otoroshi.cluster.worker.timeout} # the workers timeout when pushing quotas
        timeout = ${?CLUSTER_WORKER_PUSH_TIMEOUT} # the workers timeout when pushing quotas
        timeout = ${?OTOROSHI_CLUSTER_WORKER_PUSH_TIMEOUT} # the workers timeout when pushing quotas
      }
    }
    analytics { # settings for the analytics actor system which is separated from otoroshi default one for performance reasons
      pressure {
        enabled = ${?OTOROSHI_ANALYTICS_PRESSURE_ENABLED}
      }
      actorsystem {
        akka {
          version = ${akka.version}
          default-dispatcher {
            fork-join-executor {
            }
          }
          # http {
          #   parsing {
          #     max-chunk-size             = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_CHUNK_SIZE}
          #     max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_CHUNK_SIZE}
          #     max-content-length         = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_CONTENT_LENGHT}
          #     max-content-length         = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_CONTENT_LENGHT}
          #     max-to-strict-bytes        = ${?AKKA_HTTP_CLIENT_ANALYTICS_MAX_TO_STRICT_BYTES}
          #     max-to-strict-bytes        = ${?OTOROSHI_AKKA_HTTP_CLIENT_ANALYTICS_MAX_TO_STRICT_BYTES}
          #   }
          # }
        }
      }
    }
  }
  headers { # the default headers value for specific otoroshi headers
  }
  requests {
    validate = ${?OTOROSHI_REQUESTS_VALIDATE}
    maxUrlLength = ${akka.http.parsing.max-uri-length}
    maxCookieLength = ${akka.http.parsing.max-header-value-length}
    maxHeaderNameLength = ${akka.http.parsing.max-header-name-length}
    maxHeaderValueLength = ${akka.http.parsing.max-header-value-length}
  }
  jmx {
    enabled = ${?OTOROSHI_JMX_ENABLED}
    port = ${?OTOROSHI_JMX_PORT}
  }
  loggers {
  }
  provider {
    dashboardUrl = ${?OTOROSHI_PROVIDER_DASHBOARD_URL}
    jsUrl = ${?OTOROSHI_PROVIDER_JS_URL}
    cssUrl = ${?OTOROSHI_PROVIDER_CSS_URL}
    secret = ${?OTOROSHI_PROVIDER_SECRET}
    title = ${?OTOROSHI_PROVIDER_TITLE}
  }
  healthcheck {
    workers = ${?OTOROSHI_HEALTHCHECK_WORKERS}
    block-on-red = ${?OTOROSHI_HEALTHCHECK_BLOCK_ON_RED}
    block-on-red = ${?OTOROSHI_HEALTHCHECK_BLOCK_ON_500}
    ttl = ${?OTOROSHI_HEALTHCHECK_TTL}
    ttl-only = ${?OTOROSHI_HEALTHCHECK_TTL_ONLY}
  }
  vaults {
    enabled = ${?OTOROSHI_VAULTS_ENABLED}
    secrets-ttl = ${?OTOROSHI_VAULTS_SECRETS_TTL}
    secrets-error-ttl = ${?OTOROSHI_VAULTS_SECRETS_ERROR_TTL}
    cached-secrets = ${?OTOROSHI_VAULTS_CACHED_SECRETS}
    read-timeout = ${?otoroshi.vaults.read-ttl}
		read-timeout = ${?OTOROSHI_VAULTS_READ_TTL}
		read-timeout = ${?OTOROSHI_VAULTS_READ_TIMEOUT}
    parallel-fetchs = ${?OTOROSHI_VAULTS_PARALLEL_FETCHS}
    leader-fetch-only = ${?OTOROSHI_VAULTS_LEADER_FETCH_ONLY}
    env {
      prefix = ${?OTOROSHI_VAULTS_ENV_PREFIX}
    }
    local {
    	root = ${?OTOROSHI_VAULTS_LOCAL_ROOT}
    }
    # hashicorpvault {
    # }
  }
  tunnels {
    enabled = ${?OTOROSHI_TUNNELS_ENABLED}
    worker-ws = ${?OTOROSHI_TUNNELS_WORKER_WS}
    worker-use-internal-ports = ${?OTOROSHI_TUNNELS_WORKER_USE_INTERNAL_PORTS}
    worker-use-loadbalancing = ${?OTOROSHI_TUNNELS_WORKER_USE_LOADBALANCING}
    default {
      enabled = ${?OTOROSHI_TUNNELS_DEFAULT_ENABLED}
      id = ${?OTOROSHI_TUNNELS_DEFAULT_ID}
      name = ${?OTOROSHI_TUNNELS_DEFAULT_NAME}
			url = ${?OTOROSHI_TUNNELS_DEFAULT_URL}
			host = ${?OTOROSHI_TUNNELS_DEFAULT_HOST}
			clientId = ${?OTOROSHI_TUNNELS_DEFAULT_CLIENT_ID}
			clientSecret = ${?OTOROSHI_TUNNELS_DEFAULT_CLIENT_SECRET}
			export-routes = ${?OTOROSHI_TUNNELS_DEFAULT_EXPORT_ROUTES} # send routes information to remote otoroshi instance to facilitate remote route exposition
			export-routes-tag = ${?OTOROSHI_TUNNELS_DEFAULT_EXPORT_TAG} # only send routes information if the route has this tag
      proxy {
      }
    }
  }
  admin-extensions {
  	enabled = ${?OTOROSHI_ADMIN_EXTENSIONS_ENABLED}
  	configurations {
  		otoroshi_extensions_foo {
  		}
  	}
  }
}
http.port = ${?otoroshi.http.port}     # the main http port for the otoroshi server
http.port = ${?PORT}                   # the main http port for the otoroshi server
http.port = ${?OTOROSHI_PORT}                   # the main http port for the otoroshi server
http.port = ${?OTOROSHI_HTTP_PORT}                   # the main http port for the otoroshi server
play.server.http.port = ${http.port}   # the main http port for the otoroshi server
play.server.http.port = ${?PORT}       # the main http port for the otoroshi server
play.server.http.port = ${?OTOROSHI_PORT}       # the main http port for the otoroshi server
play.server.http.port = ${?OTOROSHI_HTTP_PORT}       # the main http port for the otoroshi server
https.port = ${?otoroshi.https.port}   # the main https port for the otoroshi server
https.port = ${?HTTPS_PORT}            # the main https port for the otoroshi server
https.port = ${?OTOROSHI_HTTPS_PORT}            # the main https port for the otoroshi server
play.server.https.keyStoreDumpPath = ${?HTTPS_KEYSTORE_DUMP_PATH}           # the file path where the TLSContext will be dumped (for debugging purposes only)
play.server.https.keyStoreDumpPath = ${?OTOROSHI_HTTPS_KEYSTORE_DUMP_PATH}           # the file path where the TLSContext will be dumped (for debugging purposes only)
play.http.secret.key = ${otoroshi.secret}       # the secret used to signed session cookies                       
play.http.secret.key = ${?PLAY_CRYPTO_SECRET}   # the secret used to signed session cookies
play.http.secret.key = ${?OTOROSHI_CRYPTO_SECRET}   # the secret used to signed session cookies
play.server.http.idleTimeout = ${?PLAY_SERVER_IDLE_TIMEOUT}       # the default server idle timeout
play.server.http.idleTimeout = ${?OTOROSHI_SERVER_IDLE_TIMEOUT}       # the default server idle timeout
play.server.akka.requestTimeout = ${?PLAY_SERVER_REQUEST_TIMEOUT} # the default server idle timeout (for akka server specifically)
play.server.akka.requestTimeout = ${?OTOROSHI_SERVER_REQUEST_TIMEOUT} # the default server idle timeout (for akka server specifically)
http2.enabled = ${?otoroshi.http2.enabled}
http2.enabled = ${?HTTP2_ENABLED}  # enable HTTP2 support
http2.enabled = ${?OTOROSHI_HTTP2_ENABLED}  # enable HTTP2 support
play.server.https.keyStore.path=${?HTTPS_KEYSTORE_PATH}         # settings for the default server keystore
play.server.https.keyStore.path=${?OTOROSHI_HTTPS_KEYSTORE_PATH}         # settings for the default server keystore
play.server.https.keyStore.type=${?HTTPS_KEYSTORE_TYPE}         # settings for the default server keystore
play.server.https.keyStore.type=${?OTOROSHI_HTTPS_KEYSTORE_TYPE}         # settings for the default server keystore
play.server.https.keyStore.password=${?HTTPS_KEYSTORE_PASSWORD} # settings for the default server keystore
play.server.https.keyStore.password=${?OTOROSHI_HTTPS_KEYSTORE_PASSWORD} # settings for the default server keystore
play.server.https.keyStore.algorithm=${?HTTPS_KEYSTORE_ALGO}    # settings for the default server keystore
play.server.https.keyStore.algorithm=${?OTOROSHI_HTTPS_KEYSTORE_ALGO}    # settings for the default server keystore
play.server.websocket.frame.maxLength = ${?OTOROSHI_WEBSOCKET_FRAME_MAX_LENGTH}
play.http {
  session {
    secure = ${?SESSION_SECURE_ONLY}  # the cookie for otoroshi backoffice should be exhanged over https only
    secure = ${?OTOROSHI_SESSION_SECURE_ONLY}  # the cookie for otoroshi backoffice should be exhanged over https only
    maxAge = ${?SESSION_MAX_AGE}      # the cookie for otoroshi backoffice max age
    maxAge = ${?OTOROSHI_SESSION_MAX_AGE}      # the cookie for otoroshi backoffice max age
    # domain = &quot;.&quot;${?app.domain}         # the cookie for otoroshi backoffice domain
    domain = &quot;.&quot;${otoroshi.domain}    # the cookie for otoroshi backoffice domain
    domain = ${?SESSION_DOMAIN}       # the cookie for otoroshi backoffice domain
    domain = ${?OTOROSHI_SESSION_DOMAIN}       # the cookie for otoroshi backoffice domain
    cookieName = ${?SESSION_NAME}     # the cookie for otoroshi backoffice name
    cookieName = ${?OTOROSHI_SESSION_NAME}     # the cookie for otoroshi backoffice name
  }
}
akka { # akka specific configuration
  actor {
    default-dispatcher {
      fork-join-executor {     
        parallelism-factor = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_FACTOR}
        parallelism-min = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_MIN}
        parallelism-max = ${?OTOROSHI_AKKA_DISPATCHER_PARALLELISM_MAX}
        task-peeking-mode = ${?OTOROSHI_AKKA_DISPATCHER_TASK_PEEKING_MODE}
      }
      throughput = ${?OTOROSHI_AKKA_DISPATCHER_THROUGHPUT}
    }
  }
  http {
    server {
      max-connections = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CONNECTIONS}
      pipelining-limit = ${?OTOROSHI_AKKA_HTTP_SERVER_PIPELINING_LIMIT}
      backlog = ${?OTOROSHI_AKKA_HTTP_SERVER_BACKLOG}
      socket-options {
      }
      http2 {
      }
    }
    client {
      socket-options {
      }
    }
    host-connection-pool {
      max-connections = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_MAX_CONNECTIONS}
      max-open-requests = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_MAX_OPEN_REQUESTS}
      pipelining-limit = ${?OTOROSHI_AKKA_HTTP_SERVER_HOST_CONNECTION_POOL_PIPELINING_LIMIT}
      client {
        socket-options {
        }
      }
    }
    parsing {
      max-uri-length             = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_URI_LENGTH}
      max-method-length          = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_METHOD_LENGTH}
      max-response-reason-length = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_RESPONSE_REASON_LENGTH}
      max-header-name-length     = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_NAME_LENGTH}
      max-header-value-length    = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_VALUE_LENGTH}
      max-header-count           = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_HEADER_COUNT}
      max-chunk-ext-length       = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CHUNK_EXT_LENGTH}
      max-chunk-size             = ${?AKKA_HTTP_SERVER_MAX_CHUNK_SIZE}
      max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CHUNK_SIZE}
      max-chunk-size             = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CHUNK_SIZE}
      max-content-length         = ${?AKKA_HTTP_SERVER_MAX_CONTENT_LENGHT}
      max-content-length         = ${?OTOROSHI_AKKA_HTTP_SERVER_MAX_CONTENT_LENGHT}
      max-content-length         = ${?OTOROSHI_AKKA_HTTP_SERVER_PARSING_MAX_CONTENT_LENGHT}
    }
  }
}</code></pre>
<div class="nav-next">
<p><strong>Next:</strong> <a href="../install/run-otoroshi.html">Run Otoroshi</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../install/setup-otoroshi.html#setup-otoroshi" class="header">Setup Otoroshi</a>
  <ul>
    <li><a href="../install/setup-otoroshi.html#setup-the-database" class="header">Setup the database</a></li>
    <li><a href="../install/setup-otoroshi.html#setup-your-hosts-before-running" class="header">Setup your hosts before running</a></li>
    <li><a href="../install/setup-otoroshi.html#setup-your-configuration-file" class="header">Setup your configuration file</a></li>
    <li><a href="../install/setup-otoroshi.html#configuration-with-env-variables" class="header">Configuration with env. variables</a></li>
    <li><a href="../install/setup-otoroshi.html#reference-configuration-for-env-variables" class="header">Reference configuration for env. variables</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2023</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/elasticlunr/0.9.5/elasticlunr.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112498312-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-112498312-1');
</script>
</html>





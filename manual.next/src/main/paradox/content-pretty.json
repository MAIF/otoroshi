[
  {
    "name": "about.md",
    "id": "/about.md",
    "url": "/about.html",
    "title": "About Otoroshi",
    "content": "# About Otoroshi\n\nAt the beginning of 2017, we had the need to create a new environment to be able to create new \"digital\" products very quickly in an agile fashion at @link:[MAIF](https://www.maif.fr) { open=new }. Naturally we turned to PaaS solutions and chose the excellent @link:[Clever Cloud](https://www.clever-cloud.com) { open=new } product to run our apps. \n\nWe also chose that every feature team will have the freedom to choose its own technological stack to build its product. It was a nice move but it has also introduced some challenges in terms of homogeneity for traceability, security, logging, ... because we did not want to force library usage in the products. We could have used something like @link:[Service Mesh Pattern](http://philcalcado.com/2017/08/03/pattern_service_mesh.html) { open=new } but the deployement model of @link:[Clever Cloud](https://www.clever-cloud.com) { open=new } prevented us to do it.\n\nThe right solution was to use a reverse proxy or some kind of API Gateway able to provide tracability, logging, security with apikeys, quotas, DNS as a service locator, etc. We needed something easy to use, with a human friendly UI, a nice API to extends its features, true hot reconfiguration, able to generate internal events for third party usage. A couple of solutions were available at that time, but not one seems to fit our needs, there was always something missing, too complicated for our needs or not playing well with @link:[Clever Cloud](https://www.clever-cloud.com) { open=new } deployment model.\n\nAt some point, we tried to write a small prototype to explore what could be our dream reverse proxy. The design was very simple, there were some rough edges but every major feature needed was there waiting to be enhanced.\n\n**Otoroshi** was born and we decided to move ahead with our hairy monster :)\n\n## Philosophy \n\nEvery OSS product build at @link:[MAIF](https://www.maif.fr) { open=new } like the develoer portal @link:[Daikoku](https://maif.github.io/daikoku) { open=new } or @link:[Izanami](https://maif.github.io/izanami) { open=new } follow a common philosophy. \n\n* the services or API provided should be **technology agnostic**.\n* **http first**: http is the right answer to the previous quote   \n* **api First**: the UI is just another client of the api. \n* **secured**: the services exposed need authentication for both humans or machines  \n* **event based**: the services should expose a way to get notified of what happened inside.  \n"
  },
  {
    "name": "api.md",
    "id": "/api.md",
    "url": "/api.html",
    "title": "Admin REST API",
    "content": "# Admin REST API\n\nOtoroshi provides a fully featured REST admin API to perform almost every operation possible in the Otoroshi dashboard. The Otoroshi dashbaord is just a regular consumer of the admin API.\n\nUsing the admin API, you can do whatever you want and enhance your Otoroshi instances with a lot of features that will feet your needs.\n\n## Swagger descriptor\n\nThe Otoroshi admin API is described using OpenAPI format and is available at :\n\nhttps://maif.github.io/otoroshi/manual/code/openapi.json\n\nEvery Otoroshi instance provides its own embedded OpenAPI descriptor at :\n\nhttp://otoroshi.oto.tools:8080/api/openapi.json\n\n## Swagger documentation\n\nYou can read the OpenAPI descriptor in a more human friendly fashion using `Swagger UI`. The swagger UI documentation of the Otoroshi admin API is available at :\n\nhttps://maif.github.io/otoroshi/swagger-ui/index.html\n\nEvery Otoroshi instance provides its own embedded OpenAPI descriptor at :\n\nhttp://otoroshi.oto.tools:8080/api/swagger/ui\n\nYou can also read the swagger UI documentation of the Otoroshi admin API below :\n\n@@@ div { .swagger-frame }\n\n\n@@@\n"
  },
  {
    "name": "architecture.md",
    "id": "/architecture.md",
    "url": "/architecture.html",
    "title": "Architecture",
    "content": "# Architecture\n\nWhen we started the development of Otoroshi, we had several classical patterns in mind like `Service gateway`, `Service locator`, `Circuit breakers`, etc ...\n\nAt start we thought about providing a bunch of librairies that would be included in each microservice or app to perform these tasks. But the more we were thinking about it, the more it was feeling weird, unagile, etc, it also prevented us to use any technical stack we wanted to use. So we decided to change our approach to something more universal.\n\nWe chose to make Otoroshi the central part of our microservices system, something between a reverse-proxy, a service gateway and a service locator where each call to a microservice (even from another microservice) must pass through Otoroshi. There are multiple benefits to do that, each call can be logged, audited, monitored, integrated with a circuit breaker, etc without imposing libraries and technical stack. Any service is exposed through its own domain and we rely only on DNS to handle the service location part. Any access to a service is secured by default with an api key and is supervised by a circuit breaker to avoid cascading failures.\n\n@@@ div { .centered-img }\n<img src=\"./imgs/architecture-1-bis.png\" />\n@@@\n\nOtoroshi tries to embrace our @ref:[global philosophy](./about.md#philosophy) by providing a full featured REST admin api, a gorgeous admin dashboard written in @link:[React](https://reactjs.org) { open=new } that uses the api, by generating traffic events, alerts events, audit events that can be consumed by several channels. Otoroshi also supports a bunch of datastores to better match with different use cases.\n\n@@@ div { .centered-img }\n<img src=\"./imgs/architecture-2-bis.png\" />\n@@@\n"
  },
  {
    "name": "aws.md",
    "id": "/deploy/aws.md",
    "url": "/deploy/aws.html",
    "title": "AWS - Elastic Beanstalk",
    "content": "# AWS - Elastic Beanstalk\n\nNow you want to use Otoroshi on AWS. There are multiple options to deploy Otoroshi on AWS, \nfor instance :\n\n* You can deploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) on [Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html)\n* You can create a basic [Amazon EC2](https://docs.aws.amazon.com/fr_fr/AWSEC2/latest/UserGuide/concepts.html), access it via SSH, then \ndeploy the @ref:[otoroshi.jar](../install/get-otoroshi.md#from-jar-file)     \n* Or you can use [AWS Elastic Beanstalk](https://aws.amazon.com/fr/elasticbeanstalk)\n\nIn this section we are going to cover how to deploy Otoroshi on [AWS Elastic Beanstalk](https://aws.amazon.com/fr/elasticbeanstalk). \n\n## AWS Elastic Beanstalk Overview\nUnlike Clever Cloud, to deploy an application on AWS Elastic Beanstalk, you don't link your app to your VCS repository, push your code and expect it to be built and run.\n\nAWS Elastic Beanstalk does only the run part. So you have to handle your own build pipeline, upload a Zip file containing your runnable, then AWS Elastic Beanstalk will take it from there.  \n  \nEg: for apps running on the JVM (Scala/Java/Kotlin) a Zip with the jar inside would suffice, for apps running in a Docker container, a Zip with the DockerFile would be enough.   \n\n\n## Prepare your deployment target\nActually, there are 2 options to build your target. \n\nEither you create a DockerFile from this @ref:[Docker image](../install/get-otoroshi.md#from-docker), build a zip, and do all the Otoroshi custom configuration using ENVs.\n\nOr you download the @ref:[otoroshi.jar](../install/get-otoroshi.md#from-jar-file), do all the Otoroshi custom configuration using your own otoroshi.conf, and create a DockerFile that runs the jar using your otoroshi.conf. \n\nFor the second option your DockerFile would look like this :\n\n```dockerfile\nFROM openjdk:11\nVOLUME /tmp\nEXPOSE 8080\nADD otoroshi.jar otoroshi.jar\nADD otoroshi.conf otoroshi.conf\nRUN sh -c 'touch /otoroshi.jar'\nENV JAVA_OPTS=\"\"\nENTRYPOINT [ \"sh\", \"-c\", \"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -Dconfig.file=/otoroshi.conf -jar /otoroshi.jar\" ]\n``` \n \nI'd recommend the second option.\n       \nNow Zip your target (Jar + Conf + DockerFile) and get ready for deployment.     \n\n## Create an Otoroshi instance on AWS Elastic Beanstalk\nFirst, go to [AWS Elastic Beanstalk Console](https://eu-west-3.console.aws.amazon.com/elasticbeanstalk/home?region=eu-west-3#/welcome), don't forget to sign in and make sure that you are in the good region (eg : eu-west-3 for Paris).\n\nHit **Get started** \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-0.png\" />\n@@@\n\nSpecify the **Application name** of your application, Otoroshi for example.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-1.png\" />\n@@@\n \nChoose the **Platform** of the application you want to create, in your case use Docker.\n\nFor **Application code** choose **Upload your code** then hit **Upload**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-2.png\" />\n@@@\n\nBrowse the zip created in the [previous section](#prepare-your-deployment-target) from your machine. \n\nAs you can see in the image above, you can also choose an S3 location, you can imagine that at the end of your build pipeline you upload your Zip to S3, and then get it from there (I wouldn't recommend that though).\n  \nWhen the upload is done, hit **Configure more options**.\n   \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-3.png\" />\n@@@ \n \nRight now an AWS Elastic Beanstalk application has been created, and by default an environment named Otoroshi-env is being created as well.\n\nAWS Elastic Beanstalk can manage multiple environments of the same application, for instance environments can be (prod, preprod, expriments...).  \n\nOtoroshi is a bit particular, it doesn't make much sense to have multiple environments, since Otoroshi will handle all the requests from/to downstream services regardless of the environment.        \n \nAs you see in the image above, we are now configuring the Otoroshi-env, the one and only environment of Otoroshi.\n  \nFor **Configuration presets**, choose custom configuration, now you have a load balancer for your environment with the capacity of at least one instance and at most four.\nI'd recommend at least 2 instances, to change that, on the **Capacity** card hit **Modify**.         \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-4.png\" />\n@@@\n\nChange the **Instances** to min 2, max 4 then hit **Save**. For the **Scaling triggers**, I'd keep the default values, but know that you can edit the capacity config any time you want, it only costs a redeploy, which will be done automatically by the way.\n       \nInstances size is by default t2.micro, which is a bit small for running Otoroshi, I'd recommend a t2.medium.     \nOn the **Instances** card hit **Modify**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-5.png\" />\n@@@\n\nFor **Instance type** choose t2.medium, then hit **Save**, no need to change the volume size, unless you have a lot of http call faults, which means a lot more logs, in that case the default volume size may not be enough.\n\nThe default environment created for Otoroshi, for instance Otoroshi-env, is a web server environment which fits in your case, but the thing is that on AWS Elastic Beanstalk by default a web server environment for a docker-based application, runs behind an Nginx proxy.\nWe have to remove that proxy. So on the **Software** card hit **Modify**.\n        \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-6.png\" />\n@@@        \n    \nFor **Proxy server** choose None then hit **Save**.\n\nAlso note that you can set Envs for Otoroshi in same page (see image below). \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-7.png\" />\n@@@  \n\nTo finalise the creation process, hit **Create app** on the bottom right.\n\nThe Otoroshi app is now created, and it's running which is cool, but we still don't have neither a **datastore** nor **https**.\n  \n## Create an Otoroshi datastore on AWS ElastiCache\n\nBy default Otoroshi uses non persistent memory to store it's data, Otoroshi supports many kinds of datastores. In this section we will be covering Redis datastore.   \n\nBefore starting, using a datastore hosted by AWS is not at all mandatory, feel free to use your own if you like, but if you want to learn more about ElastiCache, this section may interest you, otherwise you can skip it.\n\nGo to [AWS ElastiCache](https://eu-west-3.console.aws.amazon.com/elasticache/home?region=eu-west-3#) and hit **Get Started Now**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-8.png\" />\n@@@  \n\nFor **Cluster engine** keep Redis.\n\nChoose a **Name** for your datastore, for instance otoroshi-datastore.\n\nYou can keep all the other default values and hit **Create** on the bottom right of the page.\n\nOnce your Redis Cluster is created, it would look like the image below.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-9.png\" />\n@@@  \n\n\nFor applications in the same security group as your cluster, redis cluster is accessible via the **Primary Endpoint**. Don't worry the default security group is fine, you don't need any configuration to access the cluster from Otoroshi.\n\nTo make Otoroshi use the created cluster, you can either use Envs `APP_STORAGE=redis`, `REDIS_HOST` and `REDIS_PORT`, or set `app.storage=redis`, `app.redis.host` and `app.redis.port` in your otoroshi.conf.\n\n## Create SSL certificate and configure your domain\n\nOtoroshi has now a datastore, but not yet ready for use. \n\nIn order to get it ready you need to :\n\n* Configure Otoroshi with your domain \n* Create a wildcard SSL certificate for your domain\n* Configure Otoroshi AWS Elastic Beanstalk instance with the SSL certificate \n* Configure your DNS to redirect all traffic on your domain to Otoroshi  \n  \n### Configure Otoroshi with your domain\n\nYou can use ENVs or you can use a custom otoroshi.conf in your Docker container.\n\nFor the second option your otoroshi.conf would look like this :\n\n``` \n   include \"application.conf\"\n   http.port = 8080\n   app {\n     env = \"prod\"\n     domain = \"mysubdomain.oto.tools\"\n     rootScheme = \"https\"\n     snowflake {\n       seed = 0\n     }\n     events {\n       maxSize = 1000\n     }\n     backoffice {\n       subdomain = \"otoroshi\"\n       session {\n         exp = 86400000\n       }\n     }\n     \n     storage = \"redis\"\n     redis {\n        host=\"myredishost\"\n        port=myredisport\n     }\n   \n     privateapps {\n       subdomain = \"privateapps\"\n     }\n   \n     adminapi {\n       targetSubdomain = \"otoroshi-admin-internal-api\"\n       exposedSubdomain = \"otoroshi-api\"\n       defaultValues {\n         backOfficeGroupId = \"admin-api-group\"\n         backOfficeApiKeyClientId = \"admin-client-id\"\n         backOfficeApiKeyClientSecret = \"admin-client-secret\"\n         backOfficeServiceId = \"admin-api-service\"\n       }\n       proxy {\n         https = true\n         local = false\n       }\n     }\n     claim {\n       sharedKey = \"myclaimsharedkey\"\n     }\n   }\n   \n   play.http {\n     session {\n       secure = false\n       httpOnly = true\n       maxAge = 2147483646\n       domain = \".mysubdomain.oto.tools\"\n       cookieName = \"oto-sess\"\n     }\n   }\n``` \n\n### Create a wildcard SSL certificate for your domain\n\nGo to [AWS Certificate Manager](https://eu-west-3.console.aws.amazon.com/acm/home?region=eu-west-3#/firstrun).\n\nBelow **Provision certificates** hit **Get started**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-10.png\" />\n@@@   \n \nKeep the default selected value **Request a public certificate** and hit **Request a certificate**.\n \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-11.png\" />\n@@@  \n\nPut your **Domain name**, use *. for wildcard, for instance *\\*.mysubdomain.oto.tools*, then hit **Next**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-12.png\" />\n@@@  \n\nYou can choose between **Email validation** and **DNS validation**, I'd recommend **DNS validation**, then hit **Review**.    \n    \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-13.png\" />\n@@@ \n \nVerify that you did put the right **Domain name** then hit **Confirm and request**.   \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-14.png\" />\n@@@\n \nAs you see in the image above, to let Amazon do the validation you have to add the `CNAME` record to your DNS configuration. Normally this operation takes around one day.\n  \n### Configure Otoroshi AWS Elastic Beanstalk instance with the SSL certificate \n\nOnce the certificate is validated, you need to modify the configuration of Otoroshi-env to add the SSL certificate for HTTPS. \nFor that you need to go to [AWS Elastic Beanstalk applications](https://eu-west-3.console.aws.amazon.com/elasticbeanstalk/home?region=eu-west-3#/applications),\nhit **Otoroshi-env**, then on the left side hit **Configuration**, then on the **Load balancer** card hit **Modify**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-15.png\" />\n@@@\n\nIn the **Application Load Balancer** section hit **Add listener**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-16.png\" />\n@@@\n\nFill the popup as the image above, then hit **Add**.   \n\nYou should now be seeing something like this : \n   \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-17.png\" />\n@@@   \n \n \nMake sure that your listener is enabled, and on the bottom right of the page hit **Apply**.\n\nNow you have **https**, so let's use Otoroshi.\n\n### Configure your DNS to redirect all traffic on your domain to Otoroshi\n  \nIt's actually pretty simple, you just need to add a `CNAME` record to your DNS configuration, that redirects *\\*.mysubdomain.oto.tools* to the DNS name of Otoroshi's load balancer.\n\nTo find the DNS name of Otoroshi's load balancer go to [AWS Ec2](https://eu-west-3.console.aws.amazon.com/ec2/v2/home?region=eu-west-3#LoadBalancers:tag:elasticbeanstalk:environment-name=Otoroshi-env;sort=loadBalancerName)\n\nYou would find something like this : \n  \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-18.png\" />\n@@@   \n\nThere is your DNS name, so add your `CNAME` record. \n \nOnce all these steps are done, the AWS Elastic Beanstalk Otoroshi instance, would now be handling all the requests on your domain. ;)    \n"
  },
  {
    "name": "clever-cloud.md",
    "id": "/deploy/clever-cloud.md",
    "url": "/deploy/clever-cloud.html",
    "title": "Clever-Cloud",
    "content": "# Clever-Cloud\n\nNow you want to use Otoroshi on Clever Cloud. Otoroshi has been designed and created to run on Clever Cloud and a lot of choices were made because of how Clever Cloud works.\n\n## Create an Otoroshi instance on CleverCloud\n\nIf you want to customize the configuration @ref:[use env. variables](../install/setup-otoroshi.md#configuration-with-env-variables), you can use [the example provided below](#example-of-clevercloud-env-variables)\n\nCreate a new CleverCloud app based on a clevercloud git repo (not empty) or a github project of your own (not empty).\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-jar-0.png\" />\n@@@\n\nThen choose what kind of app your want to create, for Otoroshi, choose `Java + Jar`\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-jar-1.png\" />\n@@@\n\nNext, set up choose instance size and auto-scalling. Otoroshi can run on small instances, especially if you just want to test it.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-2.png\" />\n@@@\n\nFinally, choose a name for your app\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-3.png\" />\n@@@\n\nNow you just need to customize environnment variables\n\nat this point, you can also add other env. variables to configure Otoroshi like in [the example provided below](#example-of-clevercloud-env-variables)\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-4-bis.png\" />\n@@@\n\nYou can also use expert mode :\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-4.png\" />\n@@@\n\nNow, your app is ready, don't forget to add a custom domains name on the CleverCloud app matching the Otoroshi app domain. \n\n## Example of CleverCloud env. variables\n\nYou can add more env variables to customize your Otoroshi instance like the following. Use the expert mode to copy/paste all the values in one shot. If you want an real datastore, create a redis addon on clevercloud, link it to your otoroshi app and change the `APP_STORAGE` variable to `redis`\n\n<div id=\"clevercloud-envvars\"></div>\n\n<div class=\"hide\">\n```\nADMIN_API_CLIENT_ID=xxxx\nADMIN_API_CLIENT_SECRET=xxxxx\nADMIN_API_GROUP=xxxxxx\nADMIN_API_SERVICE_ID=xxxxxxx\nCLAIM_SHAREDKEY=xxxxxxx\nOTOROSHI_INITIAL_ADMIN_LOGIN=youremailaddress\nOTOROSHI_INITIAL_ADMIN_PASSWORD=yourpassword\nPLAY_CRYPTO_SECRET=xxxxxx\nSESSION_NAME=oto-session\nAPP_DOMAIN=yourdomain.tech\nAPP_ENV=prod\nAPP_STORAGE=inmemory\nAPP_ROOT_SCHEME=https\nCC_PRE_BUILD_HOOK=curl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/${latest_otoroshi_version}/otoroshi.jar'\nCC_JAR_PATH=./otoroshi.jar\nCC_JAVA_VERSION=11\nPORT=8080\nSESSION_DOMAIN=.yourdomain.tech\nSESSION_MAX_AGE=604800000\nSESSION_SECURE_ONLY=true\nUSER_AGENT=otoroshi\nMAX_EVENTS_SIZE=1\nWEBHOOK_SIZE=100\nAPP_BACKOFFICE_SESSION_EXP=86400000\nAPP_PRIVATEAPPS_SESSION_EXP=86400000\nENABLE_METRICS=true\nOTOROSHI_ANALYTICS_PRESSURE_ENABLED=true\nUSE_CACHE=true\n```\n</div>"
  },
  {
    "name": "clustering.md",
    "id": "/deploy/clustering.md",
    "url": "/deploy/clustering.html",
    "title": "Otoroshi clustering",
    "content": "# Otoroshi clustering\n\nOtoroshi can work as a cluster by default as you can spin many Otoroshi servers using the same datastore or datastore cluster. In that case any instance is capable of serving services, Otoroshi admin UI, Otoroshi admin API, etc.\n\nBut sometimes, this is not enough. So Otoroshi provides an additional clustering model named `Leader / Workers` where there is a leader cluster ([control plane](https://en.wikipedia.org/wiki/Control_plane)), composed of Otoroshi instances backed by a datastore like Redis, PostgreSQL or Cassandra, that is in charge of all `writes` to the datastore through Otoroshi admin UI and API, and a worker cluster ([data plane](https://en.wikipedia.org/wiki/Forwarding_plane)) composed of horizontally scalable Otoroshi instances, backed by a super fast in memory datastore, with the sole purpose of routing traffic to your services based on data synced from the leader cluster. With this distributed Otoroshi version, you can reach your goals of high availability, scalability and security.\n\nOtoroshi clustering only uses http internally (right now) to make communications between leaders and workers instances so it is fully compatible with PaaS providers like [Clever-Cloud](https://www.clever-cloud.com/en/) that only provide one external port for http traffic.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/cluster-6.png\" />\n\n*Fig. 1: Simplified view*\n@@@\n\n@@@ div { .centered-img }\n<img src=\"../imgs/cluster-5.jpg\" />\n\n*Fig. 2: Deployment view*\n@@@\n\n## Cluster configuration\n\n```hocon\notoroshi {\n  cluster {\n    mode = \"leader\" # can be \"off\", \"leader\", \"worker\"\n    compression = 4 # compression of the data sent between leader cluster and worker cluster. From -1 (disabled) to 9\n    leader {\n      name = ${?CLUSTER_LEADER_NAME}   # name of the instance, if none, it will be generated\n      urls = [\"http://127.0.0.1:8080\"] # urls to contact the leader cluster\n      host = \"otoroshi-api.oto.tools\"    # host of the otoroshi api in the leader cluster\n      clientId = \"apikey-id\"           # otoroshi api client id\n      clientSecret = \"secret\"          # otoroshi api client secret\n      cacheStateFor = 4000             # state is cached during (ms)\n    }\n    worker {\n      name = ${?CLUSTER_WORKER_NAME}   # name of the instance, if none, it will be generated\n      retries = 3                      # number of retries when calling leader cluster\n      timeout = 2000                   # timeout when calling leader cluster\n      state {\n        retries = ${otoroshi.cluster.worker.retries} # number of retries when calling leader cluster on state sync\n        pollEvery = 10000                            # interval of time (ms) between 2 state sync\n        timeout = ${otoroshi.cluster.worker.timeout} # timeout when calling leader cluster on state sync\n      }\n      quotas {\n        retries = ${otoroshi.cluster.worker.retries} # number of retries when calling leader cluster on quotas sync\n        pushEvery = 2000                             # interval of time (ms) between 2 quotas sync\n        timeout = ${otoroshi.cluster.worker.timeout} # timeout when calling leader cluster on quotas sync\n      }\n    }\n  }\n}\n```\n\nyou can also use many env. variables to configure Otoroshi cluster\n\n```hocon\notoroshi {\n  cluster {\n    mode = ${?CLUSTER_MODE}\n    compression = ${?CLUSTER_COMPRESSION}\n    leader {\n      name = ${?CLUSTER_LEADER_NAME}\n      host = ${?CLUSTER_LEADER_HOST}\n      url = ${?CLUSTER_LEADER_URL}\n      clientId = ${?CLUSTER_LEADER_CLIENT_ID}\n      clientSecret = ${?CLUSTER_LEADER_CLIENT_SECRET}\n      groupingBy = ${?CLUSTER_LEADER_GROUP_BY}\n      cacheStateFor = ${?CLUSTER_LEADER_CACHE_STATE_FOR}\n      stateDumpPath = ${?CLUSTER_LEADER_DUMP_PATH}\n    }\n    worker {\n      name = ${?CLUSTER_WORKER_NAME}\n      retries = ${?CLUSTER_WORKER_RETRIES}\n      timeout = ${?CLUSTER_WORKER_TIMEOUT}\n      state {\n        retries = ${?CLUSTER_WORKER_STATE_RETRIES}\n        pollEvery = ${?CLUSTER_WORKER_POLL_EVERY}\n        timeout = ${?CLUSTER_WORKER_POLL_TIMEOUT}\n      }\n      quotas {\n        retries = ${?CLUSTER_WORKER_QUOTAS_RETRIES}\n        pushEvery = ${?CLUSTER_WORKER_PUSH_EVERY}\n        timeout = ${?CLUSTER_WORKER_PUSH_TIMEOUT}\n      }\n    }\n  }\n}\n```\n\n@@@ warning\nYou **should** use HTTPS exposition for the Otoroshi API that will be used for data sync as sensitive informations are exchanged between control plane and data plane.\n@@@\n\n@@@ warning\nYou **must** have the same cluster configuration on every Otoroshi instance (worker/leader) with only names and mode changed for each instance. Some things in leader/worker are computed using configuration of their counterpart worker/leader.\n@@@\n\n## Cluster UI\n\nOnce an Otoroshi instance is launcher as cluster Leader, a new row of live metrics tile will be available on the home page of Otoroshi admin UI.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/cluster-3.png\" />\n@@@\n\nyou can also access a more detailed view of the cluster at `Settings (cog icon) / Cluster View`\n\n@@@ div { .centered-img }\n<img src=\"../imgs/cluster-4.png\" />\n@@@\n\n## Run examples\n\nfor leader \n\n```sh\njava -Dhttp.port=8091 -Dhttps.port=9091 -Dotoroshi.cluster.mode=leader -jar otoroshi.jar\n```\n\nfor worker\n\n```sh\njava -Dhttp.port=8092 -Dhttps.port=9092 -Dotoroshi.cluster.mode=worker \\\n  -Dotoroshi.cluster.leader.urls.0=http://127.0.0.1:8091 -jar otoroshi.jar\n```\n\n## Setup a cluster by example\n\nif you want to see how to setup an otoroshi cluster, just check @ref:[the clustering tutorial](../how-to-s/setup-otoroshi-cluster.md)"
  },
  {
    "name": "index.md",
    "id": "/deploy/index.md",
    "url": "/deploy/index.html",
    "title": "Deploy to production",
    "content": "# Deploy to production\n\nNow it's time to deploy Otoroshi in production, in this chapter we will see what kind of things you can do.\n\nOtoroshi can run wherever you want, even on a raspberry pi (Cluster^^) ;)\n\n@@@div { .plugin .platform }\n## Clever Cloud\n\nOtoroshi provides an integration to create easily services based on application deployed on your Clever Cloud account.\n\n<img src=\"../imgs/clever-cloud.png\" />\n@ref:[Documentation](./clever-cloud.md)\n@@@\n\n@@@div { .plugin .platform } \n## Kubernetes\nStarting at version 1.5.0, Otoroshi provides a native Kubernetes support.\n\n<img src=\"../imgs/kubernetes.png\" />\n\n@ref:[Documentation](./kubernetes.md)\n@@@\n\n@@@div { .plugin .platform } \n## AWS Elastic Beanstalk\n\nRun Otoroshi on AWS Elastic Beanstalk\n\n<img src=\"../imgs/elastic-beanstalk.png\" />\n\n@ref:[Tutorial](./aws.md)\n@@@\n\n@@@div { .plugin .platform } \n## Amazon ECS\n\nDeploy the Otoroshi Docker image using Amazon Elastic Container Service\n\n<img src=\"../imgs/amazon-ecs.png\" />\n\n@link:[Tutorial](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html)\n@ref:[Docker image](../install/get-otoroshi.md#from-docker)\n\n@@@\n\n@@@div { .plugin .platform }\n## GCE\n\nDeploy the Docker image using Google Compute Engine container integration\n\n<img src=\"../imgs/google.jpeg\" />\n\n@link:[Documentation](https://cloud.google.com/compute/docs/containers/deploying-containers)\n@ref:[Docker image](../install/get-otoroshi.md#from-docker)\n\n@@@\n\n@@@div { .plugin .platform } \n## Azure\n\nDeploy the Docker image using Azure Container Service\n\n<img src=\"../imgs/azure-container-service.png\" />\n\n@link:[Documentation](https://azure.microsoft.com/en-us/services/container-service/)\n@ref:[Docker image](../install/get-otoroshi.md#from-docker) \n@@@\n\n@@@div { .plugin .platform } \n## Heroku\n\nDeploy the Docker image using Docker integration\n\n<img src=\"../imgs/heroku.png\" />\n\n@link:[Documentation](https://devcenter.heroku.com/articles/container-registry-and-runtime)\n@ref:[Docker image](../install/get-otoroshi.md#from-docker)\n@@@\n\n@@@div { .plugin .platform } \n## CloudFoundry\n\nDeploy the Docker image using -Docker integration\n\n<img src=\"../imgs/cloudfoundry.png\" />\n\n@link:[Documentation](https://docs.cloudfoundry.org/adminguide/docker.html)\n@ref:[Docker image](../install/get-otoroshi.md#from-docker)\n@@@\n\n@@@div { .plugin .platform .platform-actions-column } \n## Your own infrastructure\n\nAs Otoroshi is a Play Framework application, you can read the doc about putting a `Play` app in production.\n\nDownload the latest Otoroshi distribution, unzip it, customize it and run it.\n\n@link:[Play Framework](https://www.playframework.com)\n@link:[Production Configuration](https://www.playframework.com/documentation/2.6.x/ProductionConfiguration)\n@ref:[Otoroshi distribution](../install/get-otoroshi.md#from-zip)\n@@@\n\n@@@div { .break }\n## Scaling and clustering in production\n@@@\n\n\n@@@div { .plugin .platform .dark-platform } \n## Clustering\n\nDeploy Otoroshi as a cluster of leaders and workers.\n\n<img src=\"../imgs/clustering.png\" />\n@ref:[Documentation](./clustering.md)\n@@@\n\n@@@div { .plugin .platform .dark-platform } \n## Scaling Otoroshi\n\nOtoroshi is designed to be reasonably easy to scale and be highly available.\n\n<img src=\"../imgs/scaling.png\" />\n@ref:[Documentation](./scaling.md) \n@@@\n\n@@@ index\n\n* [Clustering](./clustering.md)\n* [Kubernetes](./kubernetes.md)\n* [Clever Cloud](./clever-cloud.md)\n* [AWS - Elastic Beanstalk](./aws.md)\n* [Scaling](./scaling.md)  \n\n@@@\n"
  },
  {
    "name": "kubernetes.md",
    "id": "/deploy/kubernetes.md",
    "url": "/deploy/kubernetes.html",
    "title": "Kubernetes",
    "content": "# Kubernetes\n\nStarting at version 1.5.0, Otoroshi provides a native Kubernetes support. Multiple otoroshi jobs (that are actually kubernetes controllers) are provided in order to\n\n- sync kubernetes secrets of type `kubernetes.io/tls` to otoroshi certificates\n- act as a standard ingress controller (supporting `Ingress` objects)\n- provide Custom Resource Definitions (CRDs) to manage Otoroshi entities from Kubernetes and act as an ingress controller with its own resources\n\n## Installing otoroshi on your kubernetes cluster\n\n@@@ warning\nYou need to have cluster admin privileges to install otoroshi and its service account, role mapping and CRDs on a kubernetes cluster. We also advise you to create a dedicated namespace (you can name it `otoroshi` for example) to install otoroshi\n@@@\n\nIf you want to deploy otoroshi into your kubernetes cluster, you can download the deployment descriptors from https://github.com/MAIF/otoroshi/tree/master/kubernetes and use kustomize to create your own overlay.\n\nYou can also create a `kustomization.yaml` file with a remote base\n\n```yaml\nbases:\n- github.com/MAIF/otoroshi/kubernetes/kustomize/overlays/simple/?ref=v1.5.0-dev\n```\n\nThen deploy it with `kubectl apply -k ./overlays/myoverlay`. \n\nYou can also use Helm to deploy a simple otoroshi cluster on your kubernetes cluster\n\n```sh\nhelm repo add otoroshi https://maif.github.io/otoroshi/helm\nhelm install my-otoroshi otoroshi/otoroshi\n```\n\nBelow, you will find example of deployment. Do not hesitate to adapt them to your needs. Those descriptors have value placeholders that you will need to replace with actual values like \n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: ${domain}\n```\n\nyou will have to edit it to make it look like\n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: 'apis.my.domain'\n```\n\nif you don't want to use placeholders and environment variables, you can create a secret containing the configuration file of otoroshi\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: otoroshi-config\ntype: Opaque\nstringData:\n  oto.conf: >\n    include \"application.conf\"\n    app {\n      storage = \"redis\"\n      domain = \"apis.my.domain\"\n    }\n```\n\nand mount it in the otoroshi container\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: otoroshi-deployment\nspec:\n  selector:\n    matchLabels:\n      run: otoroshi-deployment\n  template:\n    metadata:\n      labels:\n        run: otoroshi-deployment\n    spec:\n      serviceAccountName: otoroshi-admin-user\n      terminationGracePeriodSeconds: 60\n      hostNetwork: false\n      containers:\n      - image: maif/otoroshi:1.5.0-dev-jdk11\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        args: ['-Dconfig.file=/usr/app/otoroshi/conf/oto.conf']\n        ports:\n          - containerPort: 8080\n            name: \"http\"\n            protocol: TCP\n          - containerPort: 8443\n            name: \"https\"\n            protocol: TCP\n        volumeMounts:\n        - name: otoroshi-config\n          mountPath: \"/usr/app/otoroshi/conf\"\n          readOnly: true\n      volumes:\n      - name: otoroshi-config\n        secret:\n          secretName: otoroshi-config\n        ...\n```\n\nYou can also create several secrets for each placeholder, mount them to the otoroshi container then use their file path as value\n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: 'file:///the/path/of/the/secret/file'\n```\n\nyou can use the same trick in the config. file itself\n\n### Note on bare metal kubernetes cluster installation\n\n@@@ note\nBare metal kubernetes clusters don't come with support for external loadbalancers (service of type `LoadBalancer`). So you will have to provide this feature in order to route external TCP traffic to Otoroshi containers running inside the kubernetes cluster. You can use projects like [MetalLB](https://metallb.universe.tf/) that provide software `LoadBalancer` services to bare metal clusters or you can use and customize examples below.\n@@@\n\n@@@ warning\nWe don't recommand running Otoroshi behind an existing ingress controller (or something like that) as you will not be able to use features like TCP proxying, TLS, mTLS, etc. Also, this additional layer of reverse proxy will increase call latencies.\n@@@\n\n### Common manifests\n\nthe following manifests are always needed. They create otoroshi CRDs, tokens, role, etc. Redis deployment is not mandatory, it's just an example. You can use your own existing setup.\n\nrbac.yaml\n:   @@snip [rbac.yaml](../snippets/kubernetes/kustomize/base/rbac.yaml) \n\ncrds.yaml\n:   @@snip [crds.yaml](../snippets/kubernetes/kustomize/base/crds.yaml) \n\nredis.yaml\n:   @@snip [redis.yaml](../snippets/kubernetes/kustomize/base/redis.yaml) \n\n\n### Deploy a simple otoroshi instanciation on a cloud provider managed kubernetes cluster\n\nHere we have 2 replicas connected to the same redis instance. Nothing fancy. We use a service of type `LoadBalancer` to expose otoroshi to the rest of the world. You have to setup your DNS to bind otoroshi domain names to the `LoadBalancer` external `CNAME` (see the example below)\n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple/deployment.yaml) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple/dns.example) \n\n### Deploy a simple otoroshi instanciation on a bare metal kubernetes cluster\n\nHere we have 2 replicas connected to the same redis instance. Nothing fancy. The otoroshi instance are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple-baremetal/deployment.yaml) \n\nhaproxy.example\n:   @@snip [haproxy.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/haproxy.example) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/dns.example) \n\n\n### Deploy a simple otoroshi instanciation on a bare metal kubernetes cluster using a DaemonSet\n\nHere we have one otoroshi instance on each kubernetes node (with the `otoroshi-kind: instance` label) with redis persistance. The otoroshi instances are exposed as `hostPort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/deployment.yaml) \n\nhaproxy.example\n:   @@snip [haproxy.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/haproxy.example) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/dns.example) \n\n### Deploy an otoroshi cluster on a cloud provider managed kubernetes cluster\n\nHere we have 2 replicas of an otoroshi leader connected to a redis instance and 2 replicas of an otoroshi worker connected to the leader. We use a service of type `LoadBalancer` to expose otoroshi leader/worker to the rest of the world. You have to setup your DNS to bind otoroshi domain names to the `LoadBalancer` external `CNAME` (see the example below)\n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster/deployment.yaml) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster/dns.example) \n\n### Deploy an otoroshi cluster on a bare metal kubernetes cluster\n\nHere we have 2 replicas of otoroshi leader connected to the same redis instance and 2 replicas for otoroshi worker. The otoroshi instances are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/deployment.yaml) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/dns.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/dns.example) \n\n### Deploy an otoroshi cluster on a bare metal kubernetes cluster using DaemonSet\n\nHere we have 1 otoroshi leader instance on each kubernetes node (with the `otoroshi-kind: leader` label) connected to the same redis instance and 1 otoroshi worker instance on each kubernetes node (with the `otoroshi-kind: worker` label). The otoroshi instances are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/deployment.yaml) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/dns.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/dns.example) \n\n## Using Otoroshi as an Ingress Controller\n\nIf you want to use Otoroshi as an [Ingress Controller](https://kubernetes.io/fr/docs/concepts/services-networking/ingress/), just go to the danger zone, and in `Global scripts` add the job named `Kubernetes Ingress Controller`.\n\nThen add the following configuration for the job (with your own tweaks of course)\n\n```json\n{\n  \"KubernetesConfig\": {\n    \"enabled\": true,\n    \"endpoint\": \"https://127.0.0.1:6443\",\n    \"token\": \"eyJhbGciOiJSUzI....F463SrpOehQRaQ\",\n    \"namespaces\": [\n      \"*\"\n    ]\n  }\n}\n```\n\nthe configuration can have the following values \n\n```javascript\n{\n  \"KubernetesConfig\": {\n    \"endpoint\": \"https://127.0.0.1:6443\", // the endpoint to talk to the kubernetes api, optional\n    \"token\": \"xxxx\", // the bearer token to talk to the kubernetes api, optional\n    \"userPassword\": \"user:password\", // the user password tuple to talk to the kubernetes api, optional\n    \"caCert\": \"/etc/ca.cert\", // the ca cert file path to talk to the kubernetes api, optional\n    \"trust\": false, // trust any cert to talk to the kubernetes api, optional\n    \"namespaces\": [\"*\"], // the watched namespaces\n    \"labels\": [\"label\"], // the watched namespaces\n    \"ingressClasses\": [\"otoroshi\"], // the watched kubernetes.io/ingress.class annotations, can be *\n    \"defaultGroup\": \"default\", // the group to put services in otoroshi\n    \"ingresses\": true, // sync ingresses\n    \"crds\": false, // sync crds\n    \"kubeLeader\": false, // delegate leader election to kubernetes, to know where the sync job should run\n    \"restartDependantDeployments\": true, // when a secret/cert changes from otoroshi sync, restart dependant deployments\n    \"templates\": { // template for entities that will be merged with kubernetes entities. can be \"default\" to use otoroshi default templates\n      \"service-group\": {},\n      \"service-descriptor\": {},\n      \"apikeys\": {},\n      \"global-config\": {},\n      \"jwt-verifier\": {},\n      \"tcp-service\": {},\n      \"certificate\": {},\n      \"auth-module\": {},\n      \"data-exporter\": {},\n      \"script\": {},\n      \"organization\": {},\n      \"team\": {},\n      \"data-exporter\": {}\n    }\n  }\n}\n```\n\nIf `endpoint` is not defined, Otoroshi will try to get it from `$KUBERNETES_SERVICE_HOST` and `$KUBERNETES_SERVICE_PORT`.\nIf `token` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/token`.\nIf `caCert` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`.\nIf `$KUBECONFIG` is defined, `endpoint`, `token` and `caCert` will be read from the current context of the file referenced by it.\n\nNow you can deploy your first service ;)\n\n### Deploy an ingress route\n\nnow let's say you want to deploy an http service and route to the outside world through otoroshi\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-app-deployment\nspec:\n  selector:\n    matchLabels:\n      run: http-app-deployment\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        run: http-app-deployment\n    spec:\n      containers:\n      - image: kennethreitz/httpbin\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        ports:\n          - containerPort: 80\n            name: \"http\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-app-service\nspec:\n  ports:\n    - port: 8080\n      targetPort: http\n      name: http\n  selector:\n    run: http-app-deployment\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: otoroshi\nspec:\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\nonce deployed, otoroshi will sync with kubernetes and create the corresponding service to route your app. You will be able to access your app with\n\n```sh\ncurl -X GET https://httpapp.foo.bar/get\n```\n\n### Support for Ingress Classes\n\nSince Kubernetes 1.18, you can use `IngressClass` type of manifest to specify which ingress controller you want to use for a deployment (https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#extended-configuration-with-ingress-classes). Otoroshi is fully compatible with this new manifest `kind`. To use it, configure the Ingress job to match your controller\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"ingressClasses\": [\"otoroshi.io/ingress-controller\"],\n    ...\n  }\n}\n```\n\nthen you have to deploy an `IngressClass` to declare Otoroshi as an ingress controller\n\n```yaml\napiVersion: \"networking.k8s.io/v1beta1\"\nkind: \"IngressClass\"\nmetadata:\n  name: \"otoroshi-ingress-controller\"\nspec:\n  controller: \"otoroshi.io/ingress-controller\"\n  parameters:\n    apiGroup: \"proxy.otoroshi.io/v1alpha\"\n    kind: \"IngressParameters\"\n    name: \"otoroshi-ingress-controller\"\n```\n\nand use it in your `Ingress`\n\n```yaml\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\nspec:\n  ingressClassName: otoroshi-ingress-controller\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\n### Use multiple ingress controllers\n\nIt is of course possible to use multiple ingress controller at the same time (https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers) using the annotation `kubernetes.io/ingress.class`. By default, otoroshi reacts to the class `otoroshi`, but you can make it the default ingress controller with the following config\n\n```json\n{\n  \"KubernetesConfig\": {\n    ...\n    \"ingressClass\": \"*\",\n    ...\n  }\n}\n```\n\n### Supported annotations\n\nif you need to customize the service descriptor behind an ingress rule, you can use some annotations. If you need better customisation, just go to the CRDs part. The following annotations are supported :\n\n- `ingress.otoroshi.io/groups`\n- `ingress.otoroshi.io/group`\n- `ingress.otoroshi.io/groupId`\n- `ingress.otoroshi.io/name`\n- `ingress.otoroshi.io/targetsLoadBalancing`\n- `ingress.otoroshi.io/stripPath`\n- `ingress.otoroshi.io/enabled`\n- `ingress.otoroshi.io/userFacing`\n- `ingress.otoroshi.io/privateApp`\n- `ingress.otoroshi.io/forceHttps`\n- `ingress.otoroshi.io/maintenanceMode`\n- `ingress.otoroshi.io/buildMode`\n- `ingress.otoroshi.io/strictlyPrivate`\n- `ingress.otoroshi.io/sendOtoroshiHeadersBack`\n- `ingress.otoroshi.io/readOnly`\n- `ingress.otoroshi.io/xForwardedHeaders`\n- `ingress.otoroshi.io/overrideHost`\n- `ingress.otoroshi.io/allowHttp10`\n- `ingress.otoroshi.io/logAnalyticsOnServer`\n- `ingress.otoroshi.io/useAkkaHttpClient`\n- `ingress.otoroshi.io/useNewWSClient`\n- `ingress.otoroshi.io/tcpUdpTunneling`\n- `ingress.otoroshi.io/detectApiKeySooner`\n- `ingress.otoroshi.io/letsEncrypt`\n- `ingress.otoroshi.io/publicPatterns`\n- `ingress.otoroshi.io/privatePatterns`\n- `ingress.otoroshi.io/additionalHeaders`\n- `ingress.otoroshi.io/additionalHeadersOut`\n- `ingress.otoroshi.io/missingOnlyHeadersIn`\n- `ingress.otoroshi.io/missingOnlyHeadersOut`\n- `ingress.otoroshi.io/removeHeadersIn`\n- `ingress.otoroshi.io/removeHeadersOut`\n- `ingress.otoroshi.io/headersVerification`\n- `ingress.otoroshi.io/matchingHeaders`\n- `ingress.otoroshi.io/ipFiltering.whitelist`\n- `ingress.otoroshi.io/ipFiltering.blacklist`\n- `ingress.otoroshi.io/api.exposeApi`\n- `ingress.otoroshi.io/api.openApiDescriptorUrl`\n- `ingress.otoroshi.io/healthCheck.enabled`\n- `ingress.otoroshi.io/healthCheck.url`\n- `ingress.otoroshi.io/jwtVerifier.ids`\n- `ingress.otoroshi.io/jwtVerifier.enabled`\n- `ingress.otoroshi.io/jwtVerifier.excludedPatterns`\n- `ingress.otoroshi.io/authConfigRef`\n- `ingress.otoroshi.io/redirection.enabled`\n- `ingress.otoroshi.io/redirection.code`\n- `ingress.otoroshi.io/redirection.to`\n- `ingress.otoroshi.io/clientValidatorRef`\n- `ingress.otoroshi.io/transformerRefs`\n- `ingress.otoroshi.io/transformerConfig`\n- `ingress.otoroshi.io/accessValidator.enabled`\n- `ingress.otoroshi.io/accessValidator.excludedPatterns`\n- `ingress.otoroshi.io/accessValidator.refs`\n- `ingress.otoroshi.io/accessValidator.config`\n- `ingress.otoroshi.io/preRouting.enabled`\n- `ingress.otoroshi.io/preRouting.excludedPatterns`\n- `ingress.otoroshi.io/preRouting.refs`\n- `ingress.otoroshi.io/preRouting.config`\n- `ingress.otoroshi.io/issueCert`\n- `ingress.otoroshi.io/issueCertCA`\n- `ingress.otoroshi.io/gzip.enabled`\n- `ingress.otoroshi.io/gzip.excludedPatterns`\n- `ingress.otoroshi.io/gzip.whiteList`\n- `ingress.otoroshi.io/gzip.blackList`\n- `ingress.otoroshi.io/gzip.bufferSize`\n- `ingress.otoroshi.io/gzip.chunkedThreshold`\n- `ingress.otoroshi.io/gzip.compressionLevel`\n- `ingress.otoroshi.io/cors.enabled`\n- `ingress.otoroshi.io/cors.allowOrigin`\n- `ingress.otoroshi.io/cors.exposeHeaders`\n- `ingress.otoroshi.io/cors.allowHeaders`\n- `ingress.otoroshi.io/cors.allowMethods`\n- `ingress.otoroshi.io/cors.excludedPatterns`\n- `ingress.otoroshi.io/cors.maxAge`\n- `ingress.otoroshi.io/cors.allowCredentials`\n- `ingress.otoroshi.io/clientConfig.useCircuitBreaker`\n- `ingress.otoroshi.io/clientConfig.retries`\n- `ingress.otoroshi.io/clientConfig.maxErrors`\n- `ingress.otoroshi.io/clientConfig.retryInitialDelay`\n- `ingress.otoroshi.io/clientConfig.backoffFactor`\n- `ingress.otoroshi.io/clientConfig.connectionTimeout`\n- `ingress.otoroshi.io/clientConfig.idleTimeout`\n- `ingress.otoroshi.io/clientConfig.callAndStreamTimeout`\n- `ingress.otoroshi.io/clientConfig.callTimeout`\n- `ingress.otoroshi.io/clientConfig.globalTimeout`\n- `ingress.otoroshi.io/clientConfig.sampleInterval`\n- `ingress.otoroshi.io/enforceSecureCommunication`\n- `ingress.otoroshi.io/sendInfoToken`\n- `ingress.otoroshi.io/sendStateChallenge`\n- `ingress.otoroshi.io/secComHeaders.claimRequestName`\n- `ingress.otoroshi.io/secComHeaders.stateRequestName`\n- `ingress.otoroshi.io/secComHeaders.stateResponseName`\n- `ingress.otoroshi.io/secComTtl`\n- `ingress.otoroshi.io/secComVersion`\n- `ingress.otoroshi.io/secComInfoTokenVersion`\n- `ingress.otoroshi.io/secComExcludedPatterns`\n- `ingress.otoroshi.io/secComSettings.size`\n- `ingress.otoroshi.io/secComSettings.secret`\n- `ingress.otoroshi.io/secComSettings.base64`\n- `ingress.otoroshi.io/secComUseSameAlgo`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.size`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.secret`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.base64`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.size`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.secret`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.base64`\n- `ingress.otoroshi.io/secComAlgoInfoToken.size`\n- `ingress.otoroshi.io/secComAlgoInfoToken.secret`\n- `ingress.otoroshi.io/secComAlgoInfoToken.base64`\n- `ingress.otoroshi.io/securityExcludedPatterns`\n\nfor more informations about it, just go to https://maif.github.io/otoroshi/swagger-ui/index.html\n\nwith the previous example, the ingress does not define any apikey, so the route is public. If you want to enable apikeys on it, you can deploy the following descriptor\n\n```yaml\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: otoroshi\n    ingress.otoroshi.io/group: http-app-group\n    ingress.otoroshi.io/forceHttps: 'true'\n    ingress.otoroshi.io/sendOtoroshiHeadersBack: 'true'\n    ingress.otoroshi.io/overrideHost: 'true'\n    ingress.otoroshi.io/allowHttp10: 'false'\n    ingress.otoroshi.io/publicPatterns: ''\nspec:\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\nnow you can use an existing apikey in the `http-app-group` to access your app\n\n```sh\ncurl -X GET https://httpapp.foo.bar/get -u existing-apikey-1:secret-1\n```\n\n## Use Otoroshi CRDs for a better/full integration\n\nOtoroshi provides some Custom Resource Definitions for kubernetes in order to manage Otoroshi related entities in kubernetes\n\n- `service-groups`\n- `service-descriptors`\n- `apikeys`\n- `certificates`\n- `global-configs`\n- `jwt-verifiers`\n- `auth-modules`\n- `scripts`\n- `tcp-services`\n- `data-exporters`\n- `admins`\n- `teams`\n- `organizations`\n\nusing CRDs, you will be able to deploy and manager those entities from kubectl or the kubernetes api like\n\n```sh\nsudo kubectl get apikeys --all-namespaces\nsudo kubectl get service-descriptors --all-namespaces\ncurl -X GET \\\n  -H 'Authorization: Bearer eyJhbGciOiJSUzI....F463SrpOehQRaQ' \\\n  -H 'Accept: application/json' -k \\\n  https://127.0.0.1:6443/apis/proxy.otoroshi.io/v1alpha1/apikeys | jq\n```\n\nYou can see this as better `Ingress` resources. Like any `Ingress` resource can define which controller it uses (using the `kubernetes.io/ingress.class` annotation), you can chose another kind of resource instead of `Ingress`. With Otoroshi CRDs you can even define resources like `Certificate`, `Apikey`, `AuthModules`, `JwtVerifier`, etc. It will help you to use all the power of Otoroshi while using the deployment model of kubernetes.\n \n@@@ warning\nwhen using Otoroshi CRDs, Kubernetes becomes the single source of truth for the synced entities. It means that any value in the descriptors deployed will overrides the one in Otoroshi datastore each time it's synced. So be careful if you use the Otoroshi UI or the API, some changes in configuration may be overriden by CRDs sync job.\n@@@\n\n### Resources examples\n\ngroup.yaml\n:   @@snip [group.yaml](../snippets/crds/group.yaml) \n\napikey.yaml\n:   @@snip [apikey.yaml](../snippets/crds/apikey.yaml) \n\nservice-descriptor.yaml\n:   @@snip [service.yaml](../snippets/crds/service-descriptor.yaml) \n\ncertificate.yaml\n:   @@snip [cert.yaml](../snippets/crds/certificate.yaml) \n\njwt.yaml\n:   @@snip [jwt.yaml](../snippets/crds/jwt.yaml) \n\nauth.yaml\n:   @@snip [auth.yaml](../snippets/crds/auth.yaml) \n\norganization.yaml\n:   @@snip [orga.yaml](../snippets/crds/organization.yaml) \n\nteam.yaml\n:   @@snip [team.yaml](../snippets/crds/team.yaml) \n\n\n### Configuration\n\nTo configure it, just go to the danger zone, and in `Global scripts` add the job named `Kubernetes Otoroshi CRDs Controller`. Then add the following configuration for the job (with your own tweak of course)\n\n```json\n{\n  \"KubernetesConfig\": {\n    \"enabled\": true,\n    \"crds\": true,\n    \"endpoint\": \"https://127.0.0.1:6443\",\n    \"token\": \"eyJhbGciOiJSUzI....F463SrpOehQRaQ\",\n    \"namespaces\": [\n      \"*\"\n    ]\n  }\n}\n```\n\nthe configuration can have the following values \n\n```javascript\n{\n  \"KubernetesConfig\": {\n    \"endpoint\": \"https://127.0.0.1:6443\", // the endpoint to talk to the kubernetes api, optional\n    \"token\": \"xxxx\", // the bearer token to talk to the kubernetes api, optional\n    \"userPassword\": \"user:password\", // the user password tuple to talk to the kubernetes api, optional\n    \"caCert\": \"/etc/ca.cert\", // the ca cert file path to talk to the kubernetes api, optional\n    \"trust\": false, // trust any cert to talk to the kubernetes api, optional\n    \"namespaces\": [\"*\"], // the watched namespaces\n    \"labels\": [\"label\"], // the watched namespaces\n    \"ingressClasses\": [\"otoroshi\"], // the watched kubernetes.io/ingress.class annotations, can be *\n    \"defaultGroup\": \"default\", // the group to put services in otoroshi\n    \"ingresses\": false, // sync ingresses\n    \"crds\": true, // sync crds\n    \"kubeLeader\": false, // delegate leader election to kubernetes, to know where the sync job should run\n    \"restartDependantDeployments\": true, // when a secret/cert changes from otoroshi sync, restart dependant deployments\n    \"templates\": { // template for entities that will be merged with kubernetes entities. can be \"default\" to use otoroshi default templates\n      \"service-group\": {},\n      \"service-descriptor\": {},\n      \"apikeys\": {},\n      \"global-config\": {},\n      \"jwt-verifier\": {},\n      \"tcp-service\": {},\n      \"certificate\": {},\n      \"auth-module\": {},\n      \"data-exporter\": {},\n      \"script\": {},\n      \"organization\": {},\n      \"team\": {},\n      \"data-exporter\": {}\n    }\n  }\n}\n```\n\nIf `endpoint` is not defined, Otoroshi will try to get it from `$KUBERNETES_SERVICE_HOST` and `$KUBERNETES_SERVICE_PORT`.\nIf `token` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/token`.\nIf `caCert` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`.\nIf `$KUBECONFIG` is defined, `endpoint`, `token` and `caCert` will be read from the current context of the file referenced by it.\n\nyou can find a more complete example of the configuration object [here](https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/plugins/jobs/kubernetes/config.scala#L134-L163)\n\n### Note about `apikeys` and `certificates` resources\n\nApikeys and Certificates are a little bit different than the other resources. They have ability to be defined without their secret part, but with an export setting so otoroshi will generate the secret parts and export the apikey or the certificate to kubernetes secret. Then any app will be able to mount them as volumes (see the full example below)\n\nIn those resources you can define \n\n```yaml\nexportSecret: true \nsecretName: the-secret-name\n```\n\nand omit `clientSecret` for apikey or `publicKey`, `privateKey` for certificates. For certificate you will have to provide a `csr` for the certificate in order to generate it\n\n```yaml\ncsr:\n  issuer: CN=Otoroshi Root\n  hosts: \n  - httpapp.foo.bar\n  - httpapps.foo.bar\n  key:\n    algo: rsa\n    size: 2048\n  subject: UID=httpapp-front, O=OtoroshiApps\n  client: false\n  ca: false\n  duration: 31536000000\n  signatureAlg: SHA256WithRSAEncryption\n  digestAlg: SHA-256\n```\n\nwhen apikeys are exported as kubernetes secrets, they will have the type `otoroshi.io/apikey-secret` with values `clientId` and `clientSecret`\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: apikey-1\ntype: otoroshi.io/apikey-secret\ndata:\n  clientId: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  clientSecret: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n```\n\nwhen certificates are exported as kubernetes secrets, they will have the type `kubernetes.io/tls` with the standard values `tls.crt` (the full cert chain) and `tls.key` (the private key). For more convenience, they will also have a `cert.crt` value containing the actual certificate without the ca chain and `ca-chain.crt` containing the ca chain without the certificate.\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: certificate-1\ntype: kubernetes.io/tls\ndata:\n  tls.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  tls.key: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  cert.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  ca-chain.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA== \n```\n\n## Full CRD example\n\nthen you can deploy the previous example with better configuration level, and using mtls, apikeys, etc\n\nLet say the app looks like :\n\n```js\nconst fs = require('fs'); \nconst https = require('https'); \n\n// here we read the apikey to access http-app-2 from files mounted from secrets\nconst clientId = fs.readFileSync('/var/run/secrets/kubernetes.io/apikeys/clientId').toString('utf8')\nconst clientSecret = fs.readFileSync('/var/run/secrets/kubernetes.io/apikeys/clientSecret').toString('utf8')\n\nconst backendKey = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/tls.key').toString('utf8')\nconst backendCert = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/cert.crt').toString('utf8')\nconst backendCa = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/ca-chain.crt').toString('utf8')\n\nconst clientKey = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/tls.key').toString('utf8')\nconst clientCert = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/cert.crt').toString('utf8')\nconst clientCa = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/ca-chain.crt').toString('utf8')\n\nfunction callApi2() {\n  return new Promise((success, failure) => {\n    const options = { \n      // using the implicit internal name (*.global.otoroshi.mesh) of the other service descriptor passing through otoroshi\n      hostname: 'http-app-service-descriptor-2.global.otoroshi.mesh',  \n      port: 433, \n      path: '/', \n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Otoroshi-Client-Id': clientId,\n        'Otoroshi-Client-Secret': clientSecret,\n      },\n      cert: clientCert,\n      key: clientKey,\n      ca: clientCa\n    }; \n    let data = '';\n    const req = https.request(options, (res) => { \n      res.on('data', (d) => { \n        data = data + d.toString('utf8');\n      }); \n      res.on('end', () => { \n        success({ body: JSON.parse(data), res });\n      }); \n      res.on('error', (e) => { \n        failure(e);\n      }); \n    }); \n    req.end();\n  })\n}\n\nconst options = { \n  key: backendKey, \n  cert: backendCert, \n  ca: backendCa, \n  // we want mtls behavior\n  requestCert: true, \n  rejectUnauthorized: true\n}; \nhttps.createServer(options, (req, res) => { \n  res.writeHead(200, {'Content-Type': 'application/json'});\n  callApi2().then(resp => {\n    res.write(JSON.stringify{ (\"message\": `Hello to ${req.socket.getPeerCertificate().subject.CN}`, api2: resp.body })); \n  });\n}).listen(433);\n```\n\nthen, the descriptors will be :\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-app-deployment\nspec:\n  selector:\n    matchLabels:\n      run: http-app-deployment\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        run: http-app-deployment\n    spec:\n      containers:\n      - image: foo/http-app\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        ports:\n          - containerPort: 443\n            name: \"https\"\n        volumeMounts:\n        - name: apikey-volume\n          # here you will be able to read apikey from files \n          # - /var/run/secrets/kubernetes.io/apikeys/clientId\n          # - /var/run/secrets/kubernetes.io/apikeys/clientSecret\n          mountPath: \"/var/run/secrets/kubernetes.io/apikeys\"\n          readOnly: true\n        volumeMounts:\n        - name: backend-cert-volume\n          # here you will be able to read app cert from files \n          # - /var/run/secrets/kubernetes.io/certs/backend/tls.crt\n          # - /var/run/secrets/kubernetes.io/certs/backend/tls.key\n          mountPath: \"/var/run/secrets/kubernetes.io/certs/backend\"\n          readOnly: true\n        - name: client-cert-volume\n          # here you will be able to read app cert from files \n          # - /var/run/secrets/kubernetes.io/certs/client/tls.crt\n          # - /var/run/secrets/kubernetes.io/certs/client/tls.key\n          mountPath: \"/var/run/secrets/kubernetes.io/certs/client\"\n          readOnly: true\n      volumes:\n      - name: apikey-volume\n        secret:\n          # here we reference the secret name from apikey http-app-2-apikey-1\n          secretName: secret-2\n      - name: backend-cert-volume\n        secret:\n          # here we reference the secret name from cert http-app-certificate-backend\n          secretName: http-app-certificate-backend-secret\n      - name: client-cert-volume\n        secret:\n          # here we reference the secret name from cert http-app-certificate-client\n          secretName: http-app-certificate-client-secret\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-app-service\nspec:\n  ports:\n    - port: 8443\n      targetPort: https\n      name: https\n  selector:\n    run: http-app-deployment\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ServiceGroup\nmetadata:\n  name: http-app-group\n  annotations:\n    otoroshi.io/id: http-app-group\nspec:\n  description: a group to hold services about the http-app\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-apikey-1\n# this apikey can be used to access the app\nspec:\n  # a secret name secret-1 will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: secret-1\n  authorizedEntities: \n  - group_http-app-group\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-2-apikey-1\n# this apikey can be used to access another app in a different group\nspec:\n  # a secret name secret-1 will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: secret-2\n  authorizedEntities: \n  - group_http-app-2-group\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-frontend\nspec:\n  description: certificate for the http-app on otorshi frontend\n  autoRenew: true\n  csr:\n    issuer: CN=Otoroshi Root\n    hosts: \n    - httpapp.foo.bar\n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-front, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-backend\nspec:\n  description: certificate for the http-app deployed on pods\n  autoRenew: true\n  # a secret name http-app-certificate-backend-secret will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: http-app-certificate-backend-secret\n  csr:\n    issuer: CN=Otoroshi Root\n    hosts: \n    - http-app-service \n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-back, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-client\nspec:\n  description: certificate for the http-app\n  autoRenew: true\n  secretName: http-app-certificate-client-secret\n  csr:\n    issuer: CN=Otoroshi Root\n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-client, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ServiceDescriptor\nmetadata:\n  name: http-app-service-descriptor\nspec:\n  description: the service descriptor for the http app\n  groups: \n  - http-app-group\n  forceHttps: true\n  hosts:\n  - httpapp.foo.bar # hostname exposed oustide of the kubernetes cluster\n  # - http-app-service-descriptor.global.otoroshi.mesh # implicit internal name inside the kubernetes cluster \n  matchingRoot: /\n  targets:\n  - url: https://http-app-service:8443\n    # alternatively, you can use serviceName and servicePort to use pods ip addresses\n    # serviceName: http-app-service\n    # servicePort: https\n    mtlsConfig:\n      # use mtls to contact the backend\n      mtls: true\n      certs: \n        # reference the DN for the client cert\n        - UID=httpapp-client, O=OtoroshiApps\n      trustedCerts: \n        # reference the DN for the CA cert \n        - CN=Otoroshi Root\n  sendOtoroshiHeadersBack: true\n  xForwardedHeaders: true\n  overrideHost: true\n  allowHttp10: false\n  publicPatterns:\n    - /health\n  additionalHeaders:\n    x-foo: bar\n# here you can specify everything supported by otoroshi like jwt-verifiers, auth config, etc ... for more informations about it, just go to https://maif.github.io/otoroshi/swagger-ui/index.html\n```\n\nnow with this descriptor deployed, you can access your app with a command like \n\n```sh\nCLIENT_ID=`kubectl get secret secret-1 -o jsonpath=\"{.data.clientId}\" | base64 --decode`\nCLIENT_SECRET=`kubectl get secret secret-1 -o jsonpath=\"{.data.clientSecret}\" | base64 --decode`\ncurl -X GET https://httpapp.foo.bar/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n## Expose Otoroshi to outside world\n\nIf you deploy Otoroshi on a kubernetes cluster, the Otoroshi service is deployed as a loadbalancer (service type: `LoadBalancer`). You'll need to declare in your DNS settings any name that can be routed by otoroshi going to the loadbalancer endpoint (CNAME or ip addresses) of your kubernetes distribution. If you use a managed kubernetes cluster from a cloud provider, it will work seamlessly as they will provide external loadbalancers out of the box. However, if you use a bare metal kubernetes cluster, id doesn't come with support for external loadbalancers (service of type `LoadBalancer`). So you will have to provide this feature in order to route external TCP traffic to Otoroshi containers running inside the kubernetes cluster. You can use projects like [MetalLB](https://metallb.universe.tf/) that provide software `LoadBalancer` services to bare metal clusters or you can use and customize examples in the installation section.\n\n@@@ warning\nWe don't recommand running Otoroshi behind an existing ingress controller (or something like that) as you will not be able to use features like TCP proxying, TLS, mTLS, etc. Also, this additional layer of reverse proxy will increase call latencies.\n@@@ \n\n## Access a service from inside the k8s cluster\n\n### Using host header overriding\n\nYou can access any service referenced in otoroshi, through otoroshi from inside the kubernetes cluster by using the otoroshi service name (if you use a template based on https://github.com/MAIF/otoroshi/tree/master/kubernetes/base deployed in the otoroshi namespace) and the host header with the service domain like :\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET -H 'Host: httpapp.foo.bar' https://otoroshi-service.otoroshi.svc.cluster.local:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using dedicated services\n\nit's also possible to define services that targets otoroshi deployment (or otoroshi workers deployment) and use then as valid hosts in otoroshi services \n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-awesome-service\nspec:\n  selector:\n    # run: otoroshi-deployment\n    # or in cluster mode\n    run: otoroshi-worker-deployment\n  ports:\n  - port: 8080\n    name: \"http\"\n    targetPort: \"http\"\n  - port: 8443\n    name: \"https\"\n    targetPort: \"https\"\n```\n\nand access it like\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET https://my-awesome-service.my-namspace.svc.cluster.local:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using coredns integration\n\nYou can also enable the coredns integration to simplify the flow. You can use the the following keys in the plugin config :\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"coreDnsIntegration\": true,                // enable coredns integration for intra cluster calls\n    \"kubeSystemNamespace\": \"kube-system\",      // the namespace where coredns is deployed\n    \"corednsConfigMap\": \"coredns\",             // the name of the coredns configmap\n    \"otoroshiServiceName\": \"otoroshi-service\", // the name of the otoroshi service, could be otoroshi-workers-service\n    \"otoroshiNamespace\": \"otoroshi\",           // the namespace where otoroshi is deployed\n    \"clusterDomain\": \"cluster.local\",          // the domain for cluster services\n    ...\n  }\n}\n```\n\notoroshi will patch coredns config at startup then you can call your services like\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET https://my-awesome-service.my-awesome-service-namespace.otoroshi.mesh:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\nBy default, all services created from CRDs service descriptors are exposed as `${service-name}.${service-namespace}.otoroshi.mesh` or `${service-name}.${service-namespace}.svc.otoroshi.local`\n\n### Using coredns with manual patching\n\nyou can also patch the coredns config manually\n\n```sh\nkubectl edit configmaps coredns -n kube-system # or your own custom config map\n```\n\nand change the `Corefile` data to add the following snippet in at the end of the file\n\n```yaml\notoroshi.mesh:53 {\n    errors\n    health\n    ready\n    kubernetes cluster.local in-addr.arpa ip6.arpa {\n        pods insecure\n        upstream\n        fallthrough in-addr.arpa ip6.arpa\n    }\n    rewrite name regex (.*)\\.otoroshi\\.mesh otoroshi-worker-service.otoroshi.svc.cluster.local\n    forward . /etc/resolv.conf\n    cache 30\n    loop\n    reload\n    loadbalance\n}\n```\n\nyou can also define simpler rewrite if it suits you use case better\n\n```\nrewrite name my-service.otoroshi.mesh otoroshi-worker-service.otoroshi.svc.cluster.local\n```\n\ndo not hesitate to change `otoroshi-worker-service.otoroshi` according to your own setup. If otoroshi is not in cluster mode, change it to `otoroshi-service.otoroshi`. If otoroshi is not deployed in the `otoroshi` namespace, change it to `otoroshi-service.the-namespace`, etc.\n\nBy default, all services created from CRDs service descriptors are exposed as `${service-name}.${service-namespace}.otoroshi.mesh`\n\nthen you can call your service like \n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\n\ncurl -X GET https://my-awesome-service.my-awesome-service-namespace.otoroshi.mesh:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using old kube-dns system\n\nif your stuck with an old version of kubernetes, it uses kube-dns that is not supported by otoroshi, so you will have to provide your own coredns deployment and declare it as a stubDomain in the old kube-dns system. \n\nHere is an example of coredns deployment with otoroshi domain config\n\ncoredns.yaml\n:   @@snip [coredns.yaml](../snippets/kubernetes/kustomize/base/coredns.yaml)\n\nthen you can enable the kube-dns integration in the otoroshi kubernetes job\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"kubeDnsOperatorIntegration\": true,                // enable kube-dns integration for intra cluster calls\n    \"kubeDnsOperatorCoreDnsNamespace\": \"otoroshi\",    // namespace where coredns is installed\n    \"kubeDnsOperatorCoreDnsName\": \"otoroshi-dns\",     // name of the coredns service\n    \"kubeDnsOperatorCoreDnsPort\": 5353,               // port of the coredns service\n    ...\n  }\n}\n```\n\n### Using Openshift DNS operator\n\nOpenshift DNS operator does not allow to customize DNS configuration a lot, so you will have to provide your own coredns deployment and declare it as a stub in the Openshift DNS operator. \n\nHere is an example of coredns deployment with otoroshi domain config\n\ncoredns.yaml\n:   @@snip [coredns.yaml](../snippets/kubernetes/kustomize/base/coredns.yaml)\n\nthen you can enable the Openshift DNS operator integration in the otoroshi kubernetes job\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"openshiftDnsOperatorIntegration\": true,                // enable openshift dns operator integration for intra cluster calls\n    \"openshiftDnsOperatorCoreDnsNamespace\": \"otoroshi\",    // namespace where coredns is installed\n    \"openshiftDnsOperatorCoreDnsName\": \"otoroshi-dns\",     // name of the coredns service\n    \"openshiftDnsOperatorCoreDnsPort\": 5353,               // port of the coredns service\n    ...\n  }\n}\n```\n\ndon't forget to update the otoroshi `ClusterRole`\n\n```yaml\n- apiGroups:\n    - operator.openshift.io\n  resources:\n    - dnses\n  verbs:\n    - get\n    - list\n    - watch\n    - update\n```\n\n## CRD validation in kubectl\n\nIn order to get CRD validation before manifest deployments right inside kubectl, you can deploy a validation webhook that will do the trick. Also check that you have `otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookCRDValidator` request sink enabled.\n\nvalidation-webhook.yaml\n:   @@snip [validation-webhook.yaml](../snippets/kubernetes/kustomize/base/validation-webhook.yaml)\n\n## Easier integration with otoroshi-sidecar\n\nOtoroshi can help you to easily use existing services without modifications while gettings all the perks of otoroshi like apikeys, mTLS, exchange protocol, etc. To do so, otoroshi will inject a sidecar container in the pod of your deployment that will handle call coming from otoroshi and going to otoroshi. To enable otoroshi-sidecar, you need to deploy the following admission webhook. Also check that you have `otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookSidecarInjector` request sink enabled.\n\nsidecar-webhook.yaml\n:   @@snip [sidecar-webhook.yaml](../snippets/kubernetes/kustomize/base/sidecar-webhook.yaml)\n\nthen it's quite easy to add the sidecar, just add the following label to your pod `otoroshi.io/sidecar: inject` and some annotations to tell otoroshi what certificates and apikeys to use.\n\n```yaml\nannotations:\n  otoroshi.io/sidecar-apikey: backend-apikey\n  otoroshi.io/sidecar-backend-cert: backend-cert\n  otoroshi.io/sidecar-client-cert: oto-client-cert\n  otoroshi.io/token-secret: secret\n  otoroshi.io/expected-dn: UID=oto-client-cert, O=OtoroshiApps\n```\n\nnow you can just call you otoroshi handled apis from inside your pod like `curl http://my-service.namespace.otoroshi.mesh/api` without passing any apikey or client certificate and the sidecar will handle everything for you. Same thing for call from otoroshi to your pod, everything will be done in mTLS fashion with apikeys and otoroshi exchange protocol\n\nhere is a full example\n\nsidecar.yaml\n:   @@snip [sidecar.yaml](../snippets/kubernetes/kustomize/base/sidecar.yaml)\n\n@@@ warning\nPlease avoid to use port `80` for your pod as it's the default port to access otoroshi from your pod and the call will be redirect to the sidecar via an iptables rule\n@@@\n\n## Daikoku integration\n\nIt is possible to easily integrate daikoku generated apikeys without any human interaction with the actual apikey secret. To do that, create a plan in Daikoku and setup the integration mode to `Automatic`\n\n@@@ div { .centered-img }\n<img src=\"../imgs/kubernetes-daikoku-integration-enabled.png\" />\n@@@\n\nthen when a user subscribe for an apikey, he will only see an integration token\n\n@@@ div { .centered-img }\n<img src=\"../imgs/kubernetes-daikoku-integration-token.png\" />\n@@@\n\nthen just create an ApiKey manifest with this token and your good to go \n\n```yaml\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-2-apikey-3\nspec:\n  exportSecret: true \n  secretName: secret-3\n  daikokuToken: RShQrvINByiuieiaCBwIZfGFgdPu7tIJEN5gdV8N8YeH4RI9ErPYJzkuFyAkZ2xy\n```\n\n"
  },
  {
    "name": "scaling.md",
    "id": "/deploy/scaling.md",
    "url": "/deploy/scaling.html",
    "title": "Scaling Otoroshi",
    "content": "# Scaling Otoroshi\n\n## Using multiple instances with a front load balancer\n\nOtoroshi has been designed to work with multiple instances. If you already have an infrastructure using frontal load balancing, you just have to declare Otoroshi instances as the target of all domain names handled by Otoroshi\n\n## Using master / workers mode of Otoroshi\n\nYou can read everything about it in @ref:[the clustering section](../deploy/clustering.md) of the documentation.\n\n## Using IPVS\n\nYou can use [IPVS](https://en.wikipedia.org/wiki/IP_Virtual_Server) to load balance layer 4 traffic directly from the Linux Kernel to multiple instances of Otoroshi. You can find example of configuration [here](http://www.linuxvirtualserver.org/VS-DRouting.html) \n\n## Using DNS Round Robin\n\nYou can use [DNS round robin technique](https://en.wikipedia.org/wiki/Round-robin_DNS) to declare multiple A records under the domain names handled by Otoroshi.\n\n## Using software L4/L7 load balancers\n\nYou can use software L4 load balancers like NGINX or HAProxy to load balance layer 4 traffic directly from the Linux Kernel to multiple instances of Otoroshi.\n\nNGINX L7\n:   @@snip [nginx-http.conf](../snippets/nginx-http.conf) \n\nNGINX L4\n:   @@snip [nginx-tcp.conf](../snippets/nginx-tcp.conf) \n\nHA Proxy L7\n:   @@snip [haproxy-http.conf](../snippets/haproxy-http.conf) \n\nHA Proxy L4\n:   @@snip [haproxy-tcp.conf](../snippets/haproxy-tcp.conf) \n\n## Using a custom TCP load balancer\n\nYou can also use any other TCP load balancer, from a hardware box to a small js file like\n\ntcp-proxy.js\n:   @@snip [tcp-proxy.js](../snippets/tcp-proxy.js) \n\ntcp-proxy.rs\n:   @@snip [tcp-proxy.rs](../snippets/proxy.rs) \n\n"
  },
  {
    "name": "dev.md",
    "id": "/dev.md",
    "url": "/dev.html",
    "title": "Developing Otoroshi",
    "content": "# Developing Otoroshi\n\nIf you want to play with Otoroshis code, here are some tips\n\n## The tools\n\nYou will need\n\n* git\n* JDK 11\n* SBT 1.3.x\n* Node 13 + yarn 1.x\n\n## Clone the repository\n\n```sh\ngit clone https://github.com/MAIF/otoroshi.git\n```\n\nor fork otoroshi and clone your own repository.\n\n## Run otoroshi in dev mode\n\nto run otoroshi in dev mode, you'll need to run two separate process to serve the javascript UI and the server part.\n\n### Javascript side\n\njust go to `<repo>/otoroshi/javascript` and install the dependencies with\n\n```sh\nyarn install\n# or\nnpm install\n```\n\nthen run the dev server with\n\n```sh\nyarn start\n# or\nnpm run start\n```\n\n### Server side\n\nsetup SBT opts with\n\n```sh\nexport SBT_OPTS=\"-Xmx2G -Xss6M\"\n```\n\nthen just go to `<repo>/otoroshi` and run the sbt console with \n\n```sh\nsbt\n```\n\nthen in the sbt console run the following command\n\n```sh\n~run -Dapp.storage=file -Dapp.liveJs=true -Dhttps.port=9998 -D-Dapp.privateapps.port=9999 -Dapp.adminPassword=password -Dapp.domain=oto.tools -Dplay.server.https.engineProvider=ssl.DynamicSSLEngineProvider -Dapp.events.maxSize=0\n```\n\nyou can now access your otoroshi instance at `http://otoroshi.oto.tools:9999`\n\n## Test otoroshi\n\nto run otoroshi test just go to `<repo>/otoroshi` and run the main test suite with\n\n```sh\nsbt 'testOnly OtoroshiTests'\n```\n\n## Create a release\n\njust go to `<repo>/otoroshi/javascript` and then build the UI\n\n```sh\nyarn install\nyarn build\n```\n\nthen go to `<repo>/otoroshi` and build the otoroshi distribution\n\n```sh\nsbt ';clean;compile;dist;assembly'\n```\n\nthe otoroshi build is waiting for you in `<repo>/otoroshi/target/scala-2.12/otoroshi.jar` or `<repo>/otoroshi/target/universal/otoroshi-1.x.x.zip`\n\n## Build the documentation\n\nfrom the root of your repository run\n\n```sh\nsh ./scripts/doc.sh all\n```\n\nThe documentation is located at `manual/target/paradox/site/main/`\n\n## Format the sources\n\nfrom the root of your repository run\n\n```sh\nsh ./scripts/fmt.sh\n```"
  },
  {
    "name": "apikeys.md",
    "id": "/entities/apikeys.md",
    "url": "/entities/apikeys.html",
    "title": "Apikeys",
    "content": "# Apikeys\n\nAn API key is linked to one or more service group and service descriptor to allow you to access any service descriptor linked or contained in one of the linked service group. You can, of course, create multiple API key for given service groups/service descriptors.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/models-apikey.png\" />\n@@@\n\nYou can found a concrete example @ref:[here](../how-to-s/secure-with-apikey.md)\n\n* `ApiKey Id`: the id is a unique random key that will represent this API key\n* `ApiKey Secret`: the secret is a random key used to validate the API key\n* `ApiKey Name`: a name for the API key, used for debug purposes\n* `ApiKey description`: a useful description for this apikey\n* `Valid until`: auto disable apikey after this date\n* `Enabled`: if the API key is disabled, then any call using this API key will fail\n* `Read only`: if the API key is in read only mode, every request done with this api key will only work for GET, HEAD, OPTIONS verbs\n* `Allow pass by clientid only`: here you allow client to only pass client id in a specific header in order to grant access to the underlying api\n* `Constrained services only`: this apikey can only be used on services using apikey routing constraints\n* `Authorized on`: the groups/services linked to this api key\n\n### Metadata and tags\n\n* `Tags`: tags attached to the api key\n* `Metadata`:metadata attached to the api key\n\n### Automatic secret rotation\n\nAPI can handle automatic secret rotation by themselves. When enabled, the rotation changes the secret every `Rotation every` duration. During the `Grace period` both secret will be usable.\n \n* `Enabled`: enabled automatic apikey secret rotation\n* `Rotation every`: rotate secrets every\n* `Grace period`: period when both secrets can be used\n* `Next client secret`: display the next generated client secret\n\n### Restrictions\n\n* `Enabled`: enable restrictions\n* `Allow last`: Otoroshi will test forbidden and notFound paths before testing allowed paths\n* `Allowed`: allowed paths\n* `Forbidden`: forbidden paths\n* `Not Found`: not found paths\n\n### Call examples\n\n* `Curl Command`: simple request with the api key passed by header\n* `Basic Auth. Header`: authorization Header with the api key as base64 encoded format\n* `Curl Command with Basic Auth. Header`: simple request with api key passed in the Authorization header as base64 format\n\n### Quotas\n\n* `Throttling quota`: the authorized number of calls per second\n* `Daily quota`: the authorized number of calls per day\n* `Monthly quota`: the authorized number of calls per month\n\n@@@ warning\n\nDaily and monthly quotas are based on the following rules :\n\n* daily quota is computed between 00h00:00.000 and 23h59:59.999 of the current day\n* monthly qutoas is computed between the first day of the month at 00h00:00.000 and the last day of the month at 23h59:59.999\n@@@\n\n### Quotas consumption\n\n* `Consumed daily calls`: the number of calls consumed today\n* `Remaining daily calls`: the remaining number of calls for today\n* `Consumed monthly calls`: the number of calls consumed this month\n* `Remaining monthly calls`: the remaining number of calls for this month\n\n"
  },
  {
    "name": "auth-modules.md",
    "id": "/entities/auth-modules.md",
    "url": "/entities/auth-modules.html",
    "title": "Authentication modules",
    "content": "# Authentication modules\n\nThe authentication modules are the resources to manage the the access to Otoroshi UI and to protect a service.\n\nAn authentication module can be as well use on guard to access to the Otoroshi UI as to protect an app.\n\nA `private app` is an Otoroshi service with an authentication module.\n\nThe list of supported authentication are :\n\n* `OAuth 2.0/2.1` : an authorization standard that allows a user to grant limited access to their resources on one site to another site, without having to expose their credentials\n* `OAuth 1.0a` : the original standard for access delegation\n* `In memory` : create users directly in Otoroshi with rights and metadata\n* `LDAP : Lightweight Directory Access Protocol` : connect users using a set of LDAP servers\n* `SAML V2 - Security Assertion Markup Language` : an open-standard, XML-based data format that allows businesses to communicate user authentication and authorization information to partner companies and enterprise applications their employees may use.\n\nAll authentication modules have a unique `id`, a `name` and a `description`.\n\nEach module has also the following fields : \n\n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n* `HttpOnly`: if enabled, the cookie cannot be accessed through client side script, prevent cross-site scripting (XSS) by not revealing the cookie to a third party\n* `Secure`: if enabled, avoid to include cookie in an HTTP Request without secure channel, typically HTTPs.\n* `Session max. age`: duration until the session expired\n\n## OAuth 2.0 / OIDC provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check these tutorials : @ref[Secure an app with keycloak](../how-to-s/secure-app-with-keycloak.md) or @ref[Secure an app with auth0](../how-to-s/secure-app-with-auth0.md)\n\n* `Use cookie`: If your OAuth2 provider does not support query param in redirect uri, you can use cookies instead\n* `Use json payloads`: the access token, sended to retrieve the user info, will be pass in body as JSON. If disabled, it will sended as Map.\n* `Enabled PKCE flow`: This way, a malicious attacker can only intercept the Authorization Code, and they cannot exchange it for a token without the Code Verifier.\n* `Disable wildcard on redirect URIs`: As of OAuth 2.1, query parameters on redirect URIs are no longer allowed\n* `Refresh tokens`: Automatically refresh access token using the refresh token if available\n* `Read profile from token`: if enabled, the user profile will be read from the access token, otherwise the user profile will be retrieved from the user information url\n* `Super admins only`: All logged in users will have super admins rights\n* `Client ID`: a public identifier of your app\n* `Client Secret`: a secret known only to the application and the authorization server\n* `Authorize URL`: used to interact with the resource owner and get the authorization to access the protected resource\n* `Token URL`: used by the application in order to get an access token or a refresh token\n* `Introspection URL`: used to validate access tokens\n* `Userinfo URL`: used to retrieve the profile of the user\n* `Login URL`:  used to redirect user to the login provider page\n* `Logout URL`:  redirect uri used by the identity provider to redirect user after logging out\n* `Callback URL`: redirect uri sended to the identity provider to redirect user after successfully connecting\n* `Access token field name`: field used to search access token in the response body of the token URL call\n* `Scope`: presented scopes to the user in the consent screen. Scopes are space-separated lists of identifiers used to specify what access privileges are being requested\n* `Claims`: asked name/values pairs that contains information about a user.\n* `Name field name`: Retrieve name from token field\n* `Email field name`: Retrieve email from token field\n* `Otoroshi metadata field name`: Retrieve metadata from token field\n* `Otoroshi rights field name`: Retrieve user rights from user profile\n* `Extra metadata`: merged with the user metadata\n* `Data override`: merged with extra metadata when a user connects to a `private app`\n* `Rights override`: useful when you want erase the rights of an user with only specific rights. This field is the last to be applied on the user rights.\n* `Api key metadata field name`: used to extract api key metadata from the OIDC access token \n* `Api key tags field name`: used to extract api key tags from the OIDC access token \n* `Proxy host`: host of proxy behind the identify provider\n* `Proxy port`: port of proxy behind the identify provider\n* `Proxy principal`: user of proxy \n* `Proxy password`: password of proxy\n* `OIDC config url`:  URI of the openid-configuration used to discovery documents. By convention, this URI ends with `.well-known/openid-configuration`\n* `Token verification`: What kind of algorithm you want to use to verify/sign your JWT token with\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Hmac secret`: The Hmac secret\n* `Base64 encoded secret`: Is the secret encoded with base64\n* `Custom TLS Settings`: TLS settings for JWKS fetching\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `Trust all`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with JWKS server\n* `Trusted certificates`: list of trusted certificates received from JWKS server\n\n## OAuth 1.0a provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check this tutorial : @ref[Secure an app with OAuth 1.0a](../how-to-s/secure-with-oauth1-client.md)\n\n* `Http Method`: method used to get request token and the access token \n* `Consumer key`: the identifier portion of the client credentials (equivalent to a username)\n* `Consumer secret`: the identifier portion of the client credentials (equivalent to a password)\n* `Request Token URL`: url to retrieve the request token\n* `Authorize URL`: used to redirect user to the login page\n* `Access token URL`: used to retrieve the access token from the server\n* `Profile URL`: used to get the user profile\n* `Callback URL`: used to redirect user when successfully connecting\n* `Rights override`: override the rights of the connected user. With JSON format, each authenticated user, using email, can be associated to a list of rights on tenants and Otoroshi teams.\n\n## LDAP Authentication provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check this tutorial : @ref[Secure an app with LDAP](../how-to-s/secure-app-with-ldap.md)\n\n* `Basic auth.`: if enabled, user and password will be extract from the `Authorization` header as a Basic authentication. It will skipped the login Otoroshi page \n* `Allow empty password`: LDAP servers configured by default with the possibility to connect without password can be secured by this module to ensure that user provides a password\n* `Super admins only`: All logged in users will have super admins rights\n* `Extract profile`: extract LDAP profile in the Otoroshi user\n* `LDAP Server URL`: list of LDAP servers to join. Otoroshi use this list in sequence and swap to the next server, each time a server breaks in timeout\n* `Search Base`: used to global filter\n* `Users search base`: concat with search base to search users in LDAP\n* `Mapping group filter`: map LDAP groups with Otoroshi rights\n* `Search Filter`: used to filter users. *\\${username}* is replace by the email of the user and compare to the given field\n* `Admin username (bind DN)`: holds the name of the environment property for specifying the identity of the principal for authenticating the caller to the service\n* `Admin password`: holds the name of the environment property for specifying the credentials of the principal for authenticating the caller to the service\n* `Extract profile filters attributes in`: keep only attributes which are matching the regex\n* `Extract profile filters attributes not in`: keep only attributes which are not matching the regex\n* `Name field name`: Retrieve name from LDAP field\n* `Email field name`: Retrieve email from LDAP field\n* `Otoroshi metadata field name`: Retrieve metadata from LDAP field\n* `Extra metadata`: merged with the user metadata\n* `Data override`: merged with extra metadata when a user connects to a `private app`\n* `Additional rights group`: list of virtual groups. A virtual group is composed of a list of users and a list of rights for each teams/organizations.\n* `Rights override`: useful when you want erase the rights of an user with only specific rights. This field is the last to be applied on the user rights.\n\n## In memory provider\n\n* `Basic auth.`: if enabled, user and password will be extract from the `Authorization` header as a Basic authentication. It will skipped the login Otoroshi page \n* `Login with WebAuthn` : enabled logging by WebAuthn\n* `Users`: list of users with *name*, *email* and *metadata*. The default password is *password*. The edit button is useful when you want to change the password of the user. The reset button reinitialize the password. \n* `Users raw`: show the registered users with their profile and their rights. You can edit directly each field, especially the rights of the user.\n\n## SAML v2 provider\n\n* `Single sign on URL`: the Identity Provider Single Sign-On URL\n* `The protocol binding for the login request`: the protocol binding for the login request\n* `Single Logout URL`: a SAML flow that allows the end-user to logout from a single session and be automatically logged out of all related sessions that were established during SSO\n* `The protocol binding for the logout request`: the protocol binding for the logout request\n* `Sign documents`: Should SAML Request be signed by Otoroshi ?\n* `Validate Assertions Signature`: Enable/disable signature validation of SAML assertions\n* `Validate assertions with Otoroshi certificate`: validate assertions with Otoroshi certificate. If disabled, the `Encryption Certificate` and `Encryption Private Key` fields can be used to pass a certificate and a private key to validate assertions.\n* `Encryption Certificate`: certificate used to verify assertions\n* `Encryption Private Key`: privaye key used to verify assertions\n* `Signing Certificate`: certicate used to sign documents\n* `Signing Private Key`: private key to sign documents\n* `Signature al`: the signature algorithm to use to sign documents\n* `Canonicalization Method`: canonicalization method for XML signatures \n* `Encryption KeyPair`: the keypair used to sign/verify assertions\n* `Name ID Format`: SP and IdP usually communicate each other about a subject. That subject should be identified through a NAME-IDentifier, which should be in some format so that It is easy for the other party to identify it based on the Format\n* `Use NameID format as email`: use NameID format as email. If disabled, the email will be search from the attributes\n* `URL issuer`: provide the URL to the IdP's who will issue the security token\n* `Validate Signature`: enable/disable signature validation of SAML responses\n* `Validate Assertions Signature`: should SAML Assertions to be decrypted ?\n* `Validating Certificates`: the certificate in PEM format that must be used to check for signatures.\n\n## Special routes\n\nwhen using private apps with auth. modules, you can access special routes that can help you \n\n```sh \nGET 'http://xxxxxxxx.xxxx.xx/.well-known/otoroshi/logout' # trigger logout for the current auth. module\nGET 'http://xxxxxxxx.xxxx.xx/.well-known/otoroshi/me'     # get the current logged user profile (do not forget to pass cookies)\n```\n\n## Related pages\n* @ref[Secure an app with auth0](../how-to-s/secure-app-with-auth0.md)\n* @ref[Secure an app with keycloak](../how-to-s/secure-app-with-keycloak.md)\n* @ref[Secure an app with LDAP](../how-to-s/secure-app-with-ldap.md)\n* @ref[Secure an app with OAuth 1.0a](../how-to-s/secure-with-oauth1-client.md)"
  },
  {
    "name": "certificates.md",
    "id": "/entities/certificates.md",
    "url": "/entities/certificates.html",
    "title": "Certificates",
    "content": "# Certificates\n\nAll generated and imported certificates are listed in the `https://otoroshi.xxxx/bo/dashboard/certificates` page. All those certificates can be used to serve traffic with TLS, perform mTLS calls, sign and verify JWT tokens.\n\nThe list of available actions are:\n\n* `Add item`: redirects the user on the certificate creation page. It's useful when you already had a certificate (like a pem file) and that you want to load it in Otoroshi.\n* `Let's Encrypt certificate`: asks a certificate matching a given host to Let's encrypt \n* `Create certificate`: issues a certificate with an existing Otoroshi certificate as CA.\n* `Import .p12 file`: loads a p12 file as certificate\n\n## Add item\n\n* `Id`: the generated unique id of the certificate\n* `Name`: the name of the certificate\n* `Description`: the description of the certificate\n* `Auto renew cert.`: certificate will be issued when it will be expired. Only works with a CA from Otoroshi and a known private key\n* `Client cert.`: the certificate generated will be used to identicate a client to a server\n* `Keypair`: the certificate entity will be a pair of public key and private key.\n* `Public key exposed`: if true, the public key will be exposed on `http://otoroshi-api.your-domain/.well-known/jwks.json`\n* `Certificate status`: the current status of the certificate. It can be valid if the certificate is not revoked and not expired, or equal to the reason of the revocation\n* `Certificate full chain`: list of certificates used to authenticate a client or a server\n* `Certificate private key`: the private key of the certificate or nothing if wanted. You can omit it if you want just add a certificte full chain to trust them.\n* `Private key password`: the password to protect the private key\n* `Certificate tags`: the tags attached to the certificate\n* `Certaificate metadata`:  the metadata attached to the certificate\n\n## Let's Encrypt certificate\n\n* `Let's encrypt`: if enabled, the certificate will be generated by Let's Encrypt. If disabled, the user will be redirect to the `Create certificate` page\n* `Host`: the host send to Let's encrypt to issue the certificate\n\n## Create certificate view\n\n* `Issuer`: the CA used to sign your certificate\n* `CA certificate`: if enabled, the certificate will be used as an authority certificate. Once generated, it will be use as CA to sign the new certificates\n* `Let's Encrypt`: redirects to the Let's Encrypt page to request a certificate\n* `Client certificate`: the certificate generated will be used to identicate a client to a server\n* `Include A.I.A`: include authority information access urls in the certificate\n* `Key Type`: the type of the private key\n* `Key Size`: the size of the private key\n* `Signature Algorithm`: the signature algorithm used to sign the certificate\n* `Digest Algorithm`:  the digest algorithm used\n* `Validity`: how much time your certificate will be valid\n* `Subject DN`:  the subject DN of your certificate\n* `Hosts`: the hosts of your certificate\n\n"
  },
  {
    "name": "data-exporters.md",
    "id": "/entities/data-exporters.md",
    "url": "/entities/data-exporters.html",
    "title": "Data exporters",
    "content": "# Data exporters\n\nThe data exporters are the way to export alerts and events from Otoroshi to an external storage.\n\nTo try them, you can folllow @ref[this tutorial](../how-to-s/export-alerts-using-mailgun.md).\n\n## Common fields\n\n* `Type`: the type of event exporter\n* `Enabled`: enabled or not the exporter\n* `Name`: given name to the exporter\n* `Description`: the data exporter description\n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n\nAll exporters are split in three parts. The first and second parts are common and the last are specific by exporter.\n\n* `Filtering and projection` : section to filter the list of sent events and alerts. The projection field allows you to export only certain event fields and reduce the size of exported data. It's composed of `Filtering` and `Projection` fields. To get a full usage of this elements, read @ref:[this section](#matching-and-projections)\n* `Queue details`: set of fields to adjust the workers of the exporter. \n  * `Buffer size`: if elements are pushed onto the queue faster than the source is consumed the overflow will be handled with a strategy specified by the user. Keep in memory the number of events.\n  * `JSON conversion workers`: number of workers used to transform events to JSON format in paralell\n  * `Send workers`: number of workers used to send transformed events\n  * `Group size`: chunk up this stream into groups of elements received within a time window (the time window is the next field)\n  * `Group duration`: waiting time before sending the group of events. If the group size is reached before the group duration, the events will be instantly sent\n  \nFor the last part, the `Exporter configuration` will be detail individually.\n\n## Matching and projections\n\n**Filtering** is used to **include** or **exclude** some kind of events and alerts. For each include and exclude field, you can add a list of key-value. \n\nLet's say we only want to keep Otoroshi alerts\n```json\n{ \"include\": [{ \"@type\": \"AlertEvent\" }] }\n```\n\nOtoroshi provides a list of rules to keep only events with specific values. We will use the following event to illustrate.\n\n```json\n{\n \"foo\": \"bar\",\n \"type\": \"AlertEvent\",\n \"alert\": \"big-alert\",\n \"status\": 200,\n \"codes\": [\"a\", \"b\"],\n \"inner\": {\n   \"foo\": \"bar\",\n   \"bar\": \"foo\"\n }\n}\n```\n\nThe rules apply with the previous example as event.\n\n@@@div { #filtering }\n&nbsp;\n@@@\n\n\n\n**Projection** is a list of fields to export. In the case of an empty list, all the fields of an event will be exported. In other case, **only** the listed fields will be exported.\n\nLet's say we only want to keep Otoroshi alerts and only type, timestamp and id of each exported events\n```json\n{\n \"@type\": true,\n \"@timestamp\": true,\n \"@id\": true\n}\n```\n\nAn other possibility is to **rename** the exported field. This value will be the same but the exported field will have a different name.\n\nLet's say we want to rename all `@id` field with `unique-id` as key\n\n```json\n{ \"@id\": \"unique-id\" }\n```\n\nThe last possiblity is to retrieve a sub-object of an event. Let's say we want to get the name of each exported user of events.\n\n```json\n{ \"user\":{ \"name\": true }}\n```\n\n## Elastic\n\nWith this kind of exporter, every matching event will be sent to an elastic cluster (in batch). It is quite useful and can be used in combination with [elastic read in global config](./global-config.html#analytics-elastic-dashboard-datasource-read-)\n\n* `Cluster URI`: Elastic cluster URI\n* `Index`: Elastic index \n* `Type`: Event type (not needed for elasticsearch above 6.x)\n* `User`: Elastic User (optional)\n* `Password`: Elastic password (optional)\n* `Version`: Elastic version (optional, if none provided it will be fetched from cluster)\n* `Apply template`: Automatically apply index template\n* `Check Connection`: Button to test the configuration. It will displayed a modal with checked point, and if the case of it's successfull, it will displayed the found version of the Elasticsearch and the index used\n* `Manually apply index template`: try to put the elasticsearch template by calling the api of elasticsearch\n* `Show index template`: try to retrieve the current index template presents in elasticsearch\n* `Client side temporal indexes handling`: When enabled, Otoroshi will manage the creation of indexes. When it's disabled, Otoroshi will push in the same index\n* `One index per`: When the previous field is enabled, you can choose the interval of time between the creation of a new index in elasticsearch \n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n\n## Webhook \n\nWith this kind of exporter, every matching event will be sent to a URL (in batch) using a POST method and an JSON array body.\n\n* `Alerts hook URL`: url used to post events\n* `Hook Headers`: headers add to the post request\n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n\n\n## Pulsar \n\nWith this kind of exporter, every matching event will be sent to an [Apache Pulsar topic](https://pulsar.apache.org/)\n\n\n* `Pulsar URI`: URI of the pulsar server\n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n* `Pulsar tenant`: tenant on the pulsar server\n* `Pulsar namespace`:  namespace on the pulsar server\n* `Pulsar topic`: topic on the pulsar server\n\n## Kafka \n\nWith this kind of exporter, every matching event will be sent to an [Apache Kafka topic](https://kafka.apache.org/)\n\n* `Kafka Servers`: the list of servers to contact to connect the Kafka client with the Kafka cluster\n* `Kafka keypass`: the keystore password if you use a keystore/truststore to connect to Kafka cluster\n* `Kafka keystore path`: the keystore path on the server if you use a keystore/truststore to connect to Kafka cluster\n* `Kafka truststore path`: the truststore path on the server if you use a keystore/truststore to connect to Kafka cluster\n* `Custom TLS Settings`: enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n* `Kafka topic`: the topic on which Otoroshi alerts will be sent\n\n## Mailer \n\nWith this kind of exporter, every matching event will be sent in batch as an email (using one of the following email provider)\n\nOtoroshi supports 5 exporters of email type.\n\n### Console\n\nNothing to add. The events will be write on the standard output.\n\n### Generic\n\n* `Mailer url`: URL used to push events\n* `Headers`: headers add to the push requests\n* `Email addresses`: recipients of the emails\n\n### Mailgun\n\n* `EU`: is EU server ? if enabled, *https://api.eu.mailgun.net/* will be used, otherwise, the US URL will be used : *https://api.mailgun.net/*\n* `Mailgun api key`: API key of the mailgun account\n* `Mailgun domain`: domain name of the mailgun account\n* `Email addresses`: recipients of the emails\n\n### Mailjet\n\n* `Public api key`: public key of the mailjet account\n* `Private api key`: private key of the mailjet account\n* `Email addresses`: recipients of the emails\n\n### Sendgrid\n\n* `Sendgrid api key`: api key of the sendgrid account\n* `Email addresses`: recipients of the emails\n\n## File \n\n* `File path`: path where the logs will be write \n* `Max file size`: when size is reached, Otoroshi will create a new file postfixed by the current timestamp\n\n## Console \n\nNothing to add. The events will be write on the standard output.\n\n## Custom \n\nThis type of exporter let you the possibility to write your own exporter with your own rules. To create an exporter, we need to navigate to the plugins page, and to create a new item of type exporter.\n\nWhen it's done, the exporter will be visible in this list.\n\n* `Exporter config.`: the configuration of the custom exporter.\n\n## Metrics \n\nThis plugin is useful to rewrite the metric labels exposed on the `/metrics` endpoint.\n\n* `Labels`: list of metric labels. Each pair contains an existing field name and the new name."
  },
  {
    "name": "global-config.md",
    "id": "/entities/global-config.md",
    "url": "/entities/global-config.html",
    "title": "Global config",
    "content": "# Global config\n\nThe global config, named `Danger zone` in Otoroshi, is the place to configure Otoroshi globally. \n\n> Warning: In this page, the configuration is really sensitive and affect the global behaviour of Otoroshi.\n\n\n### Misc. Settings\n\n\n* `Maintenance mode` : It pass every single service in maintenance mode. If an user calls a service, the maintenance page will be displayed\n* `No OAuth login for BackOffice` : Forces admins to login only with user/password or user/password/u2F device\n* `API Read Only`:Freeze the Otoroshi datastore in read only mode. Only people with access to the actual underlying datastore will be able to disable this.\n* `Auto link default` : When no group is specified on a service, it will be assigned to default one\n* `Use circuit breakers` : Use circuit breaker on all services\n* `Use new http client as the default Http client` : All http calls will use the new http client by default\n* `Enable live metrics` : Enable live metrics in the Otoroshi cluster. Performs a lot of writes in the datastore\n* `Digitus medius` : Use middle finger emoji as a response character for endless HTTP responses.\n* `Limit conc. req.` : Limit the number of concurrent request processed by Otoroshi to a certain amount. Highly recommended for resilience\n* `Use X-Forwarded-* headers for routing` : When evaluating routing of a request, X-Forwarded-* headers will be used if presents\n* `Max conc. req.` : Maximum number of concurrent requests processed by otoroshi.\n* `Max HTTP/1.0 resp. size` : Maximum size of an HTTP/1.0 response in bytes. After this limit, response will be cut and sent as is. The best value here should satisfy (maxConcurrentRequests * maxHttp10ResponseSize) < process.memory for worst case scenario.\n* `Max local events` : Maximum number of events stored.\n* `Lines` : *deprecated* \n\n### IP address filtering settings\n\n* `IP allowed list`: Only IP addresses that will be able to access Otoroshi exposed services\n* `IP blocklist`: IP addresses that will be refused to access Otoroshi exposed services\n* `Endless HTTP Responses`: IP addresses for which each request will return around 128 Gb of 0s\n\n\n### Quotas settings\n\n* `Global throttling`: The max. number of requests allowed per second globally on Otoroshi\n* `Throttling per IP`:The max. number of requests allowed per second per IP address globally on Otoroshi\n\n### Analytics: Elastic dashboard datasource (read)\n\n* `Cluster URI`: Elastic cluster URI\n* `Index`: Elastic index \n* `Type`: Event type (not needed for elasticsearch above 6.x)\n* `User`: Elastic User (optional)\n* `Password`: Elastic password (optional)\n* `Version`: Elastic version (optional, if none provided it will be fetched from cluster)\n* `Apply template`: Automatically apply index template\n* `Check Connection`: Button to test the configuration. It will displayed a modal with checked point, and if the case of it's successfull, it will displayed the found version of the Elasticsearch and the index used\n* `Manually apply index template`: try to put the elasticsearch template by calling the api of elasticsearch\n* `Show index template`: try to retrieve the current index template presents in elasticsearch\n* `Client side temporal indexes handling`: When enabled, Otoroshi will manage the creation of indexes. When it's disabled, Otoroshi will push in the same index\n* `One index per`: When the previous field is enabled, you can choose the interval of time between the creation of a new index in elasticsearch \n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `TrustAll`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with elasticsearch\n* `Trusted certificates`: list of trusted certificates received from elasticsearch\n\n\n### Statsd settings\n\n* `Datadog agent`:The StatsD agent is a Datadog agent\n* `StatsD agent host`:The host on which StatsD agent is listening\n* `StatsD agent port`:The port on which StatsD agent is listening (default is 8125)\n\n\n### Backoffice auth. settings\n\n* `Backoffice auth. config`: the authentication module used in front of Otoroshi. It will be used to connect to Otoroshi on the login page\n\n### Let's encrypt settings\n\n* `Enabled`: when enabled, Otoroshi will have the possiblity to sign certificate from let's encrypt notably in the SSL/TSL Certificates page \n* `Server URL`: ACME endpoint of let's encrypt \n* `Email addresses`: (optional) list of addresses used to order the certificates \n* `Contact URLs`: (optional) list of addresses used to order the certificates \n* `Public Key`: used to ask a certificate to let's encrypt, generated by Otoroshi \n* `Private Key`: used to ask a certificate to let's encrypt, generated by Otoroshi \n\n\n### CleverCloud settings\n\nOnce configured, you can register one clever cloud app of your organization directly as an Otoroshi service.\n\n* `CleverCloud consumer key`: consumer key of your clever cloud OAuth 1.0 app\n* `CleverCloud consumer secret`: consumer secret of your clever cloud OAuth 1.0 app\n* `OAuth Token`: oauth token of your clever cloud OAuth 1.0 app\n* `OAuth Secret`: oauth token secret of your clever cloud OAuth 1.0 app \n* `CleverCloud orga. Id`:id of your clever cloud organization\n\n###  Global scripts\n\nGlobal scripts will be deprecated soon, please use global plugins instead (see the next section)!\n\n###  Global plugins\n\n* `Enabled`: enabled all global plugins\n* `Plugins`: list of added plugins to your instance\n* `Plugin configuration`: each added plugin have a configuration that you can override from this field\n\n###  Proxies\n\nIn this section, you can add a list of proxies for :\n\n* Proxy for alert emails (mailgun)\n* Proxy for alert webhooks\n* Proxy for Clever-Cloud API access\n* Proxy for services access\n* Proxy for auth. access (OAuth, OIDC)\n* Proxy for client validators\n* Proxy for JWKS access\n* Proxy for elastic access\n\nEach proxy has the following fields \n\n* `Proxy host`: host of proxy\n* `Proxy port`: port of proxy\n* `Proxy principal`: user of proxy\n* `Proxy password`: password of proxy\n* `Non proxy host`: IP address that can access the service\n\n###  Quotas alerting settings\n\n* `Enable quotas exceeding alerts`: When apikey quotas is almost exceeded, an alert will be sent \n* `Daily quotas threshold`: The percentage of daily calls before sending alerts\n* `Monthly quotas threshold`: The percentage of monthly calls before sending alerts\n\n###  User-Agent extraction settings\n\n* `User-Agent extraction`: Allow user-agent details extraction. Can have impact on consumed memory.\n\n###  Geolocation extraction settings\n\nExtract an geolocation for each call to Otoroshi.\n\n###  Tls Settings\n\n* `Use random cert.`: Use the first available cert none matches the current domain\n* `Default domain`: When the SNI domain cannot be found, this one will be used to find the matching certificate\n* `Trust JDK CAs (server)`:Trust JDK CAs. The CAs from the JDK CA bundle will be proposed in the certificate request when performing TLS handshake\n* `Trust JDK CAs (trust)`: Trust JDK CAs. The CAs from the JDK CA bundle will be used as trusted CAs when calling HTTPS resources\n* `Trusted CAs (server)`:Select the trusted CAs you want for TLS terminaison. Those CAs only will be proposed in the certificate request when performing TLS handshake\n\n\n###  Auto Generate Certificates\n\n* `Enabled`:Generate certificates on the fly when they not exist\n* `Reply Nicely`:When not allowed domain name, accept connection and display a nice error message\n* `CA`:certificate CA used to generate missing certificate\n* `Allowed domains`:Allowed domains\n* `Not allowed domains`:Allowed domains\n  \n\n###  Global metadata\n\n* `Tags`: tags attached to the global config\n* `Metadata`:metadata attached to the global config\n\n### Actions at the bottom of the page\n\n* `Recover from a full export file`:Load global configuration from a previous export\n* `Full export`: Export with all created entities\n* `Full export (ndjson)`: Export your full state of database to ndjson format\n* `JSON`: Get the global config at JSON format\n* `YAML`:Get the global config at YAML format\n* `Enable Panic Mode`: Log out all users from UI and prevent any changes to the database by setting the admin Otoroshi api to read-only. The only way to exit of this mode is to disable this mode directly in the database."
  },
  {
    "name": "index.md",
    "id": "/entities/index.md",
    "url": "/entities/index.html",
    "title": "",
    "content": "\n# Main entities\n\nIn this section, we will pass through all the main Otoroshi entities. Otoroshi entities are the main items stored in otoroshi datastore that will be used to configure routing, authentication, etc.\n\nAny entity has the following properties\n\n* `location` or `_loc`: the location of the entity (organization and team)\n* `id`: the id of the entity (except for apikeys)\n* `name`: the name of the entity\n* `description`: the description of the entity (optional)\n* `tags`: free tags that you can put on any entity to help you manage it, automate it, etc.\n* `metadata`: free key/value tuples that you can put on any entity to help you manage it, automate it, etc.\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-groups.png\">\n<div>\n<span>Organizations</span>\n<span>This the most high level for grouping resources.</span>\n</div>\n@ref:[View](./organizations.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-groups.png\">\n<div>\n<span>Teams</span>\n<span>Organize your resources by teams</span>\n</div>\n@ref:[View](./teams.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-groups.png\">\n<div>\n<span>Service groups</span>\n<span>Group your services</span>\n</div>\n@ref:[View](./service-groups.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-keys.png\">\n<div>\n<span>JWT verifiers</span>\n<span>Verify and forge token by services.</span>\n</div>\n@ref:[View](./jwt-verifiers.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-keys.png\">\n<div>\n<span>Apikeys</span>\n<span>Add security to your services using apikeys</span>\n</div>\n@ref:[View](./apikeys.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-danger-zone.png\">\n<div>\n<span>Global Config</span>\n<span>The danger zone of Otoroshi</span>\n</div>\n@ref:[View](./global-config.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-services.png\">\n<div>\n<span>Service descriptors</span>\n<span>Proxy your applications with service descriptors</span>\n</div>\n@ref:[View](./service-descriptors.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-services.png\">\n<div>\n<span>TCP services</span>\n<span></span>\n</div>\n@ref:[View](./tcp-services.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-security.png\">\n<div>\n<span>Auth. modules</span>\n<span>Secure the Otoroshi UI and your web apps</span>\n</div>\n@ref:[View](./auth-modules.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-certificates.png\">\n<div>\n<span>Certificates</span>\n<span>Add secure communication between Otoroshi, clients and services</span>\n</div>\n@ref:[View](./certificates.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-plugins.png\">\n<div>\n<span>Data exporters</span>\n<span>Export alerts, events ands logs</span>\n</div>\n@ref:[View](./data-exporters.md)\n@@@\n\n@@@div { .plugin .entities }\n<img src=\"../imgs/entities-groups.png\">\n<div>\n<span>Scripts</span>\n<span></span>\n</div>\n@ref:[View](./scripts.md)\n@@@\n\n@@@ index\n\n* [Organizations](./organizations.md)\n* [Teams](./teams.md)\n* [Global Config](./global-config.md)\n* [Apikeys](./apikeys.md)\n* [Service groups](./service-groups.md)\n* [Service descriptors](./service-descriptors.md)\n* [Auth. modules](./auth-modules.md)\n* [Certificates](./certificates.md)\n* [JWT verifiers](./jwt-verifiers.md)\n* [Data exporters](./data-exporters.md)\n* [Scripts](./scripts.md)\n* [TCP services](./tcp-services.md)\n\n@@@\n"
  },
  {
    "name": "jwt-verifiers.md",
    "id": "/entities/jwt-verifiers.md",
    "url": "/entities/jwt-verifiers.html",
    "title": "JWT verifiers",
    "content": "# JWT verifiers\n\nSometimes, it can be pretty useful to verify Jwt tokens coming from other provider on some services. Otoroshi provides a tool to do that per service.\n\n* `Name`: name of the JWT verifier\n* `Description`: a simple description\n* `Strict`: if not strict, request without JWT token will be allowed to pass. This option is helpful when you want to force the presence of tokens in each request on a specific service \n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n\nEach JWT verifier is configurable in three steps : the `location` where find the token in incoming requests, the `validation` step to check the signature and the presence of claims in tokens, and the last step, named `Strategy`.\n\n## Token location\n\nAn incoming token can be found in three places.\n\n#### In query string\n\n* `Source`: JWT token location in query string\n* `Query param name`: the name of the query param where JWT is located\n\n#### In a header\n\n* `Source`: JWT token location in a header\n* `Header name`: the name of the header where JWT is located\n* `Remove value`: when the token is read, this value will be remove of header value (example: if the header value is *Bearer xxxx*, the *remove value* could be Bearer&nbsp; don't forget the space at the end of the string)\n\n#### In a cookie\n\n* `Source`: JWT token location in a cookie\n* `Cookie name`: the name of the cookie where JWT is located\n\n## Token validation\n\nThis section is used to verify the extracted token from specified location.\n\n* `Algo.`: What kind of algorithm you want to use to verify/sign your JWT token with\n\nAccording to the selected algorithm, the validation form will change.\n\n#### Hmac + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Hmac secret`: used to verify the token\n* `Base64 encoded secret`: if enabled, the extracted token will be base64 decoded before it is verifier\n\n#### RSASSA-PKCS1 + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Public key`: the RSA public key\n* `Private key`: the RSA private key that can be empty if not used for JWT token signing\n\n#### ECDSA + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Public key`: the ECDSA public key\n* `Private key`: the ECDSA private key that can be empty if not used for JWT token signing\n\n#### RSASSA-PKCS1 + SHA from KeyPair\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `KeyPair`: used to sign/verify token. The displayed list represents the key pair registered in the Certificates page\n  \n#### ECDSA + SHA from KeyPair\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `KeyPair`: used to sign/verify token. The displayed list represents the key pair registered in the Certificates page\n\n#### Otoroshi KeyPair from token kid (only for verification)\n* `Use only exposed keypairs`: if enabled, Otoroshi will only use the key pairs that are exposed on the well-known. If disabled, it will search on any registered key pairs.\n\n#### JWK Set (only for verification)\n\n* `URL`: the JWK set URL where the public keys are exposed\n* `HTTP call timeout`: timeout for fetching the keyset\n* `TTL`: cache TTL for the keyset\n* `HTTP Headers`: the HTTP headers passed\n* `Key type`: type of the key searched in the jwks\n\n*TLS settings for JWKS fetching*\n\n* `Custom TLS Settings`: TLS settings for JWKS fetching\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `Trust all`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with JWKS server\n* `Trusted certificates`: list of trusted certificates received from JWKS server\n\n*Proxy*\n\n* `Proxy host`: host of proxy behind the identify provider\n* `Proxy port`: port of proxy behind the identify provider\n* `Proxy principal`: user of proxy \n* `Proxy password`: password of proxy\n\n## Strategy\n\nThe first step is to select the verifier strategy. Otoroshi supports 4 types of JWT verifiers:\n\n* `Default JWT token` will add a token if no present. \n* `Verify JWT token` will only verifiy token signing and fields values if provided. \n* `Verify and re-sign JWT token` will verify the token and will re-sign the JWT token with the provided algo. settings. \n* `Verify, re-sign and transform JWT token` will verify the token, re-sign and will be able to transform the token.\n\nAll verifiers has the following properties: \n\n* `Verify token fields`: when the JWT token is checked, each field specified here will be verified with the provided value\n* `Verify token array value`: when the JWT token is checked, each field specified here will be verified if the provided value is contained in the array\n\n\n#### Default JWT token\n\n* `Strict`: if token is already present, the call will fail\n* `Default value`: list of claims of the generated token. These fields support raw values or language expressions. See the documentation about @ref:[the expression language](../topics/expression-language.md)\n\n#### Verify JWT token\n\nNo specific values needed. This kind of verifier needs only the two fields `Verify token fields` and `Verify token array value`.\n\n#### Verify and re-sign JWT token\n\nWhen `Verify and re-sign JWT token` is chosen, the `Re-sign settings` appear. All fields of `Re-sign settings` are the same of the `Token validation` section. The only difference is that the values are used to sign the new token and not to validate the token.\n\n\n#### Verify, re-sign and transform JWT token\n\nWhen `Verify, re-sign and transform JWT token` is chosen, the `Re-sign settings` and `Transformation settings` appear.\n\nThe `Re-sign settings` are used to sign the new token and has the same fields than the `Token validation` section.\n\nFor the `Transformation settings` section, the fields are:\n\n* `Token location`: the location where to find/set the JWT token\n* `Header name`: the name of the header where JWT is located\n* `Prepend value`: remove a value inside the header value\n* `Rename token fields`: when the JWT token is transformed, it is possible to change a field name, just specify origin field name and target field name\n* `Set token fields`: when the JWT token is transformed, it is possible to add new field with static values, just specify field name and value\n* `Remove token fields`: when the JWT token is transformed, it is possible to remove fields"
  },
  {
    "name": "organizations.md",
    "id": "/entities/organizations.md",
    "url": "/entities/organizations.html",
    "title": "Organizations",
    "content": "# Organizations\n\nThe resources of Otoroshi are grouped by `Organization`. This the most high level for grouping resources.\n\nAn organization have a unique `id`, a `name` and a `description`. As all Otoroshi resources, an Organization have a list of tags and metadata associated.\n\nFor example, you can use the organizations as a mean of :\n\n* to seperate resources by services or entities in your enterprise\n* to split internal and external usage of the resources (it's useful when you have a list of services deployed in your company and another one deployed by your partners)\n\n@@@ div { .centered-img }\n<img src=\"../imgs/organizations-and-teams.png\" />\n@@@\n\n## Access to the list of organizations\n\nTo visualize and edit the list of organizations, you can navigate to your instance on the `https://otoroshi.xxxxxx/bo/dashboard/organizations` route or click on the cog icon and select the organizations button.\n\nOnce on the page, you can create a new item, edit an existing organization or delete an existing one.\n\n> When an organization is deleted, the resources associated are not deleted. On the other hand, the organization and the team of associated resources are let empty.\n\n## Entities location\n\nAny otoroshi entity has a location property (`_loc` when serialized to json) explaining where and by whom the entity can be seen. \n\nAn entity can be part of one organization (`tenant` in the json document)\n\n```javascript\n{\n  \"_loc\": {\n    \"tenant\": \"tenant-1\",\n    \"teams\": ...\n  }\n  ...\n}\n```\n\nor all organizations\n\n```javascript\n{\n  \"_loc\": {\n    \"tenant\": \"*\",\n    \"teams\": ...\n  }\n  ...\n}\n```\n\n"
  },
  {
    "name": "scripts.md",
    "id": "/entities/scripts.md",
    "url": "/entities/scripts.html",
    "title": "Scripts",
    "content": "# Scripts\n\nScript are a way to create plugins for otoroshi without deploying them as jar files. With scripts, you just have to store the scala code of your plugins inside the otoroshi datastore and otoroshi will compile and deploy them at startup. You can find all your scripts in the UI at `cog icon / Plugins`. You can find all the documentation about plugins @ref:[here](../plugins/index.md)\n\n@@@ warning\nThe compilation of your plugins can be pretty long and resources consuming. As the compilation happens during otoroshi boot sequence, your instance will be blocked until all plugins have compiled. This behavior can be disabled. If so, the plugins will not work until they have been compiled. Any service using a plugin that is not compiled yet will fail\n@@@\n\nLike any entity, the script has has the following properties\n\n* `id`\n* `plugin name`\n* `plugin description`\n* `tags`\n* `metadata`\n\nAnd you also have\n\n* `type`: the kind of plugin you are building with this script\n* `plugin code`: the code for your plugin\n\n## Compile\n\nYou can use the compile button to check if the code you write in `plugin code` is valid. It will automatically save your script and try to compile. As mentionned earlier, script compilation is quite resource intensive. It will affect your CPU load and your memory consumption. Don't forget to adjust your VM settings accordingly.\n"
  },
  {
    "name": "service-descriptors.md",
    "id": "/entities/service-descriptors.md",
    "url": "/entities/service-descriptors.html",
    "title": "Service descriptors",
    "content": "# Service descriptors\n\nServices or service descriptor, let you declare how to proxy a call from a domain name to another domain name (or multiple domain names). \n\n@@@ div { .centered-img }\n<img src=\"../imgs/models-service.png\" />\n@@@\n\nLets say you have an API exposed on http://192.168.0.42 and I want to expose it on https://my.api.foo. Otoroshi will proxy all calls to https://my.api.foo and forward them to http://192.168.0.42. While doing that, it will also log everyhting, control accesses, etc.\n\n\n* `Id`: a unique random string to identify your service\n* `Groups`: each service descriptor is attached to a group. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group.\n* `Create a new group`: you can create a new group to host this descriptor\n* `Create dedicated group`: you can create a new group with an auto generated name to host this descriptor\n* `Name`: the name of your service. Only for debug and human readability purposes.\n* `Description`: the description of your service. Only for debug and human readability purposes.\n* `Service enabled`: activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist.\n* `Read only mode`: authorize only GET, HEAD, OPTIONS calls on this service\n* `Maintenance mode`: display a maintainance page when a user try to use the service\n* `Construction mode`: display a construction page when a user try to use the service\n* `Log analytics`: Log analytics events for this service on the servers\n* `Use new http client`: will use Akka Http Client for every request\n* `Detect apikey asap`: If the service is public and you provide an apikey, otoroshi will detect it and validate it. Of course this setting may impact performances because of useless apikey lookups.\n* `Send Otoroshi headers back`: when enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...\n* `Override Host header`: when enabled, Otoroshi will automatically set the Host header to corresponding target host\n* `Send X-Forwarded-* headers`: when enabled, Otoroshi will send X-Forwarded-* headers to target\n* `Force HTTPS`: will force redirection to https:// if not present\n* `Allow HTTP/1.0 requests`: will return an error on HTTP/1.0 request\n* `Use new WebSocket client`: will use the new websocket client for every websocket request\n* `TCP/UDP tunneling`: with this setting enabled, otoroshi will not proxy http requests anymore but instead will create a secured tunnel between a cli on your machine and otoroshi to proxy any tcp connection with all otoroshi security features enabled\n\n### Service exposition settings\n\n* `Exposed domain`: the domain used to expose your service. Should follow pattern: (http|https)://subdomain?.env?.domain.tld?/root? or regex (http|https):\\/\\/(.*?)\\.?(.*?)\\.?(.*?)\\.?(.*)\\/?(.*)\n* `Legacy domain`: use 'domain', 'subdomain', 'env' and 'matchingRoot' for routing in addition to hosts, or just use hosts.\n* `Strip path`: when matching, strip the matching prefix from the upstream request URL. Defaults to true\n* `Issue Let's Encrypt cert.`: automatically issue and renew let's encrypt certificate based on domain name. Only if Let's Encrypt enabled in global config.\n* `Issue certificate`: automatically issue and renew a certificate based on domain name\n* `Possible hostnames`: all the possible hostnames for your service\n* `Possible matching paths`: all the possible matching paths for your service\n\n### Redirection\n\n* `Redirection enabled`: enabled the redirection. If enabled, a call to that service will redirect to the chosen URL\n* `Http redirection code`: type of redirection used\n* `Redirect to`: URL used to redirect user when the service is called\n\n### Service targets\n\n* `Redirect to local`: if you work locally with Otoroshi, you may want to use that feature to redirect one specific service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests\n* `Load balancing`: the load balancing algorithm used\n* `Targets`: the list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures\n* `Targets root`: Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar\n\n### URL Patterns\n\n* `Make service a 'public ui'`: add a default pattern as public routes\n* `Make service a 'private api'`: add a default pattern as private routes\n* `Public patterns`: by default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'\n* `Private patterns`: if you define a public pattern that is a little bit too much, you can make some of public URL private again\n\n### Restrictions\n\n* `Enabled`: enable restrictions\n* `Allow last`: Otoroshi will test forbidden and notFound paths before testing allowed paths\n* `Allowed`: allowed paths\n* `Forbidden`: forbidden paths\n* `Not Found`: not found paths\n\n### Otoroshi exchange protocol\n\n* `Enabled`: when enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside.\n* `Send challenge`: when disbaled, Otoroshi will not check if target service respond with sent random value.\n* `Send info. token`: when enabled, Otoroshi add an additional header containing current call informations\n* `Challenge token version`: version the otoroshi exchange protocol challenge. This option will be set to V2 in a near future.\n* `Info. token version`: version the otoroshi exchange protocol info token. This option will be set to Latest in a near future.\n* `Tokens TTL`: the number of seconds for tokens (state and info) lifes\n* `State token header name`: the name of the header containing the state token. If not specified, the value will be taken from the configuration (otoroshi.headers.comm.state)\n* `State token response header name`: the name of the header containing the state response token. If not specified, the value will be taken from the configuration (otoroshi.headers.comm.stateresp)\n* `Info token header name`: the name of the header containing the info token. If not specified, the value will be taken from the configuration (otoroshi.headers.comm.claim)\n* `Excluded patterns`: by default, when security is enabled, everything is secured. But sometimes you need to exlude something, so just add regex to matching path you want to exlude.\n* `Use same algo.`: when enabled, all JWT token in this section will use the same signing algorithm. If `use same algo.` is disabled, three more options will be displayed to select an algorithm for each step of the calls :\n    * Otoroshi to backend\n    * Backend to otoroshi\n    * Info. token\n\n* `Algo.`: What kind of algorithm you want to use to verify/sign your JWT token with\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Hmac secret`: used to verify the token\n* `Base64 encoded secret`: if enabled, the extracted token will be base64 decoded before it is verifier\n\n### Authentication\n\n* `Enforce user authentication`: when enabled, user will be allowed to use the service (UI) only if they are registered users of the chosen authentication module.\n* `Auth. config`: authentication module used to protect the service\n* `Create a new auth config.`: navigate to the creation of authentication module page\n* `all auth config.`: navigate to the authentication pages\n\n* `Excluded patterns`: by default, when security is enabled, everything is secured. But sometimes you need to exlude something, so just add regex to matching path you want to exlude.\n* `Strict mode`: strict mode enabled\n\n### Api keys constraints\n\n* `From basic auth.`: you can pass the api key in Authorization header (ie. from 'Authorization: Basic xxx' header)\n* `Allow client id only usage`: you can pass the api key using client id only (ie. from Otoroshi-Token header)\n* `From custom headers`: you can pass the api key using custom headers (ie. Otoroshi-Client-Id and Otoroshi-Client-Secret headers)\n* `From JWT token`: you can pass the api key using a JWT token (ie. from 'Authorization: Bearer xxx' header)\n\n#### Basic auth. Api Key\n\n* `Custom header name`: the name of the header to get Authorization\n* `Custom query param name`: the name of the query param to get Authorization\n\n#### Client ID only Api Key\n\n* `Custom header name`: the name of the header to get the client id\n* `Custom query param name`: the name of the query param to get the client id\n\n#### Custom headers Api Key\n\n* `Custom client id header name`: the name of the header to get the client id\n* `Custom client secret header name`: the name of the header to get the client secret\n\n#### JWT Token Api Key\n\n* `Secret signed`: JWT can be signed by apikey secret using HMAC algo.\n* `Keypair signed`: JWT can be signed by an otoroshi managed keypair using RSA/EC algo.\n* `Include Http request attrs.`: if enabled, you have to put the following fields in the JWT token corresponding to the current http call (httpPath, httpVerb, httpHost)\n* `Max accepted token lifetime`: the maximum number of second accepted as token lifespan\n* `Custom header name`: the name of the header to get the jwt token\n* `Custom query param name`: the name of the query param to get the jwt token\n* `Custom cookie name`: the name of the cookie to get the jwt token\n\n### Routing constraints\n\n* `All Tags in` : have all of the following tags\n* `No Tags in` : not have one of the following tags\n* `One Tag in` : have at least one of the following tags\n* `All Meta. in` : have all of the following metadata entries\n* `No Meta. in` : not have one of the following metadata entries\n* `One Meta. in` : have at least one of the following metadata entries\n* `One Meta key in` : have at least one of the following key in metadata\n* `All Meta key in` : have all of the following keys in metadata\n* `No Meta key in` : not have one of the following keys in metadata\n\n### CORS support\n\n* `Enabled`: if enabled, CORS header will be check for each incoming request\n* `Allow credentials`: if enabled, the credentials will be sent. Credentials are cookies, authorization headers, or TLS client certificates.\n* `Allow origin`: if enabled, it will indicates whether the response can be shared with requesting code from the given\n* `Max age`: response header indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached.\n* `Expose headers`: response header allows a server to indicate which response headers should be made available to scripts running in the browser, in response to a cross-origin request.\n* `Allow headers`: response header is used in response to a preflight request which includes the Access-Control-Request-Headers to indicate which HTTP headers can be used during the actual request.\n* `Allow methods`: response header specifies one or more methods allowed when accessing a resource in response to a preflight request.\n* `Excluded patterns`: by default, when cors is enabled, everything has cors. But sometimes you need to exlude something, so just add regex to matching path you want to exlude.\n\n#### Related documentations\n\n* @link[Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) { open=new }\n* @link[Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) { open=new }\n* @link[Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age) { open=new }\n* @link[Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) { open=new }\n* @link[Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) { open=new }\n\n### JWT tokens verification\n\n* `Verifiers`: list of selected verifiers to apply on the service\n* `Enabled`: if enabled, Otoroshi will enabled each verifier of the previous list\n* `Excluded patterns`: list of routes where the verifiers will not be apply\n\n### Pre Routing\n\nThis part has been deprecated and moved to the plugin section.\n\n### Access validation\nThis part has been deprecated and moved to the plugin section.\n\n### Gzip support\n\n* `Mimetypes allowed list`: gzip only the files that are matching to a format in the list\n* `Mimetypes blocklist`: will not gzip files matching to a format in the list. A possible way is to allowed all format by default by setting a `*` on the `Mimetypes allowed list` and to add the unwanted format in this list.\n* `Compression level`: the compression level where 9 gives us maximum compression but at the slowest speed. The default compression level is 5 and is a good compromise between speed and compression ratio.\n* `Buffer size`: chunking up a stream of bytes into limited size\n* `Chunk threshold`: if the content type of a request reached over the threshold, the response will be chunked\n* `Excluded patterns`: by default, when gzip is enabled, everything has gzip. But sometimes you need to exlude something, so just add regex to matching path you want to exlude.\n\n### Client settings\n\n* `Use circuit breaker`: use a circuit breaker to avoid cascading failure when calling chains of services. Highly recommended !\n* `Cache connections`: use a cache at host connection level to avoid reconnection time\n* `Client attempts`: specify how many times the client will retry to fetch the result of the request after an error before giving up.\n* `Client call timeout`: specify how long each call should last at most in milliseconds.\n* `Client call and stream timeout`: specify how long each call should last at most in milliseconds for handling the request and streaming the response.\n* `Client connection timeout`: specify how long each connection should last at most in milliseconds.\n* `Client idle timeout`: specify how long each connection can stay in idle state at most in milliseconds.\n* `Client global timeout`: specify how long the global call (with retries) should last at most in milliseconds.\n* `C.breaker max errors`: specify how many errors can pass before opening the circuit breaker\n* `C.breaker retry delay`: specify the delay between two retries. Each retry, the delay is multiplied by the backoff factor\n* `C.breaker backoff factor`: specify the factor to multiply the delay for each retry\n* `C.breaker window`: specify the sliding window time for the circuit breaker in milliseconds, after this time, error count will be reseted\n\n#### Custom timeout settings (list)\n\n* `Path`: the path on which the timeout will be active\n* `Client connection timeout`: specify how long each connection should last at most in milliseconds.\n* `Client idle timeout`: specify how long each connection can stay in idle state at most in milliseconds.\n* `Client call and stream timeout`: specify how long each call should last at most in milliseconds for handling the request and streaming the response.\n* `Call timeout`: Specify how long each call should last at most in milliseconds.\n* `Client global timeout`: specify how long the global call (with retries) should last at most in milliseconds.\n\n#### Proxy settings\n\n* `Proxy host`: host of proxy behind the identify provider\n* `Proxy port`: port of proxy behind the identify provider\n* `Proxy principal`: user of proxy \n* `Proxy password`: password of proxy\n\n### HTTP Headers\n\n* `Additional Headers In`: specify headers that will be added to each client request (from Otoroshi to target). Useful to add authentication.\n* `Additional Headers Out`: specify headers that will be added to each client response (from Otoroshi to client).\n* `Missing only Headers In`: specify headers that will be added to each client request (from Otoroshi to target) if not in the original request.\n* `Missing only Headers Out`: specify headers that will be added to each client response (from Otoroshi to client) if not in the original response.\n* `Remove incoming headers`: remove headers in the client request (from client to Otoroshi).\n* `Remove outgoing headers`: remove headers in the client response (from Otoroshi to client).\n* `Security headers`:\n* `Utility headers`:\n* `Matching Headers`: specify headers that MUST be present on client request to route it (pre routing). Useful to implement versioning.\n* `Headers verification`: verify that some headers has a specific value (post routing)\n\n### Additional settings \n\n* `OpenAPI`: specify an open API descriptor. Useful to display the documentation\n* `Tags`: specify tags for the service\n* `Metadata`: specify metadata for the service. Useful for analytics\n* `IP allowed list`: IP address that can access the service\n* `IP blocklist`: IP address that cannot access the service\n\n### Canary mode\n\n* `Enabled`: Canary mode enabled\n* `Traffic split`: Ratio of traffic that will be sent to canary targets. For instance, if traffic is at 0.2, for 10 request, 2 request will go on canary targets and 8 will go on regular targets.\n* `Targets`: The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures\n  * `Target`:\n  * `Targets root`: Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar\n* `Campaign stats`:\n* `Use canary targets as standard targets`:\n\n### Healthcheck settings\n\n* `HealthCheck enabled`: to help failing fast, you can activate healthcheck on a specific URL.\n* `HealthCheck url`: the URL to check. Should return an HTTP 200 response. You can also respond with an 'Opun-Health-Check-Logic-Test-Result' header set to the value of the 'Opun-Health-Check-Logic-Test' request header + 42. to make the healthcheck complete.\n\n### Fault injection\n\n* `User facing app.`: if service is set as user facing, Snow Monkey can be configured to not being allowed to create outage on them.\n* `Chaos enabled`: activate or deactivate chaos setting on this service descriptor.\n\n### Custom errors template\n\n* `40x template`: html template displayed when 40x error occurred\n* `50x template`: html template displayed when 50x error occurred\n* `Build mode template`:  html template displayed when the build mode is enabled\n* `Maintenance mode template`: html template displayed when the maintenance mode is enabled\n* `Custom messages`: override error message one by one\n\n### Request transformation\n\nThis part has been deprecated and moved to the plugin section.\n\n### Plugins\n\n* `Plugins`:\n  \n    * `Inject default config`: injects, if present, the default configuration of a selected plugin in the configuration object\n    * `Documentation`: link to the documentation website of the plugin\n    * `show/hide config. panel`: shows and hides the plugin panel which contains the plugin description and configuration\n* `Excluded patterns`: by default, when plugins are enabled, everything pass in. But sometimes you need to exclude something, so just add regex to matching path you want to exlude.\n* `Configuration`: the configuration of each enabled plugin, split by names and grouped in the same configuration object."
  },
  {
    "name": "service-groups.md",
    "id": "/entities/service-groups.md",
    "url": "/entities/service-groups.html",
    "title": "Service groups",
    "content": "# Service groups\n\nA service group is composed of an unique `id`, a `Group name`, a `Group description`, an `Organization` and a `Team`. As all Otoroshi resources, a service group have a list of tags and metadata associated.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/models-group.png\" />\n@@@\n\nThe first instinctive usage of service group is to group a list of services. \n\nWhen it's done, you can authorize an api key on a specific group. Instead of authorize an api key for each service, you can regroup a list of services together, and give authorization on the group (read the page on the api keys and the usage of the `Authorized on.` field).\n\n## Access to the list of service groups\n\nTo visualize and edit the list of groups, you can navigate to your instance on the `https://otoroshi.xxxxx/bo/dashboard/groups` route or click on the cog icon and select the Service groups button.\n\nOnce on the page, you can create a new item, edit an existing service group or delete an existing one.\n\n> When a service group is deleted, the resources associated are not deleted. On the other hand, the service group of associated resources is let empty.\n\n"
  },
  {
    "name": "tcp-services.md",
    "id": "/entities/tcp-services.md",
    "url": "/entities/tcp-services.html",
    "title": "TCP services",
    "content": "# TCP services\n\nTCP service are special kind of otoroshi services meant to proxy pure TCP connections (ssh, database, http, etc)\n\n## Global information\n\n* `Id`: generated unique identifier\n* `TCP service name`: the name of your TCP service\n* `Enabled`: enable and disable the service\n* `TCP service port`: the listening port\n* `TCP service interface`: network interface listen by the service\n* `Tags`: list of tags associated to the service\n* `Metadata`: list of metadata associated to the service\n\n## TLS\n\nthis section controls the TLS exposition of the service\n\n* `TLS mode`\n    * `Disabled`: no TLS\n    * `PassThrough`: as the target exposes TLS, the call will pass through otoroshi and use target TLS\n    * `Enabled`: the service will be exposed using TLS and will chose certificate based on SNI\n* `Client Auth.`\n    * `None` no mTLS needed to pass\n    * `Want` pass with or without mTLS\n    * `Need` need mTLS to pass\n\n## Server Name Indication (SNI)\n\nthis section control how SNI should be treated\n\n* `SNI routing enabled`: if enabled, the server will use the SNI hostname to determine which certificate to present to the client\n* `Forward to target if no SNI match`: if enabled, a call without any SNI match will be forward to the target\n* `Target host`: host of the target called if no SNI\n* `Target ip address`: ip of the target called if no SNI\n* `Target port`: port of the target called if no SNI\n* `TLS call`: encrypt the communication with TLS\n\n## Rules\n\nfor any listening TCP proxy, it is possible to route to multiple targets based on SNI or extracted http host (if proxying http)\n\n* `Matching domain name`: regex used to filter the list of domains where the rule will be applied\n* `Target host`: host of the target\n* `Target ip address`: ip of the target\n* `Target port`: port of the target\n* `TLS call`: enable this flag if the target is exposed using TLS\n"
  },
  {
    "name": "teams.md",
    "id": "/entities/teams.md",
    "url": "/entities/teams.html",
    "title": "Teams",
    "content": "# Teams\n\nIn Otoroshi, all resources are attached to an `Organization` and a `Team`. \n\nA team is composed of an unique `id`, a `name`, a `description` and an `Organization`. As all Otoroshi resources, a Team have a list of tags and metadata associated.\n\nA team have an unique organization and can be use on multiples resources (services, api keys, etc ...).\n\nA connected user on Otoroshi UI has a list of teams and organizations associated. It can be helpful when you want restrict the rights of a connected user.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/organizations-and-teams.png\" />\n@@@\n\n## Access to the list of teams\n\nTo visualize and edit the list of teams, you can navigate to your instance on the `https://otoroshi.xxxxxx/bo/dashboard/teams` route or click on the cog icon and select the teams button.\n\nOnce on the page, you can create a new item, edit an existing team or delete an existing one.\n\n> When a team is deleted, the resources associated are not deleted. On the other hand, the team of associated resources is let empty.\n\n## Entities location\n\nAny otoroshi entity has a location property (`_loc` when serialized to json) explaining where and by whom the entity can be seen. \n\nAn entity can be part of multiple teams in an organization\n\n```javascript\n{\n  \"_loc\": {\n    \"tenant\": \"tenant-1\",\n    \"teams\": [\n      \"team-1\",\n      \"team-2\"\n    ]\n  }\n  ...\n}\n```\n\nor all teams\n\n```javascript\n{\n  \"_loc\": {\n    \"tenant\": \"tenant-1\",\n    \"teams\": [\n      \"*\"\n    ]\n  }\n  ...\n}\n```"
  },
  {
    "name": "features.md",
    "id": "/features.md",
    "url": "/features.html",
    "title": "Features",
    "content": "# Features\n\nAll the features supported by **Otoroshi** are listed below\n\n**Traffic Management**\n\n* Can proxy any HTTP(s) service (apis, webapps, websocket, etc)\n* Can proxy any TCP service (app, database, etc)\n* Traffic mirroring\n* Canary deployments\n* Multiple load-balancing otpions: RoundRobin, Random, Sticky, Ip Hash, Best Response Time\n* Distributed in-flight request limiting\t\n* Distributed rate limiting \n\n**Services customization**\n\n* Dozens of built-in plugins (circuit breakers, automatic retries, buffering, response compression, headers manipulation, cors, gzip) \n* Custom plugins\n* Private and public visibility\n\n**Services Monitoring**\n\n* Active health checks\n* Calls tracing\n* Export alerts and events to external database\n* Real-time traffic metrics\n* Alert mailers\n* Real-time traffic metrics (Datadog, Prometheus, StatsD)\n\n**API security**\n\n* Access management with apikeys and quotas\n* Automatic apikeys secrets rotation\n* HTTPS and TLS\n* Mutual TLS in/out\n* Routing constraints\n* Routing restrictions\n* JWT tokens validation and manipulation\n\n**Administration UI**\n\n* Manage and organize all resources\n* Secured users access with Authentication module\n* Traced users actions\n* Dynamic changes at runtime without full reload\n\n**Webapp authentication and security**\n\n* OAuth2.0/2.1 authentication\n* OpenID Connect (OIDC) authentication\n* Internal users management\n* LDAP authentication\n* JWT authentication\n* OAuth 1.0a authentication\n* SAML V2 authentication\n\n**Certificates management**\n\n* Dynamic TLS certificates store \n* Dynamic TLS termination\n* Internal PKI\n* ACME / Let's Encrypt support\n* On-the-fly certificate generation based on a CA certificate without request loss\n\n**Performances and testing**\n\n* Chaos engineering\n* Clustering with encrypted communication\n* Scalability\n\n**Kubernetes integration**\n\n* Standard Ingress controller\n* Custom Ingress controller\n    * Manage Otoroshi resources from Kubernetes\n* Validation of resources via webhook\n* Service Mesh for easy service-to-service communication\n\n**Developpers portal**\n\n* Using @link:[Daikoku](https://maif.github.io/daikoku/manual/index.html) { open=new }\n"
  },
  {
    "name": "getting-started.md",
    "id": "/getting-started.md",
    "url": "/getting-started.html",
    "title": "Getting Started",
    "content": "# Getting Started\n\n- [Protect the access to your api with the Otoroshi management of api keys](#protect-the-access-to-your-api-with-the-otoroshi-management-of-api-keys)\n- [Secure your web app in 5 minutes with an authentication](#secure-your-web-app-in-5-minutes-with-an-authentication)\n\nDownload the latest jar of Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nOnce downloading, run Otoroshi.\n```sh\njava -Dapp.adminPassword=password -jar otoroshi.jar \n```\n\n## Protect the access to your api with the Otoroshi management of api keys\n\nCreate a service, exposed on `http://myapi.oto.tools:8080`, which will forward all requests to the mirror `https://mirror.otoroshi.io`.\n\n```sh\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/services \\\n-d '{\"enforceSecureCommunication\": false, \"forceHttps\": false, \"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"groupId\":\"default\",\"groups\":[\"default\"],\"name\":\"myapi\",\"description\":\"a service\",\"env\":\"prod\",\"domain\":\"oto.tools\",\"subdomain\":\"myapi\",\"targetsLoadBalancing\":{\"type\":\"RoundRobin\"},\"targets\":[{\"host\":\"mirror.otoroshi.io\",\"scheme\":\"https\",\"weight\":1,\"mtlsConfig\":{\"certs\":[],\"trustedCerts\":[],\"mtls\":false,\"loose\":false,\"trustAll\":false},\"tags\":[],\"metadata\":{},\"protocol\":\"HTTP\\/1.1\",\"predicate\":{\"type\":\"AlwaysMatch\"},\"ipAddress\":null}],\"root\":\"\\/\",\"matchingRoot\":null,\"stripPath\":true,\"enabled\":true,\"secComHeaders\":{\"claimRequestName\":null,\"stateRequestName\":null,\"stateResponseName\":null},\"publicPatterns\":[\"\"],\"privatePatterns\":[\"\\/.*\"],\"kind\":\"ServiceDescriptor\"}' \\\n-H \"Content-type: application/json\" \\\n-u admin-api-apikey-id:admin-api-apikey-secret\n```\n\nTry to call this service. You should receive an error from Otoroshi about a missing api key in our request.\n\n```sh\ncurl http://myapi.oto.tools:8080\n```\n\nCreate your first api key with a quota of 10 calls by day and month.\n\n```sh\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/apikeys \\\n-H \"Content-type: application/json\" \\\n-u admin-api-apikey-id:admin-api-apikey-secret \\\n-d @- <<'EOF'\n{\n    \"clientId\": \"my-first-apikey-id\",\n    \"clientSecret\": \"my-first-apikey-secret\",\n    \"clientName\": \"my-first-apikey\",\n    \"description\": \"my-first-apikey-description\",\n    \"authorizedGroup\": \"default\",\n    \"enabled\": true,\n    \"throttlingQuota\": 10,\n    \"dailyQuota\": 10,\n    \"monthlyQuota\": 10\n}\nEOF\n```\n\nCall your api with the generated apikey.\n\n```sh\ncurl http://myapi.oto.tools:8080 -u my-first-apikey-id:my-first-apikey-secret\n```\n\n```json\n{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"headers\": {\n    \"host\": \"mirror.otoroshi.io\",\n    \"accept\": \"*/*\",\n    \"user-agent\": \"curl/7.64.1\",\n    \"authorization\": \"Basic bXktZmlyc3QtYXBpLWtleS1pZDpteS1maXJzdC1hcGkta2V5LXNlY3JldA==\",\n    \"otoroshi-request-id\": \"1465298507974836306\",\n    \"otoroshi-proxied-host\": \"myapi.oto.tools:8080\",\n    \"otoroshi-request-timestamp\": \"2021-11-29T13:36:02.888+01:00\",\n  },\n  \"body\": \"\"\n}\n```\n\nCheck your remaining quotas\n\n```sh\ncurl http://myapi.oto.tools:8080 -u my-first-apikey-id:my-first-apikey-secret --include\n```\n\nThis should output these following Otoroshi headers\n\n```json\nOtoroshi-Daily-Calls-Remaining: 6\nOtoroshi-Monthly-Calls-Remaining: 6\n```\n\nKeep calling the api and confirm that Otoroshi is sending you an apikey exceeding quota error\n\n\n```json\n{ \n    \"Otoroshi-Error\": \"You performed too much requests\"\n}\n```\n\nWell done, you have secured your first api with the apikeys system with limited call quotas.\n\n## Secure your web app in 5 minutes with an authentication\n\nCreate an in-memory authentication module, with one registered user, to protect your service.\n\n```sh\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/auths \\\n-H \"Otoroshi-Client-Id: admin-api-apikey-id\" \\\n-H \"Otoroshi-Client-Secret: admin-api-apikey-secret\" \\\n-H 'Content-Type: application/json; charset=utf-8' \\\n-d @- <<'EOF'\n{\n    \"type\":\"basic\",\n    \"id\":\"auth_mod_in_memory_auth\",\n    \"name\":\"in-memory-auth\",\n    \"desc\":\"in-memory-auth\",\n    \"users\":[\n        {\n            \"name\":\"User Otoroshi\",\n            \"password\":\"$2a$10$oIf4JkaOsfiypk5ZK8DKOumiNbb2xHMZUkYkuJyuIqMDYnR/zXj9i\",\n            \"email\":\"user@foo.bar\",\n            \"metadata\":{\n                \"username\":\"roger\"\n            },\n            \"tags\":[\"foo\"],\n            \"webauthn\":null,\n            \"rights\":[{\n                \"tenant\":\"*:r\",\n                \"teams\":[\"*:r\"]\n            }]\n        }\n    ],\n    \"sessionCookieValues\":{\n        \"httpOnly\":true,\n        \"secure\":false\n    }\n}\nEOF\n```\n\nThen create a service secure by the previous authentication module, which proxies `google.fr` on `webapp.oto.tools`.\n\n```sh\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/services \\\n-d '{\"enforceSecureCommunication\": false, \"forceHttps\": false, \"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"groupId\":\"default\",\"groups\":[\"default\"],\"name\":\"webapp\",\"description\":\"a service\",\"env\":\"prod\",\"domain\":\"oto.tools\",\"subdomain\":\"webapp\",\"targetsLoadBalancing\":{\"type\":\"RoundRobin\"},\"targets\":[{\"host\":\"google.fr\",\"scheme\":\"https\",\"weight\":1,\"mtlsConfig\":{\"certs\":[],\"trustedCerts\":[],\"mtls\":false,\"loose\":false,\"trustAll\":false},\"tags\":[],\"metadata\":{},\"protocol\":\"HTTP\\/1.1\",\"predicate\":{\"type\":\"AlwaysMatch\"},\"ipAddress\":null}],\"root\":\"\\/\",\"matchingRoot\":null,\"stripPath\":true,\"enabled\":true,\"secComHeaders\":{\"claimRequestName\":null,\"stateRequestName\":null,\"stateResponseName\":null},\"publicPatterns\":[\"\\/.*\"],\"privatePatterns\":[\"\"],\"kind\":\"ServiceDescriptor\",\"authConfigRef\":\"auth_mod_in_memory_auth\",\"privateApp\":true}' \\\n-H \"Content-type: application/json\" \\\n-u admin-api-apikey-id:admin-api-apikey-secret\n```\n\nNavigate to http://webapp.oto.tools:8080, login with `user@foo.bar/password` and check that you're redirect to `google` page.\n\nWell done! You completed the discovery tutorial."
  },
  {
    "name": "custom-initial-state.md",
    "id": "/how-to-s/custom-initial-state.md",
    "url": "/how-to-s/custom-initial-state.html",
    "title": "Initial state customization",
    "content": "# Initial state customization\n\nwhen you start otoroshi for the first time, some basic entities will be created and stored in the datastore in order to make your instance work properly. However it might not be enough for your use case but you do want to bother with restoring a complete otoroshi export.\n\nIn order to make state customization easy, otoroshi provides the config. key `app.initialCustomization`, overriden by the env. variable `OTOROSHI_INITIAL_CUSTOMIZATION`\n\nThe expected structure is the following :\n\n```javascript\n{\n  \"config\": { ... },\n  \"admins\": [],\n  \"simpleAdmins\": [],\n  \"serviceGroups\": [],\n  \"apiKeys\": [],\n  \"serviceDescriptors\": [],\n  \"errorTemplates\": [],\n  \"jwtVerifiers\": [],\n  \"authConfigs\": [],\n  \"certificates\": [],\n  \"clientValidators\": [],\n  \"scripts\": [],\n  \"tcpServices\": [],\n  \"dataExporters\": [],\n  \"tenants\": [],\n  \"teams\": []\n}\n```\n\nin this structure, everything is optional. For every array property, items will be added to the datastore. For the global config. object, you can just add the parts that you need, and they will be merged with the existing config. object of the datastore.\n\n## Customize the global config.\n\nfor instance, if you want to customize the behavior of the TLS termination, you can use the following :\n\n```sh\nexport OTOROSHI_INITIAL_CUSTOMIZATION='{\"config\":{\"tlsSettings\":{\"defaultDomain\":\"www.foo.bar\",\"randomIfNotFound\":false}}'\n```\n\n## Customize entities\n\nif you want to add apikeys at first boot \n\n```sh\nexport OTOROSHI_INITIAL_CUSTOMIZATION='{\"apikeys\":[{\"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"clientId\":\"ksVlQ2KlZm0CnDfP\",\"clientSecret\":\"usZYbE1iwSsbpKY45W8kdbZySj1M5CWvFXe0sPbZ0glw6JalMsgorDvSBdr2ZVBk\",\"clientName\":\"awesome-apikey\",\"description\":\"the awesome apikey\",\"authorizedGroup\":\"default\",\"authorizedEntities\":[\"group_default\"],\"enabled\":true,\"readOnly\":false,\"allowClientIdOnly\":false,\"throttlingQuota\":10000000,\"dailyQuota\":10000000,\"monthlyQuota\":10000000,\"constrainedServicesOnly\":false,\"restrictions\":{\"enabled\":false,\"allowLast\":true,\"allowed\":[],\"forbidden\":[],\"notFound\":[]},\"rotation\":{\"enabled\":false,\"rotationEvery\":744,\"gracePeriod\":168,\"nextSecret\":null},\"validUntil\":null,\"tags\":[],\"metadata\":{}}]}'\n```\n"
  },
  {
    "name": "custom-log-levels.md",
    "id": "/how-to-s/custom-log-levels.md",
    "url": "/how-to-s/custom-log-levels.html",
    "title": "Log levels customization",
    "content": "# Log levels customization\n\nIf you want to customize the log level of your otoroshi instances, it's pretty easy to do it using environment variables or configuration file.\n\n## Customize log level for one logger with configuration file\n\nLet say you want to see `DEBUG` messages from the logger `otoroshi-http-handler`.\n\nThen you just have to declare in your otoroshi configuration file\n\n```\notoroshi.loggers {\n  ...\n  otoroshi-http-handler = \"DEBUG\"\n  ...\n}\n```\n\npossible levels are `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`. Default one is `WARN`.\n\n## Customize log level for one logger with environment variable\n\nLet say you want to see `DEBUG` messages from the logger `otoroshi-http-handler`.\n\nThen you just have to declare an environment variable named `OTOROSHI_LOGGERS_OTOROSHI_HTTP_HANDLER` with value `DEBUG`. The rule is \n\n```scala\n\"OTOROSHI_LOGGERS_\" + loggerName.toUpperCase().replace(\"-\", \"_\")\n```\n\npossible levels are `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`. Default one is `WARN`.\n\n## List of loggers\n\n* `otoroshi-error-handler`\n* `otoroshi-http-handler`\n* `otoroshi-http-handler-debug`\n* `otoroshi-websocket-handler`\n* `otoroshi-websocket`\n* `otoroshi-websocket-handler-actor`\n* `otoroshi-snowmonkey`\n* `otoroshi-circuit-breaker`\n* `otoroshi-circuit-breaker`\n* `otoroshi-worker`\n* `otoroshi-http-handler`\n* `otoroshi-auth-controller`\n* `otoroshi-swagger-controller`\n* `otoroshi-u2f-controller`\n* `otoroshi-backoffice-api`\n* `otoroshi-health-api`\n* `otoroshi-stats-api`\n* `otoroshi-admin-api`\n* `otoroshi-auth-modules-api`\n* `otoroshi-certificates-api`\n* `otoroshi-pki`\n* `otoroshi-scripts-api`\n* `otoroshi-analytics-api`\n* `otoroshi-import-export-api`\n* `otoroshi-templates-api`\n* `otoroshi-teams-api`\n* `otoroshi-events-api`\n* `otoroshi-canary-api`\n* `otoroshi-data-exporter-api`\n* `otoroshi-services-api`\n* `otoroshi-tcp-service-api`\n* `otoroshi-tenants-api`\n* `otoroshi-global-config-api`\n* `otoroshi-apikeys-fs-api`\n* `otoroshi-apikeys-fg-api`\n* `otoroshi-apikeys-api`\n* `otoroshi-statsd-actor`\n* `otoroshi-snow-monkey-api`\n* `otoroshi-jobs-eventstore-checker`\n* `otoroshi-initials-certs-job`\n* `otoroshi-alert-actor`\n* `otoroshi-alert-actor-supervizer`\n* `otoroshi-alerts`\n* `otoroshi-apikeys-secrets-rotation-job`\n* `otoroshi-loader`\n* `otoroshi-api-action`\n* `otoroshi-api-action`\n* `otoroshi-analytics-writes-elastic`\n* `otoroshi-analytics-reads-elastic`\n* `otoroshi-events-actor-supervizer`\n* `otoroshi-data-exporter`\n* `otoroshi-data-exporter-update-job`\n* `otoroshi-kafka-wrapper`\n* `otoroshi-kafka-connector`\n* `otoroshi-analytics-webhook`\n* `otoroshi-jobs-software-updates`\n* `otoroshi-analytics-actor`\n* `otoroshi-analytics-actor-supervizer`\n* `otoroshi-analytics-event`\n* `otoroshi-env`\n* `otoroshi-script-compiler`\n* `otoroshi-script-manager`\n* `otoroshi-script`\n* `otoroshi-tcp-proxy`\n* `otoroshi-tcp-proxy`\n* `otoroshi-tcp-proxy`\n* `otoroshi-custom-timeouts`\n* `otoroshi-client-config`\n* `otoroshi-canary`\n* `otoroshi-redirection-settings`\n* `otoroshi-service-descriptor`\n* `otoroshi-service-descriptor-datastore`\n* `otoroshi-console-mailer`\n* `otoroshi-mailgun-mailer`\n* `otoroshi-mailjet-mailer`\n* `otoroshi-sendgrid-mailer`\n* `otoroshi-generic-mailer`\n* `otoroshi-clevercloud-client`\n* `otoroshi-metrics`\n* `otoroshi-gzip-config`\n* `otoroshi-regex-pool`\n* `otoroshi-ws-client-chooser`\n* `otoroshi-akka-ws-client`\n* `otoroshi-http-implicits`\n* `otoroshi-service-group`\n* `otoroshi-data-exporter-config`\n* `otoroshi-data-exporter-config-migration-job`\n* `otoroshi-lets-encrypt-helper`\n* `otoroshi-apkikey`\n* `otoroshi-error-template`\n* `otoroshi-job-manager`\n* `otoroshi-plugins-internal-eventlistener-actor`\n* `otoroshi-global-config`\n* `otoroshi-jwks`\n* `otoroshi-jwt-verifier`\n* `otoroshi-global-jwt-verifier`\n* `otoroshi-snowmonkey-config`\n* `otoroshi-webauthn-admin-datastore`\n* `otoroshi-webauthn-admin-datastore`\n* `otoroshi-leveldb-datastores`\n* `otoroshi-service-datatstore`\n* `otoroshi-cassandra-datastores`\n* `otoroshi-redis-like-store.error(s\"Try to deserialize ${Json.prettyPrint(value)}`\n* `otoroshi-globalconfig-datastore`\n* `otoroshi-mongo-redis`\n* `otoroshi-mongo-datastores`\n* `otoroshi-reactive-pg-datastores`\n* `otoroshi-reactive-pg-kv`\n* `otoroshi-cassandra-datastores`\n* `otoroshi-apikey-datastore`\n* `otoroshi-datastore`\n* `otoroshi-certificate-datastore`\n* `otoroshi-simple-admin-datastore`\n* `otoroshi-atomic-in-memory-datastore`\n* `otoroshi-lettuce-redis`\n* `otoroshi-lettuce-redis-cluster`\n* `otoroshi-redis-lettuce-datastores`\n* `otoroshi-datastores`\n* `otoroshi-file-db-datastores`\n* `otoroshi-http-db-datastores`\n* `otoroshi-s3-datastores`\n* `PluginDocumentationGenerator`\n* `otoroshi-health-checker`\n* `otoroshi-healthcheck-job`\n* `otoroshi-healthcheck-local-cache-job`\n* `otoroshi-plugins-response-cache`\n* `otoroshi-oidc-apikey-config`\n* `otoroshi-plugins-maxmind-geolocation-info`\n* `otoroshi-plugins-ipstack-geolocation-info`\n* `otoroshi-plugins-maxmind-geolocation-helper`\n* `otoroshi-plugins-user-agent-helper`\n* `otoroshi-plugins-user-agent-extractor`\n* `otoroshi-global-el`\n* `otoroshi-plugins-oauth1-caller-plugin`\n* `otoroshi-dynamic-sslcontext`\n* `otoroshi-plugins-access-log-clf`\n* `otoroshi-plugins-access-log-json`\n* `otoroshi-plugins-kafka-access-log`\n* `otoroshi-plugins-kubernetes-client`\n* `otoroshi-plugins-kubernetes-ingress-controller-job`\n* `otoroshi-plugins-kubernetes-ingress-sync`\n* `otoroshi-plugins-kubernetes-crds-controller-job`\n* `otoroshi-plugins-kubernetes-crds-sync`\n* `otoroshi-cluster`\n* `otoroshi-crd-validator`\n* `otoroshi-sidecar-injector`\n* `otoroshi-plugins-kubernetes-cert-sync`\n* `otoroshi-plugins-kubernetes-to-otoroshi-certs-job`\n* `otoroshi-plugins-otoroshi-certs-to-kubernetes-secrets-job`\n* `otoroshi-apikeys-workflow-job`\n* `otoroshi-cert-helper`\n* `otoroshi-certificates-ocsp`\n* `otoroshi-claim`\n* `otoroshi-cert`\n* `otoroshi-ssl-provider`\n* `otoroshi-cert-data`\n* `otoroshi-client-cert-validator`\n* `otoroshi-ssl-implicits`\n* `otoroshi-saml-validator-utils`\n* `otoroshi-global-saml-config`\n* `otoroshi-plugins-hmac-caller-plugin`\n* `otoroshi-plugins-hmac-access-validator-plugin`\n* `otoroshi-plugins-hasallowedusersvalidator`\n* `otoroshi-auth-module-config`\n* `otoroshi-basic-auth-config`\n* `otoroshi-ldap-auth-config`\n* `otoroshi-plugins-jsonpath-helper`\n* `otoroshi-global-oauth2-config`\n* `otoroshi-global-oauth2-module`\n* `otoroshi-ldap-auth-config`\n"
  },
  {
    "name": "end-to-end-mtls.md",
    "id": "/how-to-s/end-to-end-mtls.md",
    "url": "/how-to-s/end-to-end-mtls.html",
    "title": "End-to-end mTLS",
    "content": "# End-to-end mTLS\n\nIf you want to use MTLS on otoroshi, you first need to enable it. It is not enabled by default as it will make TLS handshake way heavier. \nTo enable it just change the following config :\n\n```sh\notoroshi.ssl.fromOutside.clientAuth=None|Want|Need\n```\n\nor using env. variables\n\n```sh\nSSL_OUTSIDE_CLIENT_AUTH=None|Want|Need\n```\n\nYou can use the `Want` setup if you cant to have both mtls on some services and no mtls on other services.\n\nYou can also change the trusted CA list sent in the handshake certificate request from the `Danger Zone` in `Tls Settings`.\n\nOtoroshi support mutual TLS out of the box. mTLS from client to Otoroshi and from Otoroshi to targets are supported. In this article we will see how to configure Otoroshi to use end-to-end mTLS. All code and files used in this articles can be found on the [Otoroshi github](https://github.com/MAIF/otoroshi/tree/master/demos/mtls)\n\n### Create certificates\n\nBut first we need to generate some certificates to make the demo work\n\n```sh\nmkdir mtls-demo\ncd mtls-demo\nmkdir ca\nmkdir server\nmkdir client\n\n# create a certificate authority key, use password as pass phrase\nopenssl genrsa -out ./ca/ca-backend.key 4096\n# remove pass phrase\nopenssl rsa -in ./ca/ca-backend.key -out ./ca/ca-backend.key\n# generate the certificate authority cert\nopenssl req -new -x509 -sha256 -days 730 -key ./ca/ca-backend.key -out ./ca/ca-backend.cer -subj \"/CN=MTLSB\"\n\n\n# create a certificate authority key, use password as pass phrase\nopenssl genrsa -out ./ca/ca-frontend.key 2048\n# remove pass phrase\nopenssl rsa -in ./ca/ca-frontend.key -out ./ca/ca-frontend.key\n# generate the certificate authority cert\nopenssl req -new -x509 -sha256 -days 730 -key ./ca/ca-frontend.key -out ./ca/ca-frontend.cer -subj \"/CN=MTLSF\"\n\n\n# now create the backend cert key, use password as pass phrase\nopenssl genrsa -out ./server/_.backend.oto.tools.key 2048\n# remove pass phrase\nopenssl rsa -in ./server/_.backend.oto.tools.key -out ./server/_.backend.oto.tools.key\n# generate the csr for the certificate\nopenssl req -new -key ./server/_.backend.oto.tools.key -sha256 -out ./server/_.backend.oto.tools.csr -subj \"/CN=*.backend.oto.tools\"\n# generate the certificate\nopenssl x509 -req -days 365 -sha256 -in ./server/_.backend.oto.tools.csr -CA ./ca/ca-backend.cer -CAkey ./ca/ca-backend.key -set_serial 1 -out ./server/_.backend.oto.tools.cer\n# verify the certificate, should output './server/_.backend.oto.tools.cer: OK'\nopenssl verify -CAfile ./ca/ca-backend.cer ./server/_.backend.oto.tools.cer\n\n\n# now create the frontend cert key, use password as pass phrase\nopenssl genrsa -out ./server/_.frontend.oto.tools.key 2048\n# remove pass phrase\nopenssl rsa -in ./server/_.frontend.oto.tools.key -out ./server/_.frontend.oto.tools.key\n# generate the csr for the certificate\nopenssl req -new -key ./server/_.frontend.oto.tools.key -sha256 -out ./server/_.frontend.oto.tools.csr -subj \"/CN=*.frontend.oto.tools\"\n# generate the certificate\nopenssl x509 -req -days 365 -sha256 -in ./server/_.frontend.oto.tools.csr -CA ./ca/ca-frontend.cer -CAkey ./ca/ca-frontend.key -set_serial 1 -out ./server/_.frontend.oto.tools.cer\n# verify the certificate, should output './server/_.frontend.oto.tools.cer: OK'\nopenssl verify -CAfile ./ca/ca-frontend.cer ./server/_.frontend.oto.tools.cer\n\n\n# now create the client cert key for backend, use password as pass phrase\nopenssl genrsa -out ./client/_.backend.oto.tools.key 2048\n# remove pass phrase\nopenssl rsa -in ./client/_.backend.oto.tools.key -out ./client/_.backend.oto.tools.key\n# generate the csr for the certificate\nopenssl req -new -key ./client/_.backend.oto.tools.key -out ./client/_.backend.oto.tools.csr -subj \"/CN=*.backend.oto.tools\"\n# generate the certificate\nopenssl x509 -req -days 365 -sha256 -in ./client/_.backend.oto.tools.csr -CA ./ca/ca-backend.cer -CAkey ./ca/ca-backend.key -set_serial 2 -out ./client/_.backend.oto.tools.cer\n# generate a pem version of the cert and key, use password as password\nopenssl x509 -in client/_.backend.oto.tools.cer -out client/_.backend.oto.tools.pem -outform PEM\n\n\n# now create the client cert key for frontend, use password as pass phrase\nopenssl genrsa -out ./client/_.frontend.oto.tools.key 2048\n# remove pass phrase\nopenssl rsa -in ./client/_.frontend.oto.tools.key -out ./client/_.frontend.oto.tools.key\n# generate the csr for the certificate\nopenssl req -new -key ./client/_.frontend.oto.tools.key -out ./client/_.frontend.oto.tools.csr -subj \"/CN=*.frontend.oto.tools\"\n# generate the certificate\nopenssl x509 -req -days 365 -sha256 -in ./client/_.frontend.oto.tools.csr -CA ./ca/ca-frontend.cer -CAkey ./ca/ca-frontend.key -set_serial 2 -out ./client/_.frontend.oto.tools.cer\n# generate a pkcs12 version of the cert and key, use password as password\n# openssl pkcs12 -export -clcerts -in client/_.frontend.oto.tools.cer -inkey client/_.frontend.oto.tools.key -out client/_.frontend.oto.tools.p12\nopenssl x509 -in client/_.frontend.oto.tools.cer -out client/_.frontend.oto.tools.pem -outform PEM\n```\n\nOnce it's done, you should have something like\n\n```sh\n$ tree\n.\n backend.js\n ca\n  ca-backend.cer\n  ca-backend.key\n  ca-frontend.cer\n  ca-frontend.key\n client\n  _.backend.oto.tools.cer\n  _.backend.oto.tools.csr\n  _.backend.oto.tools.key\n  _.backend.oto.tools.pem\n  _.frontend.oto.tools.cer\n  _.frontend.oto.tools.csr\n  _.frontend.oto.tools.key\n  _.frontend.oto.tools.pem\n server\n     _.backend.oto.tools.cer\n     _.backend.oto.tools.csr\n     _.backend.oto.tools.key\n     _.frontend.oto.tools.cer\n     _.frontend.oto.tools.csr\n     _.frontend.oto.tools.key\n\n3 directories, 18 files\n```\n\n### The backend service \n\nnow, let's create a backend service using nodejs. Create a file named `backend.js`\n\n```sh\ntouch backend.js\n```\n\nand put the following content\n\n```js\nconst fs = require('fs'); \nconst https = require('https'); \n\nconst options = { \n  key: fs.readFileSync('./server/_.backend.oto.tools.key'), \n  cert: fs.readFileSync('./server/_.backend.oto.tools.cer'), \n  ca: fs.readFileSync('./ca/ca-backend.cer'), \n}; \n\nconst server = https.createServer(options, (req, res) => { \n  res.writeHead(200, {\n    'Content-Type': 'application/json'\n  }); \n  res.end(JSON.stringify({ message: 'Hello World!' }) + \"\\n\"); \n}).listen(8444);\n\nconsole.log('Server listening:', `http://localhost:${server.address().port}`);\n```\n\nto run the server, just do \n\n```sh\nnode ./backend.js\n```\n\nnow you can try your server with\n\n```sh\ncurl --cacert ./ca/ca-backend.cer 'https://api.backend.oto.tools:8444/'\n```\n\nThis should output :\n```json\n{ \"message\": \"Hello World!\" }\n```\n\nnow modify your backend server to ensure that the client provides a client certificate like:\n\n```js\nconst fs = require('fs'); \nconst https = require('https'); \n\nconst options = { \n  key: fs.readFileSync('./server/_.backend.oto.tools.key'), \n  cert: fs.readFileSync('./server/_.backend.oto.tools.cer'), \n  ca: fs.readFileSync('./ca/ca-backend.cer'), \n  requestCert: true, \n  rejectUnauthorized: true\n}; \n\nconst server = https.createServer(options, (req, res) => { \n  console.log('Client certificate CN: ', req.socket.getPeerCertificate().subject.CN);\n  res.writeHead(200, {\n    'Content-Type': 'application/json'\n  }); \n  res.end(JSON.stringify({ message: 'Hello World!' }) + \"\\n\"); \n}).listen(8444);\n\nconsole.log('Server listening:', `http://localhost:${server.address().port}`);\n```\n\nyou can test your new server with\n\n```sh\ncurl \\\n  --cacert ./ca/ca-backend.cer \\\n  --cert ./client/_.backend.oto.tools.pem \\\n  --key ./client/_.backend.oto.tools.key 'https://api.backend.oto.tools:8444/'\n```\n\nthe output should be :\n\n```json\n{ \"message\": \"Hello World!\" }\n```\n\n### Otoroshi setup\n\nDownload the latest version of the Otoroshi jar and run it like\n\n```sh\n java \\\n  -Dapp.adminPassword=password \\\n  -Dotoroshi.ssl.fromOutside.clientAuth=Want \\\n  -jar -Dapp.storage=file otoroshi.jar\n\n[info] otoroshi-env - Admin API exposed on http://otoroshi-api.oto.tools:8080\n[info] otoroshi-env - Admin UI  exposed on http://otoroshi.oto.tools:8080\n[info] otoroshi-in-memory-datastores - Now using InMemory DataStores\n[info] otoroshi-env - The main datastore seems to be empty, registering some basic services\n[info] otoroshi-env - You can log into the Otoroshi admin console with the following credentials: admin@otoroshi.io / password\n[info] play.api.Play - Application started (Prod)\n[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n[info] p.c.s.AkkaHttpServer - Listening for HTTPS on /0:0:0:0:0:0:0:0:8443\n[info] otoroshi-env - Generating a self signed SSL certificate for https://*.oto.tools ...\n```\n\nand log into otoroshi with the tuple `admin@otoroshi.io / password` displayed in the logs. \n\nOnce logged in, navigate to the services pages and create a new item. \n* Jump to the `Service exposition settings` and add `http://api.frontend.oto.tools` as `Exposed domain`. \n* Navigate to the `Service targets` and add the following url `https://api.backend.oto.tools:8444/` to redirect our call to the previous created backend. \n* End this step by exposing the service as `Public UI` on the `URL Patterns` section.\n\nand test it\n\n```sh\ncurl 'http://api.frontend.oto.tools:8080/'\n```\n\nThis should output :\n```json\n{\"Otoroshi-Error\": \"Something went wrong, you should try later. Thanks for your understanding.\"}\n```\n\nyou should get an error due to the fact that Otoroshi doesn't know about the server certificate or the client certificate expected by the server.\n\nWe have to add the client certificate for `https://api.backend.oto.tools` to Otoroshi. Go to http://otoroshi.oto.tools:8080/bo/dashboard/certificates and create a new item. Copy and paste the content of `./client/_.backend.oto.tools.cer` and `./client/_.backend.oto.tools.key` respectively in `Certificate full chain` and `Certificate private key`.\n\nand retry the following curl command \n\n```sh\ncurl 'http://api.frontend.oto.tools:8080/'\n```\nthe output should be\n\n```json\n{\"message\":\"Hello World!\"}\n```\n\nnow we have to expose `https://api.frontend.oto.tools:8443` using otoroshi. Go to http://otoroshi.oto.tools:8080/bo/dashboard/certificates and create a new item. Copy and paste the content of `./server/_.frontend.oto.tools.cer` and `./server/_.frontend.oto.tools.key` respectively in `Certificate full chain` and `Certificate private key`.\n\nand try the following command\n\n```sh\ncurl --cacert ./ca/ca-frontend.cer 'https://api.frontend.oto.tools:8443/'\n```\nthe output should be\n\n```json\n{\"message\":\"Hello World!\"}\n```\n\nnow we have to enforce the fact that we want client certificate for `api.frontend.oto.tools`. To do that, we have to add a `Client Validator Only` plugin on the `api.frontend.oto.tools` service. Scroll to the last section called `Plugins` and select the `Client validator only` in the list.\n\nnow if you retry \n\n```sh\ncurl --cacert ./ca/ca-frontend.cer 'https://api.frontend.oto.tools:8443/'\n```\nthe output should be\n\n```json\n{\"Otoroshi-Error\":\"bad request\"}\n```\n\nyou should get an error because no client cert. is passed with the request. But if you pass the `./client/_.frontend.oto.tools.csr` client cert and the key in your curl call\n\n```sh\ncurl 'https://api.frontend.oto.tools:8443' \\\n  --cacert ./ca/ca-frontend.cer \\\n  --cert ./client/_.frontend.oto.tools.pem \\\n  --key ./client/_.frontend.oto.tools.key\n```\nthe output should be\n\n```json\n{\"message\":\"Hello World!\"}\n```\n\n### Client certificate matching plugin\n\nOtoroshi can restrict and check all incoming client certificates on a service.\n\nScroll to the `Plugins` section and select the `Client certificate matching` plugin. Then, click on the `show config. panel` and inject the default configuration of the plugin (by clicking on `Inject default config.`).\n\nSave the service and retry your call again.\n\n```sh\ncurl 'https://api.frontend.oto.tools:8443' \\\n  --cacert ./ca/ca-frontend.cer \\\n  --cert ./client/_.frontend.oto.tools.pem \\\n  --key ./client/_.frontend.oto.tools.key\n```\nthe output should be\n\n```json\n{\"Otoroshi-Error\":\"bad request\"}\n```\n\nOur client certificate is not matched by Otoroshi. We have to add the subject DN in the configuration of the `Client certificate matching` plugin to authorize it.\n\n```json\n{\n  \"HasClientCertMatchingValidator\": {\n    \"serialNumbers\": [],\n    \"subjectDNs\": [\n      \"CN=*.frontend.oto.tools\"\n    ],\n    \"issuerDNs\": [],\n    \"regexSubjectDNs\": [],\n    \"regexIssuerDNs\": []\n  }\n}\n```\n\nSave the service and retry your call again.\n\n```sh\ncurl 'https://api.frontend.oto.tools:8443' \\\n  --cacert ./ca/ca-frontend.cer \\\n  --cert ./client/_.frontend.oto.tools.pem \\\n  --key ./client/_.frontend.oto.tools.key\n```\nthe output should be\n\n```json\n{\"message\":\"Hello World!\"}\n```\n\n\n"
  },
  {
    "name": "export-alerts-using-mailgun.md",
    "id": "/how-to-s/export-alerts-using-mailgun.md",
    "url": "/how-to-s/export-alerts-using-mailgun.html",
    "title": "Send alerts using mailgun",
    "content": "# Send alerts using mailgun\n\nAll Otoroshi alerts can be send on different channels.\nOne of the ways is to send a group of specific alerts via emails.\n\nTo enable this behaviour, let's start by create an exporter of events.\n\nIn this tutorial, we will admit that you already have a mailgun account with an API key and a domain.\n\n## Create an Mailgun exporter\n\nLet's create an exporter. The exporter will export by default all events generate by Otoroshi.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:8080\n2. Click on the cog icon on the top right\n3. Then `Exporters` button\n4. And add a new configuration when clicking on the `Add item` button\n5. Select the `mailer` in the `type` selector field\n6. Jump to `Exporter config` and select the `Mailgun` option\n7. Set the following values:\n* `EU` : false/true depending on your mailgun configuratin\n* `Mailgun api key` : your-mailgun-api-key\n* `Mailgun domain` : your-mailgun-domain\n* `Email addresses` : list of the recipient adresses\n\nWith this configuration, all Otoroshi events will be send to your listed addresses (we don't recommended to do that).\n\nTo filter events on `Alerts` type, we need to add the following configuration inside the `Filtering and projection` section.\n\n```json\n{\n    \"include\": [\n        { \"@type\": \"AlertEvent\" }\n    ],\n    \"exclude\": []\n}\n``` \n\nSave at the bottom page and enable the exporter (on the top of the page or in list of exporters).\n\nThe second field can be useful in the case you want filter the fields contains in each alert sended.\n\nThe `Projection` field is a json when you can list the fields to keep for each alerts.\n\n```json\n{\n \"@type\": true,\n \"@timestamp\": true,\n \"@id\": true\n}\n```\nWith this example, only `@type`, `@timestamp` and `@id` will be send to your recipient adresses."
  },
  {
    "name": "export-events-to-elastic.md",
    "id": "/how-to-s/export-events-to-elastic.md",
    "url": "/how-to-s/export-events-to-elastic.html",
    "title": "Export events to Elasticsearch",
    "content": "# Export events to Elasticsearch\n\n### Before you start\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n### Deploy a Elasticsearch and kibana stack on Docker\n\nLet's start by creating an Elasticsearch and Kibana stack on our machine (if it's already done for you, you can skip this section).\n\nTo start an Elasticsearch container for development or testing, run:\n\n```sh\ndocker network create elastic\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.1\ndocker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.15.1\n```\n\n```sh\ndocker pull docker.elastic.co/kibana/kibana:7.15.1\ndocker run --name kib01-test --net elastic -p 5601:5601 -e \"ELASTICSEARCH_HOSTS=http://es01-test:9200\" docker.elastic.co/kibana/kibana:7.15.1\n```\n\nTo access Kibana, go to *http://localhost:5601*.\n\n### Create an Elasticsearch exporter\n\nLet's create an exporter. The exporter will export by default all events generate by Otoroshi.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:8080\n2. Click on the cog icon on the top right\n3. Then `Exporters` button\n4. And add a new configuration when clicking on the `Add item` button\n5. Select the `elastic` in the `type` selector field\n6. Jump to `Exporter config`\n7. Set the following values: `Cluster URI` -> `http://localhost:9200`\n\nThen test your configuration with `Check connection` button. This should output a modal with Elasticsearch version and the number of loaded docs.\n\nSave at the bottom page and enable the exporter (on the top of the page or in list).\n\n### Testing your configuration\n\nOne simple way to test is to setup the reading of the elasticsearch by Otoroshi.\n\nNavigate to the danger zone (click on the cog on the right top and scroll to `danger zone`).\n\nJump to the `Analytics: Elastic dashboard datasource (read)` section.\n\nSet the following values : `Cluster URI` -> `http://localhost:9200`\n\nThen click on the `Check connection`. This should ouput the same result as the previous part. Save the global configuration and navigate to http://otoroshi.oto.tools:8080/bo/dashboard/stats.\n\nThis should output a list of graphs.\n\n### Advanced usage\n\nBy default, an exporter handle all events from Otoroshi. In some case, you need to filter the events to send to elasticsearch.\n\nTo filter the events, jump to the `Filtering and projection` field in exporter view. Otoroshi supports to include a kind of events or to exclude a list of events. \n\nAn example which include only events with a field `@type` of value `AlertEvent` :\n```json\n{\n    \"include\": [\n        { \"@type\": \"AlertEvent\" }\n    ],\n    \"exclude\": []\n}\n```\nAn example which exclude only events with a field `@type` of value `GatewayEvent` :\n```json\n{\n    \"exclude\": [\n        { \"@type\": \"GatewayEvent\" }\n    ],\n    \"include\": []\n}\n```\n\nThe next field is the `Projection`. This field is a json when you can list the fields to keep for each events.\n\n```json\n{\n \"@type\": true,\n \"@timestamp\": true,\n \"@id\": true\n}\n```\n\nWith this example, only `@type`, `@timestamp` and `@id` will be send to ES.\n\n### Debug your configuration\n\n#### Missing user rights on Elasticsearch\n\nWhen creating an exporter, Otoroshi try to join the index route of the elasticsearch instance. If you have a specific management access rights on Elasticsearch, you have two possiblities :\n\n- set a full access to the user used in Otoroshi for write in Elasticsearch\n- set the version of Elasticsearch inside the `Version` field of your exporter.\n\n#### None events appear in your Elasticsearch\n\nWhen creating an exporter, Otoroshi try to push the index template on Elasticsearch. If the post failed, Otoroshi will fail for each push of events and your database will keep empty. \n\nTo fix this problem, you can try to send the index template with the `Manually apply index template` button in your exporter."
  },
  {
    "name": "import-export-otoroshi-datastore.md",
    "id": "/how-to-s/import-export-otoroshi-datastore.md",
    "url": "/how-to-s/import-export-otoroshi-datastore.html",
    "title": "Import and export Otoroshi datastore",
    "content": "# Import and export Otoroshi datastore\n\n### Start Otoroshi with an initial datastore\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nNow you are almost ready to run Otoroshi for the first time, we want run it with an initial data.\n\nTo do that, you need to add the app.importFrom setting to the Otoroshi configuration (of `$APP_IMPORT_FROM` env).\n\nIt can be a file path or a URL.\n\nThe content of the initial datastore.\n\n```json\n{\n  \"label\": \"Otoroshi initial datastore\",\n  \"admins\": [],\n  \"simpleAdmins\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"username\": \"admin@otoroshi.io\",\n      \"password\": \"$2a$10$iQRkqjKTW.5XH8ugQrnMDeUstx4KqmIeQ58dHHdW2Dv1FkyyAs4C.\",\n      \"label\": \"Otoroshi Admin\",\n      \"createdAt\": 1634651307724,\n      \"type\": \"SIMPLE\",\n      \"metadata\": {},\n      \"tags\": [],\n      \"rights\": [\n        {\n          \"tenant\": \"*:rw\",\n          \"teams\": [\n            \"*:rw\"\n          ]\n        }\n      ]\n    }\n  ],\n  \"serviceGroups\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"admin-api-group\",\n      \"name\": \"Otoroshi Admin Api group\",\n      \"description\": \"No description\",\n      \"tags\": [],\n      \"metadata\": {}\n    },\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"default\",\n      \"name\": \"default-group\",\n      \"description\": \"The default service group\",\n      \"tags\": [],\n      \"metadata\": {}\n    }\n  ],\n  \"apiKeys\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"clientId\": \"admin-api-apikey-id\",\n      \"clientSecret\": \"admin-api-apikey-secret\",\n      \"clientName\": \"Otoroshi Backoffice ApiKey\",\n      \"description\": \"The apikey use by the Otoroshi UI\",\n      \"authorizedGroup\": \"admin-api-group\",\n      \"authorizedEntities\": [\n        \"group_admin-api-group\"\n      ],\n      \"enabled\": true,\n      \"readOnly\": false,\n      \"allowClientIdOnly\": false,\n      \"throttlingQuota\": 10000,\n      \"dailyQuota\": 10000000,\n      \"monthlyQuota\": 10000000,\n      \"constrainedServicesOnly\": false,\n      \"restrictions\": {\n        \"enabled\": false,\n        \"allowLast\": true,\n        \"allowed\": [],\n        \"forbidden\": [],\n        \"notFound\": []\n      },\n      \"rotation\": {\n        \"enabled\": false,\n        \"rotationEvery\": 744,\n        \"gracePeriod\": 168,\n        \"nextSecret\": null\n      },\n      \"validUntil\": null,\n      \"tags\": [],\n      \"metadata\": {}\n    }\n  ],\n  \"serviceDescriptors\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"admin-api-service\",\n      \"groupId\": \"admin-api-group\",\n      \"groups\": [\n        \"admin-api-group\"\n      ],\n      \"name\": \"otoroshi-admin-api\",\n      \"description\": \"\",\n      \"env\": \"prod\",\n      \"domain\": \"oto.tools\",\n      \"subdomain\": \"otoroshi-api\",\n      \"targetsLoadBalancing\": {\n        \"type\": \"RoundRobin\"\n      },\n      \"targets\": [\n        {\n          \"host\": \"127.0.0.1:8080\",\n          \"scheme\": \"http\",\n          \"weight\": 1,\n          \"mtlsConfig\": {\n            \"certs\": [],\n            \"trustedCerts\": [],\n            \"mtls\": false,\n            \"loose\": false,\n            \"trustAll\": false\n          },\n          \"tags\": [],\n          \"metadata\": {},\n          \"protocol\": \"HTTP/1.1\",\n          \"predicate\": {\n            \"type\": \"AlwaysMatch\"\n          },\n          \"ipAddress\": null\n        }\n      ],\n      \"root\": \"/\",\n      \"matchingRoot\": null,\n      \"stripPath\": true,\n      \"localHost\": \"127.0.0.1:8080\",\n      \"localScheme\": \"http\",\n      \"redirectToLocal\": false,\n      \"enabled\": true,\n      \"userFacing\": false,\n      \"privateApp\": false,\n      \"forceHttps\": false,\n      \"logAnalyticsOnServer\": false,\n      \"useAkkaHttpClient\": true,\n      \"useNewWSClient\": false,\n      \"tcpUdpTunneling\": false,\n      \"detectApiKeySooner\": false,\n      \"maintenanceMode\": false,\n      \"buildMode\": false,\n      \"strictlyPrivate\": false,\n      \"enforceSecureCommunication\": true,\n      \"sendInfoToken\": true,\n      \"sendStateChallenge\": true,\n      \"sendOtoroshiHeadersBack\": true,\n      \"readOnly\": false,\n      \"xForwardedHeaders\": false,\n      \"overrideHost\": true,\n      \"allowHttp10\": true,\n      \"letsEncrypt\": false,\n      \"secComHeaders\": {\n        \"claimRequestName\": null,\n        \"stateRequestName\": null,\n        \"stateResponseName\": null\n      },\n      \"secComTtl\": 30000,\n      \"secComVersion\": 1,\n      \"secComInfoTokenVersion\": \"Legacy\",\n      \"secComExcludedPatterns\": [],\n      \"securityExcludedPatterns\": [],\n      \"publicPatterns\": [\n        \"/health\",\n        \"/metrics\"\n      ],\n      \"privatePatterns\": [],\n      \"additionalHeaders\": {\n        \"Host\": \"otoroshi-admin-internal-api.oto.tools\"\n      },\n      \"additionalHeadersOut\": {},\n      \"missingOnlyHeadersIn\": {},\n      \"missingOnlyHeadersOut\": {},\n      \"removeHeadersIn\": [],\n      \"removeHeadersOut\": [],\n      \"headersVerification\": {},\n      \"matchingHeaders\": {},\n      \"ipFiltering\": {\n        \"whitelist\": [],\n        \"blacklist\": []\n      },\n      \"api\": {\n        \"exposeApi\": false\n      },\n      \"healthCheck\": {\n        \"enabled\": false,\n        \"url\": \"/\"\n      },\n      \"clientConfig\": {\n        \"useCircuitBreaker\": true,\n        \"retries\": 1,\n        \"maxErrors\": 20,\n        \"retryInitialDelay\": 50,\n        \"backoffFactor\": 2,\n        \"callTimeout\": 30000,\n        \"callAndStreamTimeout\": 120000,\n        \"connectionTimeout\": 10000,\n        \"idleTimeout\": 60000,\n        \"globalTimeout\": 30000,\n        \"sampleInterval\": 2000,\n        \"proxy\": {},\n        \"customTimeouts\": [],\n        \"cacheConnectionSettings\": {\n          \"enabled\": false,\n          \"queueSize\": 2048\n        }\n      },\n      \"canary\": {\n        \"enabled\": false,\n        \"traffic\": 0.2,\n        \"targets\": [],\n        \"root\": \"/\"\n      },\n      \"gzip\": {\n        \"enabled\": false,\n        \"excludedPatterns\": [],\n        \"whiteList\": [\n          \"text/*\",\n          \"application/javascript\",\n          \"application/json\"\n        ],\n        \"blackList\": [],\n        \"bufferSize\": 8192,\n        \"chunkedThreshold\": 102400,\n        \"compressionLevel\": 5\n      },\n      \"metadata\": {},\n      \"tags\": [],\n      \"chaosConfig\": {\n        \"enabled\": false,\n        \"largeRequestFaultConfig\": null,\n        \"largeResponseFaultConfig\": null,\n        \"latencyInjectionFaultConfig\": null,\n        \"badResponsesFaultConfig\": null\n      },\n      \"jwtVerifier\": {\n        \"type\": \"ref\",\n        \"ids\": [],\n        \"id\": null,\n        \"enabled\": false,\n        \"excludedPatterns\": []\n      },\n      \"secComSettings\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"${config.app.claim.sharedKey}\",\n        \"base64\": false\n      },\n      \"secComUseSameAlgo\": true,\n      \"secComAlgoChallengeOtoToBack\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"secComAlgoChallengeBackToOto\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"secComAlgoInfoToken\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"cors\": {\n        \"enabled\": false,\n        \"allowOrigin\": \"*\",\n        \"exposeHeaders\": [],\n        \"allowHeaders\": [],\n        \"allowMethods\": [],\n        \"excludedPatterns\": [],\n        \"maxAge\": null,\n        \"allowCredentials\": true\n      },\n      \"redirection\": {\n        \"enabled\": false,\n        \"code\": 303,\n        \"to\": \"https://www.otoroshi.io\"\n      },\n      \"authConfigRef\": null,\n      \"clientValidatorRef\": null,\n      \"transformerRef\": null,\n      \"transformerRefs\": [],\n      \"transformerConfig\": {},\n      \"apiKeyConstraints\": {\n        \"basicAuth\": {\n          \"enabled\": true,\n          \"headerName\": null,\n          \"queryName\": null\n        },\n        \"customHeadersAuth\": {\n          \"enabled\": true,\n          \"clientIdHeaderName\": null,\n          \"clientSecretHeaderName\": null\n        },\n        \"clientIdAuth\": {\n          \"enabled\": true,\n          \"headerName\": null,\n          \"queryName\": null\n        },\n        \"jwtAuth\": {\n          \"enabled\": true,\n          \"secretSigned\": true,\n          \"keyPairSigned\": true,\n          \"includeRequestAttributes\": false,\n          \"maxJwtLifespanSecs\": null,\n          \"headerName\": null,\n          \"queryName\": null,\n          \"cookieName\": null\n        },\n        \"routing\": {\n          \"noneTagIn\": [],\n          \"oneTagIn\": [],\n          \"allTagsIn\": [],\n          \"noneMetaIn\": {},\n          \"oneMetaIn\": {},\n          \"allMetaIn\": {},\n          \"noneMetaKeysIn\": [],\n          \"oneMetaKeyIn\": [],\n          \"allMetaKeysIn\": []\n        }\n      },\n      \"restrictions\": {\n        \"enabled\": false,\n        \"allowLast\": true,\n        \"allowed\": [],\n        \"forbidden\": [],\n        \"notFound\": []\n      },\n      \"accessValidator\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excludedPatterns\": []\n      },\n      \"preRouting\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excludedPatterns\": []\n      },\n      \"plugins\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excluded\": []\n      },\n      \"hosts\": [\n        \"otoroshi-api.oto.tools\"\n      ],\n      \"paths\": [],\n      \"handleLegacyDomain\": true,\n      \"issueCert\": false,\n      \"issueCertCA\": null\n    }\n  ],\n  \"errorTemplates\": [],\n  \"jwtVerifiers\": [],\n  \"authConfigs\": [],\n  \"certificates\": [],\n  \"clientValidators\": [],\n  \"scripts\": [],\n  \"tcpServices\": [],\n  \"dataExporters\": [],\n  \"tenants\": [\n    {\n      \"id\": \"default\",\n      \"name\": \"Default organization\",\n      \"description\": \"The default organization\",\n      \"metadata\": {},\n      \"tags\": []\n    }\n  ],\n  \"teams\": [\n    {\n      \"id\": \"default\",\n      \"tenant\": \"default\",\n      \"name\": \"Default Team\",\n      \"description\": \"The default Team of the default organization\",\n      \"metadata\": {},\n      \"tags\": []\n    }\n  ]\n}\n```\n\nRun an Otoroshi with the previous file as parameter.\n\n```sh\njava \\\n  -Dapp.adminPassword=password \\\n  -Dapp.importFrom=./initial-state.json \\\n  -jar otoroshi.jar \n```\n\nThis should display\n\n```sh\n...\n[info] otoroshi-env - Importing from: ./initial-state.json\n[info] otoroshi-env - Successful import !\n...\n[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n...\n```\n\n> Warning : when you using Otoroshi with a datastore different from file or in-memory, Otoroshi doesn't will reload the initialization script. If you expected it, you need to clean manually your store.\n\n### Export the current datastore via the danger zone\n\nWhen Otoroshi is running, you can backup the global configuration store from the UI. Navigate to your instance (in our case http://otoroshi.oto.tools:8080/bo/dashboard/dangerzone) and scroll to the bottom page. \n\nClick on `Full export` button to download the full global configuration.\n\n### Import a datastore from file via the danger zone\n\nWhen Otoroshi is running, you can recover a global configuration from the UI. Navigate to your instance (in our case http://otoroshi.oto.tools:8080/bo/dashboard/dangerzone) and scroll to the bottom page. \n\nClick on `Recover from a full export file` button to apply all configurations from a file.\n\n### Export the current datastore with the Admin API\n\nOtoroshi exposes his own Admin API to manage Otoroshi resources. To call this api, you need to an api key with the rights on `Otoroshi Admin Api group`. This group includes the `Otoroshi-admin-api` service that you can found on the services page. \n\nBy default, and with our initial configuration, Otoroshi has already created an api key named `Otoroshi Backoffice ApiKey`. You can verify the rights of an api key on its page by checking the `Authorized On` field (you should find the `Otoroshi Admin Api group` inside).\n\nThe default api key id and secret are `admin-api-apikey-id` and `admin-api-apikey-secret`.\n\nRun the next command with these values.\n\n```sh\ncurl \\\n  -H 'Content-Type: application/json' \\\n  -u admin-api-apikey-id:admin-api-apikey-secret \\\n  'http://otoroshi-api.oto.tools:8080/api/otoroshi.json'\n```\n\nWhen calling the `/api/otoroshi.json`, the return should be the current datastore including the service descriptors, the api keys, all others resources like certificates and authentification modules, and the the global config (represented by the form of the danger zone).\n\n### Import the current datastore with the Admin API\n\nAs the same way of previous section, you can erase the current datastore with a POST request. The route is the same : `/api/otoroshi.json`.\n\n```sh\ncurl \\\n  -X POST \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"label\" : \"Otoroshi export\",\n    \"dateRaw\" : 1634714811217,\n    \"date\" : \"2021-10-20 09:26:51\",\n    \"stats\" : {\n      \"calls\" : 4,\n      \"dataIn\" : 0,\n      \"dataOut\" : 97991\n    },\n    \"config\" : {\n      \"tags\" : [ ],\n      \"letsEncryptSettings\" : {\n        \"enabled\" : false,\n        \"server\" : \"acme://letsencrypt.org/staging\",\n        \"emails\" : [ ],\n        \"contacts\" : [ ],\n        \"publicKey\" : \"\",\n        \"privateKey\" : \"\"\n      },\n      \"lines\" : [ \"prod\" ],\n      \"maintenanceMode\" : false,\n      \"enableEmbeddedMetrics\" : true,\n      \"streamEntityOnly\" : true,\n      \"autoLinkToDefaultGroup\" : true,\n      \"limitConcurrentRequests\" : false,\n      \"maxConcurrentRequests\" : 1000,\n      \"maxHttp10ResponseSize\" : 4194304,\n      \"useCircuitBreakers\" : true,\n      \"apiReadOnly\" : false,\n      \"u2fLoginOnly\" : false,\n      \"trustXForwarded\" : true,\n      \"ipFiltering\" : {\n        \"whitelist\" : [ ],\n        \"blacklist\" : [ ]\n      },\n      \"throttlingQuota\" : 10000000,\n      \"perIpThrottlingQuota\" : 10000000,\n      \"analyticsWebhooks\" : [ ],\n      \"alertsWebhooks\" : [ ],\n      \"elasticWritesConfigs\" : [ ],\n      \"elasticReadsConfig\" : null,\n      \"alertsEmails\" : [ ],\n      \"logAnalyticsOnServer\" : false,\n      \"useAkkaHttpClient\" : false,\n      \"endlessIpAddresses\" : [ ],\n      \"statsdConfig\" : null,\n      \"kafkaConfig\" : {\n        \"servers\" : [ ],\n        \"keyPass\" : null,\n        \"keystore\" : null,\n        \"truststore\" : null,\n        \"topic\" : \"otoroshi-events\",\n        \"mtlsConfig\" : {\n          \"certs\" : [ ],\n          \"trustedCerts\" : [ ],\n          \"mtls\" : false,\n          \"loose\" : false,\n          \"trustAll\" : false\n        }\n      },\n      \"backOfficeAuthRef\" : null,\n      \"mailerSettings\" : {\n        \"type\" : \"none\"\n      },\n      \"cleverSettings\" : null,\n      \"maxWebhookSize\" : 100,\n      \"middleFingers\" : false,\n      \"maxLogsSize\" : 10000,\n      \"otoroshiId\" : \"83539cbca-76ee-4abc-ad31-a4794e873848\",\n      \"snowMonkeyConfig\" : {\n        \"enabled\" : false,\n        \"outageStrategy\" : \"OneServicePerGroup\",\n        \"includeUserFacingDescriptors\" : false,\n        \"dryRun\" : false,\n        \"timesPerDay\" : 1,\n        \"startTime\" : \"09:00:00.000\",\n        \"stopTime\" : \"23:59:59.000\",\n        \"outageDurationFrom\" : 600000,\n        \"outageDurationTo\" : 3600000,\n        \"targetGroups\" : [ ],\n        \"chaosConfig\" : {\n          \"enabled\" : true,\n          \"largeRequestFaultConfig\" : null,\n          \"largeResponseFaultConfig\" : null,\n          \"latencyInjectionFaultConfig\" : {\n            \"ratio\" : 0.2,\n            \"from\" : 500,\n            \"to\" : 5000\n          },\n          \"badResponsesFaultConfig\" : {\n            \"ratio\" : 0.2,\n            \"responses\" : [ {\n              \"status\" : 502,\n              \"body\" : \"{\\\"error\\\":\\\"Nihonzaru everywhere ...\\\"}\",\n              \"headers\" : {\n                \"Content-Type\" : \"application/json\"\n              }\n            } ]\n          }\n        }\n      },\n      \"scripts\" : {\n        \"enabled\" : false,\n        \"transformersRefs\" : [ ],\n        \"transformersConfig\" : { },\n        \"validatorRefs\" : [ ],\n        \"validatorConfig\" : { },\n        \"preRouteRefs\" : [ ],\n        \"preRouteConfig\" : { },\n        \"sinkRefs\" : [ ],\n        \"sinkConfig\" : { },\n        \"jobRefs\" : [ ],\n        \"jobConfig\" : { }\n      },\n      \"geolocationSettings\" : {\n        \"type\" : \"none\"\n      },\n      \"userAgentSettings\" : {\n        \"enabled\" : false\n      },\n      \"autoCert\" : {\n        \"enabled\" : false,\n        \"replyNicely\" : false,\n        \"caRef\" : null,\n        \"allowed\" : [ ],\n        \"notAllowed\" : [ ]\n      },\n      \"tlsSettings\" : {\n        \"defaultDomain\" : null,\n        \"randomIfNotFound\" : false,\n        \"includeJdkCaServer\" : true,\n        \"includeJdkCaClient\" : true,\n        \"trustedCAsServer\" : [ ]\n      },\n      \"plugins\" : {\n        \"enabled\" : false,\n        \"refs\" : [ ],\n        \"config\" : { },\n        \"excluded\" : [ ]\n      },\n      \"metadata\" : { }\n    },\n    \"admins\" : [ ],\n    \"simpleAdmins\" : [ {\n      \"_loc\" : {\n        \"tenant\" : \"default\",\n        \"teams\" : [ \"default\" ]\n      },\n      \"username\" : \"admin@otoroshi.io\",\n      \"password\" : \"$2a$10$iQRkqjKTW.5XH8ugQrnMDeUstx4KqmIeQ58dHHdW2Dv1FkyyAs4C.\",\n      \"label\" : \"Otoroshi Admin\",\n      \"createdAt\" : 1634651307724,\n      \"type\" : \"SIMPLE\",\n      \"metadata\" : { },\n      \"tags\" : [ ],\n      \"rights\" : [ {\n        \"tenant\" : \"*:rw\",\n        \"teams\" : [ \"*:rw\" ]\n      } ]\n    } ],\n    \"serviceGroups\" : [ {\n      \"_loc\" : {\n        \"tenant\" : \"default\",\n        \"teams\" : [ \"default\" ]\n      },\n      \"id\" : \"admin-api-group\",\n      \"name\" : \"Otoroshi Admin Api group\",\n      \"description\" : \"No description\",\n      \"tags\" : [ ],\n      \"metadata\" : { }\n    }, {\n      \"_loc\" : {\n        \"tenant\" : \"default\",\n        \"teams\" : [ \"default\" ]\n      },\n      \"id\" : \"default\",\n      \"name\" : \"default-group\",\n      \"description\" : \"The default service group\",\n      \"tags\" : [ ],\n      \"metadata\" : { }\n    } ],\n    \"apiKeys\" : [ {\n      \"_loc\" : {\n        \"tenant\" : \"default\",\n        \"teams\" : [ \"default\" ]\n      },\n      \"clientId\" : \"admin-api-apikey-id\",\n      \"clientSecret\" : \"admin-api-apikey-secret\",\n      \"clientName\" : \"Otoroshi Backoffice ApiKey\",\n      \"description\" : \"The apikey use by the Otoroshi UI\",\n      \"authorizedGroup\" : \"admin-api-group\",\n      \"authorizedEntities\" : [ \"group_admin-api-group\" ],\n      \"enabled\" : true,\n      \"readOnly\" : false,\n      \"allowClientIdOnly\" : false,\n      \"throttlingQuota\" : 10000,\n      \"dailyQuota\" : 10000000,\n      \"monthlyQuota\" : 10000000,\n      \"constrainedServicesOnly\" : false,\n      \"restrictions\" : {\n        \"enabled\" : false,\n        \"allowLast\" : true,\n        \"allowed\" : [ ],\n        \"forbidden\" : [ ],\n        \"notFound\" : [ ]\n      },\n      \"rotation\" : {\n        \"enabled\" : false,\n        \"rotationEvery\" : 744,\n        \"gracePeriod\" : 168,\n        \"nextSecret\" : null\n      },\n      \"validUntil\" : null,\n      \"tags\" : [ ],\n      \"metadata\" : { }\n    } ],\n    \"serviceDescriptors\" : [ {\n      \"_loc\" : {\n        \"tenant\" : \"default\",\n        \"teams\" : [ \"default\" ]\n      },\n      \"id\" : \"admin-api-service\",\n      \"groupId\" : \"admin-api-group\",\n      \"groups\" : [ \"admin-api-group\" ],\n      \"name\" : \"otoroshi-admin-api\",\n      \"description\" : \"\",\n      \"env\" : \"prod\",\n      \"domain\" : \"oto.tools\",\n      \"subdomain\" : \"otoroshi-api\",\n      \"targetsLoadBalancing\" : {\n        \"type\" : \"RoundRobin\"\n      },\n      \"targets\" : [ {\n        \"host\" : \"127.0.0.1:8080\",\n        \"scheme\" : \"http\",\n        \"weight\" : 1,\n        \"mtlsConfig\" : {\n          \"certs\" : [ ],\n          \"trustedCerts\" : [ ],\n          \"mtls\" : false,\n          \"loose\" : false,\n          \"trustAll\" : false\n        },\n        \"tags\" : [ ],\n        \"metadata\" : { },\n        \"protocol\" : \"HTTP/1.1\",\n        \"predicate\" : {\n          \"type\" : \"AlwaysMatch\"\n        },\n        \"ipAddress\" : null\n      } ],\n      \"root\" : \"/\",\n      \"matchingRoot\" : null,\n      \"stripPath\" : true,\n      \"localHost\" : \"127.0.0.1:8080\",\n      \"localScheme\" : \"http\",\n      \"redirectToLocal\" : false,\n      \"enabled\" : true,\n      \"userFacing\" : false,\n      \"privateApp\" : false,\n      \"forceHttps\" : false,\n      \"logAnalyticsOnServer\" : false,\n      \"useAkkaHttpClient\" : true,\n      \"useNewWSClient\" : false,\n      \"tcpUdpTunneling\" : false,\n      \"detectApiKeySooner\" : false,\n      \"maintenanceMode\" : false,\n      \"buildMode\" : false,\n      \"strictlyPrivate\" : false,\n      \"enforceSecureCommunication\" : true,\n      \"sendInfoToken\" : true,\n      \"sendStateChallenge\" : true,\n      \"sendOtoroshiHeadersBack\" : true,\n      \"readOnly\" : false,\n      \"xForwardedHeaders\" : false,\n      \"overrideHost\" : true,\n      \"allowHttp10\" : true,\n      \"letsEncrypt\" : false,\n      \"secComHeaders\" : {\n        \"claimRequestName\" : null,\n        \"stateRequestName\" : null,\n        \"stateResponseName\" : null\n      },\n      \"secComTtl\" : 30000,\n      \"secComVersion\" : 1,\n      \"secComInfoTokenVersion\" : \"Legacy\",\n      \"secComExcludedPatterns\" : [ ],\n      \"securityExcludedPatterns\" : [ ],\n      \"publicPatterns\" : [ \"/health\", \"/metrics\" ],\n      \"privatePatterns\" : [ ],\n      \"additionalHeaders\" : {\n        \"Host\" : \"otoroshi-admin-internal-api.oto.tools\"\n      },\n      \"additionalHeadersOut\" : { },\n      \"missingOnlyHeadersIn\" : { },\n      \"missingOnlyHeadersOut\" : { },\n      \"removeHeadersIn\" : [ ],\n      \"removeHeadersOut\" : [ ],\n      \"headersVerification\" : { },\n      \"matchingHeaders\" : { },\n      \"ipFiltering\" : {\n        \"whitelist\" : [ ],\n        \"blacklist\" : [ ]\n      },\n      \"api\" : {\n        \"exposeApi\" : false\n      },\n      \"healthCheck\" : {\n        \"enabled\" : false,\n        \"url\" : \"/\"\n      },\n      \"clientConfig\" : {\n        \"useCircuitBreaker\" : true,\n        \"retries\" : 1,\n        \"maxErrors\" : 20,\n        \"retryInitialDelay\" : 50,\n        \"backoffFactor\" : 2,\n        \"callTimeout\" : 30000,\n        \"callAndStreamTimeout\" : 120000,\n        \"connectionTimeout\" : 10000,\n        \"idleTimeout\" : 60000,\n        \"globalTimeout\" : 30000,\n        \"sampleInterval\" : 2000,\n        \"proxy\" : { },\n        \"customTimeouts\" : [ ],\n        \"cacheConnectionSettings\" : {\n          \"enabled\" : false,\n          \"queueSize\" : 2048\n        }\n      },\n      \"canary\" : {\n        \"enabled\" : false,\n        \"traffic\" : 0.2,\n        \"targets\" : [ ],\n        \"root\" : \"/\"\n      },\n      \"gzip\" : {\n        \"enabled\" : false,\n        \"excludedPatterns\" : [ ],\n        \"whiteList\" : [ \"text/*\", \"application/javascript\", \"application/json\" ],\n        \"blackList\" : [ ],\n        \"bufferSize\" : 8192,\n        \"chunkedThreshold\" : 102400,\n        \"compressionLevel\" : 5\n      },\n      \"metadata\" : { },\n      \"tags\" : [ ],\n      \"chaosConfig\" : {\n        \"enabled\" : false,\n        \"largeRequestFaultConfig\" : null,\n        \"largeResponseFaultConfig\" : null,\n        \"latencyInjectionFaultConfig\" : null,\n        \"badResponsesFaultConfig\" : null\n      },\n      \"jwtVerifier\" : {\n        \"type\" : \"ref\",\n        \"ids\" : [ ],\n        \"id\" : null,\n        \"enabled\" : false,\n        \"excludedPatterns\" : [ ]\n      },\n      \"secComSettings\" : {\n        \"type\" : \"HSAlgoSettings\",\n        \"size\" : 512,\n        \"secret\" : \"${config.app.claim.sharedKey}\",\n        \"base64\" : false\n      },\n      \"secComUseSameAlgo\" : true,\n      \"secComAlgoChallengeOtoToBack\" : {\n        \"type\" : \"HSAlgoSettings\",\n        \"size\" : 512,\n        \"secret\" : \"secret\",\n        \"base64\" : false\n      },\n      \"secComAlgoChallengeBackToOto\" : {\n        \"type\" : \"HSAlgoSettings\",\n        \"size\" : 512,\n        \"secret\" : \"secret\",\n        \"base64\" : false\n      },\n      \"secComAlgoInfoToken\" : {\n        \"type\" : \"HSAlgoSettings\",\n        \"size\" : 512,\n        \"secret\" : \"secret\",\n        \"base64\" : false\n      },\n      \"cors\" : {\n        \"enabled\" : false,\n        \"allowOrigin\" : \"*\",\n        \"exposeHeaders\" : [ ],\n        \"allowHeaders\" : [ ],\n        \"allowMethods\" : [ ],\n        \"excludedPatterns\" : [ ],\n        \"maxAge\" : null,\n        \"allowCredentials\" : true\n      },\n      \"redirection\" : {\n        \"enabled\" : false,\n        \"code\" : 303,\n        \"to\" : \"https://www.otoroshi.io\"\n      },\n      \"authConfigRef\" : null,\n      \"clientValidatorRef\" : null,\n      \"transformerRef\" : null,\n      \"transformerRefs\" : [ ],\n      \"transformerConfig\" : { },\n      \"apiKeyConstraints\" : {\n        \"basicAuth\" : {\n          \"enabled\" : true,\n          \"headerName\" : null,\n          \"queryName\" : null\n        },\n        \"customHeadersAuth\" : {\n          \"enabled\" : true,\n          \"clientIdHeaderName\" : null,\n          \"clientSecretHeaderName\" : null\n        },\n        \"clientIdAuth\" : {\n          \"enabled\" : true,\n          \"headerName\" : null,\n          \"queryName\" : null\n        },\n        \"jwtAuth\" : {\n          \"enabled\" : true,\n          \"secretSigned\" : true,\n          \"keyPairSigned\" : true,\n          \"includeRequestAttributes\" : false,\n          \"maxJwtLifespanSecs\" : null,\n          \"headerName\" : null,\n          \"queryName\" : null,\n          \"cookieName\" : null\n        },\n        \"routing\" : {\n          \"noneTagIn\" : [ ],\n          \"oneTagIn\" : [ ],\n          \"allTagsIn\" : [ ],\n          \"noneMetaIn\" : { },\n          \"oneMetaIn\" : { },\n          \"allMetaIn\" : { },\n          \"noneMetaKeysIn\" : [ ],\n          \"oneMetaKeyIn\" : [ ],\n          \"allMetaKeysIn\" : [ ]\n        }\n      },\n      \"restrictions\" : {\n        \"enabled\" : false,\n        \"allowLast\" : true,\n        \"allowed\" : [ ],\n        \"forbidden\" : [ ],\n        \"notFound\" : [ ]\n      },\n      \"accessValidator\" : {\n        \"enabled\" : false,\n        \"refs\" : [ ],\n        \"config\" : { },\n        \"excludedPatterns\" : [ ]\n      },\n      \"preRouting\" : {\n        \"enabled\" : false,\n        \"refs\" : [ ],\n        \"config\" : { },\n        \"excludedPatterns\" : [ ]\n      },\n      \"plugins\" : {\n        \"enabled\" : false,\n        \"refs\" : [ ],\n        \"config\" : { },\n        \"excluded\" : [ ]\n      },\n      \"hosts\" : [ \"otoroshi-api.oto.tools\" ],\n      \"paths\" : [ ],\n      \"handleLegacyDomain\" : true,\n      \"issueCert\" : false,\n      \"issueCertCA\" : null\n    } ],\n    \"errorTemplates\" : [ ],\n    \"jwtVerifiers\" : [ ],\n    \"authConfigs\" : [ ],\n    \"certificates\" : [],\n    \"clientValidators\" : [ ],\n    \"scripts\" : [ ],\n    \"tcpServices\" : [ ],\n    \"dataExporters\" : [ ],\n    \"tenants\" : [ {\n      \"id\" : \"default\",\n      \"name\" : \"Default organization\",\n      \"description\" : \"The default organization\",\n      \"metadata\" : { },\n      \"tags\" : [ ]\n    } ],\n    \"teams\" : [ {\n      \"id\" : \"default\",\n      \"tenant\" : \"default\",\n      \"name\" : \"Default Team\",\n      \"description\" : \"The default Team of the default organization\",\n      \"metadata\" : { },\n      \"tags\" : [ ]\n    } ]\n  }' \\\n  'http://otoroshi-api.oto.tools:8080/api/otoroshi.json' \\\n  -u admin-api-apikey-id:admin-api-apikey-secret \n```\n\nThis should output :\n\n```json\n{ \"done\":true }\n```\n\n> Note : be very carefully with this POST command. If you send a wrong JSON, you risked to break your instance.\n\nThe second way is to send the same configuration but from a file. You can pass two kind of file : a `json` file or a `ndjson` file. Both files are available as export methods on the danger zone.\n\n```sh\n# the curl is run from a folder containing the initial-state.json file \ncurl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d @./initial-state.json \\\n  'http://otoroshi-api.oto.tools:8080/api/otoroshi.json' \\\n  -u admin-api-apikey-id:admin-api-apikey-secret\n```\n\nThis should output :\n\n```json\n{ \"done\":true }\n```\n\n> Note: To send a ndjson file, you have to set the Content-Type header at `application/x-ndjson`"
  },
  {
    "name": "index.md",
    "id": "/how-to-s/index.md",
    "url": "/how-to-s/index.html",
    "title": "How to's",
    "content": "# How to's\n\nin this section, we will explain some mainstream Otoroshi usage scenario's \n\n* @ref:[End-to-end mTLS](./end-to-end-mtls.md)\n* @ref:[Send alerts by emails](./export-alerts-using-mailgun.md)\n* @ref:[Export events to Elasticsearch](./export-events-to-elastic.md)\n* @ref:[Import/export Otoroshi datastore](./import-export-otoroshi-datastore.md)\n* @ref:[Secure an app with Auth0](./secure-app-with-auth0.md)\n* @ref:[Secure an app with Keycloak](./secure-app-with-keycloak.md)\n* @ref:[Secure an app with LDAP](./secure-app-with-ldap.md)\n* @ref:[Secure an api with apikeys](./secure-with-apikey.md)\n* @ref:[Secure an app with OAuth1](./secure-with-oauth1-client.md)\n* @ref:[Secure an api with OAuth2 client_credentials flow](./secure-with-oauth2-client-credentials.md)\n* @ref:[Setup an Otoroshi cluster](./setup-otoroshi-cluster.md)\n* @ref:[TLS termination using Let's Encrypt](./tls-using-lets-encrypt.md)\n* @ref:[Secure an app with jwt verifiers](./secure-an-app-with-jwt-verifiers.md)\n* @ref:[Secure the communication between a downstream app and Otoroshi](./secure-the-communication-between-a-downstream-app-and-otoroshi.md)\n* @ref:[TLS termination using own certificates](./tls-termination-using-own-certificates.md)\n* @ref:[The resources loader](./resources-loader.md)\n* @ref:[Log levels customization](./custom-log-levels.md)\n* @ref:[Initial state customization](./custom-initial-state.md)\n\n@@@ index\n\n* [End-to-end mTLS](./end-to-end-mtls.md)\n* [Send alerts by emails](./export-alerts-using-mailgun.md)\n* [Export events to Elasticsearch](./export-events-to-elastic.md)\n* [Import/export Otoroshi datastore](./import-export-otoroshi-datastore.md)\n* [Secure an app with Auth0](./secure-app-with-auth0.md)\n* [Secure an app with Keycloak](./secure-app-with-keycloak.md)\n* [Secure an app with LDAP](./secure-app-with-ldap.md)\n* [Secure an api with apikeys](./secure-with-apikey.md)\n* [Secure an app with OAuth1](./secure-with-oauth1-client.md)\n* [Secure an api with OAuth2 client_credentials flow](./secure-with-oauth2-client-credentials.md)\n* [Setup an Otoroshi cluster](./setup-otoroshi-cluster.md)\n* [TLS termination using Let's Encrypt](./tls-using-lets-encrypt.md)\n* [Secure an app with jwt verifiers](./secure-an-app-with-jwt-verifiers.md)\n* [Secure the communication between a downstream app and Otoroshi](./secure-the-communication-between-a-downstream-app-and-otoroshi.md)\n* [TLS termination using own certificates](./tls-termination-using-own-certificates.md)\n* [The resources loader](./resources-loader.md)\n* [Log levels customization](./custom-log-levels.md)\n* [Initial state customization](./custom-initial-state.md)\n\n@@@"
  },
  {
    "name": "resources-loader.md",
    "id": "/how-to-s/resources-loader.md",
    "url": "/how-to-s/resources-loader.html",
    "title": "The resources loader",
    "content": "# The resources loader\n\nThe resources loader is a tool to create an Otoroshi resource from a raw content. This content can be found on each Otoroshi resources pages (services descriptors, apikeys, certificates, etc ...). To get the content of a resource as file, you can use the two export buttons, one to export as JSON format and the other as YAML format.\n\nOnce exported, the content of the resource can be import with the resource loader. You can import single or multiples resources on one time, as JSON and YAML format.\n\nThe resource loader is available on this route [`bo/dashboard/resources-loader`](http://otoroshi.oto.tools:8080/bo/dashboard/resources-loader).\n\nOn this page, you can paste the content of your resources and click on **Load resources**.\n\nFor each detected resource, the loader will display :\n\n* a resource name corresponding to the field `name` \n* a resource type corresponding to the type of created resource (ServiceDescriptor, ApiKey, Certificate, etc)\n* a toggle to choose if you want to include the element for the creation step\n* the updated status by the creation process\n\nOnce you have selected the resources to create, you can **Import selected resources**.\n\nOnce generated, all status will be updated. If all is working, the status will be equals to done.\n\nIf you want to get back to the initial page, you can use the **restart** button."
  },
  {
    "name": "secure-an-app-with-jwt-verifiers.md",
    "id": "/how-to-s/secure-an-app-with-jwt-verifiers.md",
    "url": "/how-to-s/secure-an-app-with-jwt-verifiers.html",
    "title": "Secure an api with jwt verifiers",
    "content": "# Secure an api with jwt verifiers\n\nA Jwt verifier is the guard which check the signature of tokens present in incoming requests on a service. It can be a simple verifier, a tokens generator, or extend to be a verifier and a tokens generator.\n\n### Before you start\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n### Your first jwt verifier : a verifier of tokens\n\nLet's start navigating the @link:[page of verifier creation](http://otoroshi.oto.tools:8080/bo/dashboard/jwt-verifiers/add) { open=new }. By default, the type of jwt verifier is a **Verify JWT token**.\n\nCreate the following verifier : \n\n* Set `simple-jwt-verifier` as `Name`\n* Set `My simple jwt verifier` as `Description`\n* We expect in entry a token in a specific header. Set `Authorization` as `Header name`\n* Select `Hmac + SHA` as `Algo` (for this example, we expect tokens with a symetric signature)\n* Set `otoroshi` as `Hmac secret`\n* Remove the default field in `Verify token fields` array\n* Create your verifier when clicking on `Create and stay on this Jwt verifier` button.\n\nOnce created, navigate to the simple service (created in @ref:[Before you start](#before-you-start) section) and jump to the `JWT tokens verification` section.\n\nIn the verifiers list, choose the `simple-jwt-verifier` and `enabled` the section.\n\nSave your service and try to call the service.\n```sh\ncurl -X GET 'http://myservice.oto.tools:8080/' --include\n```\n\nThis should output : \n```json\n{\n    \"Otoroshi-Error\": \"error.expected.token.not.found\"\n}\n```\n\nA simple way to generate a token is to use @link:[jwt.io](http://jwt.io) { open=new }. Once navigate, define `HS512` as `alg` in header section, and insert `otoroshi` as verify signature secret. \n\nOnce created, copy-paste the token from jwt.io to the Authorization header and call our service.\n\n```sh\n# replace xxxx by the generated token\ncurl -X GET \\\n  -H \"Authorization: xxxx\" \\\n  'http://myservice.oto.tools:8080'\n```\n\nThis should output a json with `authorization` in headers field. His value is exactly the same as the passed token.\n\n```json\n{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"headers\": {\n    \"host\": \"mirror.otoroshi.io\",\n    \"authorization\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.ipDFgkww51mSaSg_199BMRj4gK20LGz_czozu3u8rCFFO1X20MwcabSqEzUc0q4qQ4rjTxjoR4HeUDVcw8BxoQ\",\n    ...\n  }\n}\n```\n\n### Verify and generate a new token\n\nAn other feature is to verify the entry token and generate a new token, with a different signature and news claims. \n\nLet's start by extending the @link:[previous verifier](http://otoroshi.oto.tools:8080/bo/dashboard/jwt-verifiers) { open=new }.\n\n1. Jump to the `Verif Strategy` field and select `Verify and re-sign JWT token`. \n2. Edit the name with `jwt-verify-and-resign`\n3. Remove the default field in `Verify token fields` array\n4. Change the second `Hmac secret` in `Re-sign settings` section with `otoroshi-internal-secret`\n5. Save your verifier.\n\n> Note : the name of the verifier doesn't impact the identifier. So you can save the changes of your verifier without modifying the identifier used in your call.  \n\n```sh\n# replace xxxx by the generated token\ncurl -X GET \\\n  -H \"Authorization: xxxx\" \\\n  'http://myservice.oto.tools:8080'\n```\n\nThis should output a json with `authorization` in headers field. This time, the value are different and you can check his signature on @link:[jwt.io](https://jwt.io) { open=new } (the expected secret of the generated token is **otoroshi-internal-secret**)\n\n<img src=\"../imgs/secure-an-app-with-jwt-verifiers-jwtio.png\" height=\"300px\">\n\n### Verify, transform and generate a new token\n\nThe most advanced verifier is able to do the same as the previous ones, with the ability to configure the token generation (claims, output header name).\n\nLet's start by extending the @link:[previous verifier](http://otoroshi.oto.tools:8080/bo/dashboard/jwt-verifiers) { open=new }.\n\n1. Jump to the `Verif Strategy` field and select `Verify, transform and re-sign JWT token`. \n\n2. Edit the name with `jwt-verify-transform-and-resign`\n3. Remove the default field in `Verify token fields` array\n4. Change the second `Hmac secret` in `Re-sign settings` section with `otoroshi-internal-secret`\n5. Set `Internal-Authorization` as `Header name`\n6. Set `key` on first field of `Rename token fields` and `from-otoroshi-verifier` on second field\n7. Set `generated-key` and `generated-value` as `Set token fields`\n8. Add `generated_at` and `${date}` as second field of `Set token fields` (Otoroshi supports an @ref:[expression language](../topics/expression-language.md))\n9. Save your verifier and try to call your service again.\n\nThis should output a json with `authorization` in headers field and our generate token in `Internal-Authorization`.\nOnce paste in @link:[jwt.io](https://jwt.io) { open=new }, you should have :\n\n<img src=\"../imgs/secure-an-app-with-jwt-verifiers-transform-jwtio.png\">\n\nYou can see, in the payload of your token, the two claims **from-otoroshi-verifier** and **generated-key** added during the generation of the token by the JWT verifier.\n"
  },
  {
    "name": "secure-app-with-auth0.md",
    "id": "/how-to-s/secure-app-with-auth0.md",
    "url": "/how-to-s/secure-app-with-auth0.html",
    "title": "Secure an app with Auth0",
    "content": "# Secure an app with Auth0\n\n### Download Otoroshi\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n### Configure an Auth0 client\n\nThe first step of this tutorial is to setup an Auth0 application with the information of the instance of our Otoroshi.\n\nNavigate to https://manage.auth0.com/ (create an account if it's not already done). \n\nLet's create an application when clicking on the `Applications` button on the sidebar. Then click on the `Create application` button on the right top.\n\n1. Choose `Regular Web Applications` as `Application type`\n2. Then set for example `otoroshi-client` as `Name`, and confirm the creation\n3. Jump to the `Settings` tab\n4. Scroll to the `Application URLs` section and add the following url as `Allowed Callback URLs` : `http://otoroshi.oto.tools:8080/backoffice/auth0/callback`\n5. Set `https://otoroshi.oto.tools:8080/` as `Allowed Logout URLs`\n6. Set `https://otoroshi.oto.tools:8080` as `Allowed Web Origins` \n7. Save changes at the bottom of the page.\n\nOnce done, we have a full setup, with a client ID and secret at the top of the page, which authorize our Otoroshi and redirect the user to the callback url when it will connect to Auth0.\n\n### Create an Auth0 provider module\n\nLet's back to Otoroshi to create an authentication module with `OAuth2 / OIDC provider` as `type`.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:8080\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `OAuth provider` in the type selector field\n3. Then click on `Get from OIDC config` and paste `https://<tenant-name>.<region>.auth0.com/.well-known/openid-configuration`. Replace the tenant name by the name of your tenant (displayed on the left top of auth0 page), and the region of the tenant (`eu` in my case).\n\nOnce done, set the `Client ID` and the `Client secret` from your auth0 application. End the configuration with `http://otoroshi.oto.tools:8080/backoffice/auth0/callback` as `Callback URL`.\n\nAt the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs).\n\n### Connect to Otoroshi with Auth0 authentication\n\nTo secure Otoroshi with your Auth0 configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n2. Scroll to the *BackOffice auth. settings*\n3. Select your last Authentication configuration (created in the previous section)\n4. Save the global configuration with the button on the top right\n\n#### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to http://otoroshi.oto.tools:8080)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the auth0 server login page\n4. Set your account credentials\n5. Good works! You're connected to Otoroshi with an Auth0 module.\n\n### Secure an app with Auth0 authentication\n\nWith the previous configuration, you can secure any of Otoroshi services with it. \n\nThe first step is to apply a little change on the previous configuration. \n\n1. Navigate to http://otoroshi.oto.tools:8080/bo/dashboard/auth-configs.\n2. Create a new auth module configuration with the same values.\n3. Replace the `Callback URL` field to `http://privateapps.oto.tools:8080/privateapps/generic/callback` (we changed this value because the redirection of a logged user by a third-party server is cover by an other route by Otoroshi).\n4. Disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n> Note : a Otoroshi service is call a private app when it is protected by an authentication module.\n\nWe can set the authentication module on the service.\n\n1. Navigate to any created service\n2. Scroll to `Authentication` section\n3. Enable `Enforce user authentication`\n4. Select your Authentication config inside the list\n5. Enable `Strict mode`\n6. Don't forget to save your configuration.\n7. Now you can try to call your defined service and see the Auth0 login page appears.\n\n\n"
  },
  {
    "name": "secure-app-with-keycloak.md",
    "id": "/how-to-s/secure-app-with-keycloak.md",
    "url": "/how-to-s/secure-app-with-keycloak.html",
    "title": "Secure an app with Keycloak",
    "content": "# Secure an app with Keycloak\n\n### Before you start\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n### Running a keycloak instance with docker\n\n```sh\ndocker run \\\n  -p 8080:8080 \\\n  -e KEYCLOAK_USER=admin \\\n  -e KEYCLOAK_PASSWORD=admin \\\n  --name keycloak-server \\\n  --detach jboss/keycloak:15.0.1\n```\n\nThis should download the image of keycloak (if you haven't already it) and display the digest of the created container. This command mapped TCP port 8080 in the container to port 8080 of your laptop and created a server with `admin/admin` as admin credentials.\n\nOnce started, you can open a browser on `http://localhost:8080/` and click on `Administration Console`. Log to your instance with `admin/admin` as credentials.\n\nThe first step is to create a Keycloak client, an entity that can request Keycloak to authenticate a user. Click on the `clients` button on the sidebar, and then on `Create` button at the right top of the view.\n\nFill the client form with the following values.\n\n* `Client ID`: `keycloak-otoroshi-backoffice`\n* `Client Protocol`: `openid-connect`\n* `Root URL`: `http://otoroshi.oto.tools:8080/`\n\nEnd by create the client with the `Save` button.\n\nThe next step is to change the `Access Type` used by default. Jump to the `Access Type` field and select `confidential`. The confidential configuration force the client application to send at Keycloak a client ID and a client Secret. Scroll to the bottom of the page and save the configuration.\n\nNow scroll to the top of your page. Just at the right of the `Settings` tab, a new tab appeared : the `Credentials` page. Click on this tab, and make sure that `Client Id and Secret` is selected as `Client Authenticator` and copy the generated `Secret` to the next part.\n\n### Create a Keycloak provider module\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:8080\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `OAuth2 / OIDC provider` in the type selector field\n3. Set a basic name and description\n\nA simple way to import a Keycloak client is to give the `URL of the OpenID Connect` Otoroshi. By default, keycloak used the next URL : `http://localhost:8080/auth/realms/master/.well-known/openid-configuration`. \n\nClick on the `Get from OIDC config` button and paste the previous link. Once it's done, scroll to the `URLs` section. All URLs has been fill with the values picked from the JSON object returns by the previous URL.\n\nThe only fields to change are : \n\n* `Client ID`: `keycloak-otoroshi-backoffice`\n* `Client Secret`: Paste the Secret from the Credentials Keycloak page. In my case, it's something like `90c9bf0b-2c0c-4eb0-aa02-72195beb9da7`\n* `Callback URL`: `http://otoroshi.oto.tools:8080/backoffice/auth0/callback`\n\nAt the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs). Nothing else to change, just save the configuration.\n\n### Connect to Otoroshi with Keycloak authentication\n\nTo secure Otoroshi with your Keycloak configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n1. Scroll to the *BackOffice auth. settings*\n1. Select your last Authentication configuration (created in the previous section)\n1. Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to http://otoroshi.oto.tools:8080)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the keycloak login page\n4. Set `admin/admin` as user and trust the user by clicking on `yes` button.\n5. Good work! You're connected to Otoroshi with an Keycloak module.\n\n> A fallback solution is always available, by going to http://otoroshi.oto.tools:8080/bo/simple/login, for administrators in case your Authentication module is not well configured or not available\n\n### Visualize an admin user session or a private user session\n\nEach user, wheter connected user to the Otoroshi UI or at a private Otoroshi app, has an own session. As an administrator of Otoroshi, you can visualize via Otoroshi the list of the connected users and their profile.\n\nLet's start by navigating to the `Admin users sessions` page (just @link:[here](http://otoroshi.oto.tools:8080/bo/dashboard/sessions/admin) or when clicking on the cog, and on the `Admins sessions` button at the bottom of the list).\n\nThis page gives a complete view of the connected admins. For each admin, you have his connection date and his expiration date. You can also check the `Profile` and the `Rights` of the connected users.\n\nIf we check the profile and the rights of the previously logged user (from Keycloak in the previous part) we can retrieve the following information :\n\n```json\n{\n  \"sub\": \"4c8cd101-ca28-4611-80b9-efa504ac51fd\",\n  \"upn\": \"admin\",\n  \"email_verified\": false,\n  \"address\": {},\n  \"groups\": [\n    \"create-realm\",\n    \"default-roles-master\",\n    \"offline_access\",\n    \"admin\",\n    \"uma_authorization\"\n  ],\n  \"preferred_username\": \"admin\"\n}\n```\n\nand his default rights \n\n```sh\n[\n  {\n    \"tenant\": \"default:rw\",\n    \"teams\": [\n      \"default:rw\"\n    ]\n  }\n]\n```\n\nWe haven't create any specific groups in Keycloak or specify rights in Otoroshi for him. In this case, the use received the default Otoroshi rights at his connection. We can see that he can navigate on the default Organization and Teams (which are two resources created by Otoroshi at the boot) and that he have the full access (`r`: Read, `w`: Write, `*`: read/write) on its.\n\nIn the same way, you'll find all users connected to a private Otoroshi app when navigate on the @link:[`Private App View`](http://otoroshi.oto.tools:8080/bo/dashboard/sessions/private) or using the cog at the top of the page. \n\n### Configure the Keycloak module to force logged in users to be an Otoroshi admin with full access\n\nGo back to the Keycloak module in `Authentication configs` view. Turn on the `Supers admin only` button and save your configuration. Try again the connection to Otoroshi using Keycloak third-party server.\n\nOnce connected, click on the cog button, and check that you have access to the full features of Otoroshi (like Admin user sessions). Now, your rights should be : \n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\"\n    ]\n  }\n]\n```\n\n### Merge Id token content on user profile\n\nGo back to the Keycloak module in `Authentication confgis` view. Turn on the `Read profile` from token button and save your configuration. Try again the connection to Otoroshi using Keycloak third-party server.\n\nOnce connected, your profile should be contains all Keycloak id token : \n```json\n{\n    \"exp\": 1634286674,\n    \"iat\": 1634286614,\n    \"auth_time\": 1634286614,\n    \"jti\": \"eb368578-e886-4caa-a51b-c1d04973c80e\",\n    \"iss\": \"http://localhost:8080/auth/realms/master\",\n    \"aud\": [\n        \"master-realm\",\n        \"account\"\n    ],\n    \"sub\": \"4c8cd101-ca28-4611-80b9-efa504ac51fd\",\n    \"typ\": \"Bearer\",\n    \"azp\": \"keycloak-otoroshi-backoffice\",\n    \"session_state\": \"e44fe471-aa3b-477d-b792-4f7b4caea220\",\n    \"acr\": \"1\",\n    \"allowed-origins\": [\n        \"http://otoroshi.oto.tools:8080\"\n    ],\n    \"realm_access\": {\n        \"roles\": [\n        \"create-realm\",\n        \"default-roles-master\",\n        \"offline_access\",\n        \"admin\",\n        \"uma_authorization\"\n        ]\n    },\n    \"resource_access\": {\n        \"master-realm\": {\n        \"roles\": [\n            \"view-identity-providers\",\n            \"view-realm\",\n            \"manage-identity-providers\",\n            \"impersonation\",\n            \"create-client\",\n            \"manage-users\",\n            \"query-realms\",\n            \"view-authorization\",\n            \"query-clients\",\n            \"query-users\",\n            \"manage-events\",\n            \"manage-realm\",\n            \"view-events\",\n            \"view-users\",\n            \"view-clients\",\n            \"manage-authorization\",\n            \"manage-clients\",\n            \"query-groups\"\n        ]\n        },\n        \"account\": {\n        \"roles\": [\n            \"manage-account\",\n            \"manage-account-links\",\n            \"view-profile\"\n        ]\n        }\n    }\n    ...\n}\n```\n\n### Manage the Otoroshi user rights from keycloak\n\nOne powerful feature supports by Otoroshi, is to use the Keycloak groups attributes to set a list of rights for a Otoroshi user.\n\nIn the Keycloak module, you have a field, named `Otoroshi rights field name` with `otoroshi_rights` as default value. This field is used by Otoroshi to retrieve information from the Id token groups.\n\nLet's create a group in Keycloak, and set our default Admin user inside.\nIn Keycloak admin console :\n1. Navigate to the groups view, using the keycloak sidebar\n2. Create a new group with `my-group` as `Name`\n3. Then, on the `Attributes` tab, create an attribute with `otoroshi_rights` as `Key` and the following json array as `Value`\n```json\n[\n    {\n        \"tenant\": \"*:rw\",\n        \"teams\": [\n            \"*:rw\",\n            \"my-future-team:rw\"\n        ]\n    }\n]\n```\n\nWith this configuration, the user have a full access on all Otoroshi resources (my-future-team is not created in Otoroshi but it's not a problem, Otoroshi can handle it and use this rights only when the teams will be present)\n\nClick on the `Add` button and save the group. The last step is to assign our user to this group. Jump to `Users` view using the sidebar, click on `View all users`, edit the user and his group membership using the `Groups` tab (use `join` button the assign user in `my-group`).\n\nThe next step is to add a mapper in the Keycloak client. By default, Keycloak doesn't expose any users information (like group membership or users attribute). We need to ask to Keycloak to expose the user attribute `otoroshi_rights` set previously on group.\n\nNavigate to the `Keycloak-otoroshi-backoffice` client, and jump to `Mappers` tab. Create a new mapper with the following values: \n\n* Name: `otoroshi_rights`\n* Mapper Type: `User Attribute`\n* User Attribute: `otoroshi_rights`\n* Token Claim Name: `otoroshi_rights`\n* Claim JSON Type: `JSON`\n* Multivalued: ``\n* Aggregate attribute values: ``\n\nGo back to the Authentication Keycloak module inside Otoroshi UI, and turn off `Super admins only`. Save the configuration.\n\nOnce done, try again the connection to Otoroshi using Keycloak third-party server.\nNow, your rights should be : \n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\",\n      \"my-future-team:rw\"\n    ]\n  }\n]\n```\n\n### Secure an app with Keycloak authentication\n\nThe only change to apply on the previous authentication module, is on the callback URL. When you want secure a Otoroshi service, and transform it on `Private App`, you need to set the `Callback URL` at `http://privateapps.oto.tools:8080/privateapps/generic/callback`\n\n1. Go back to the authentication module\n1. Jump to the `Callback URL` field\n2. Paste this value `http://privateapps.oto.tools:8080/privateapps/generic/callback`\n3. Save your configuration\n4. Navigate to `http://myservice.oto.tools:8080`.\n5. You should redirect to the keycloak login page.\n6. Once logged in, you can check the content of the private app session created.\n\nThe rights should be : \n\n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\",\n      \"my-future-team:rw\"\n    ]\n  }\n]\n```"
  },
  {
    "name": "secure-app-with-ldap.md",
    "id": "/how-to-s/secure-app-with-ldap.md",
    "url": "/how-to-s/secure-app-with-ldap.html",
    "title": "Secure an app and/or your Otoroshi UI with LDAP",
    "content": "# Secure an app and/or your Otoroshi UI with LDAP\n\n### Before you start\n\n@@include[fetch-and-start.md](../includes/fetch-and-start.md) { #init }\n\n#### Running an simple OpenLDAP server \n\nRun OpenLDAP docker image : \n```sh\ndocker run \\\n  -p 389:389 \\\n  -p 636:636  \\\n  --env LDAP_ORGANISATION=\"Otoroshi company\" \\\n  --env LDAP_DOMAIN=\"otoroshi.tools\" \\\n  --env LDAP_ADMIN_PASSWORD=\"otoroshi\" \\\n  --env LDAP_READONLY_USER=\"false\" \\\n  --env LDAP_TLS\"false\" \\\n  --env LDAP_TLS_ENFORCE\"false\" \\\n  --name my-openldap-container \\\n  --detach osixia/openldap:1.5.0\n```\n\nLet's make the first search in our LDAP container :\n\n```sh\ndocker exec my-openldap-container ldapsearch -x -H ldap://localhost -b dc=otoroshi,dc=tools -D \"cn=admin,dc=otoroshi,dc=tools\" -w otoroshi\n```\n\nThis should output :\n```sh\n# extended LDIF\n ...\n# otoroshi.tools\ndn: dc=otoroshi,dc=tools\nobjectClass: top\nobjectClass: dcObject\nobjectClass: organization\no: Otoroshi company\ndc: otoroshi\n\n# search result\nsearch: 2\nresult: 0 Success\n...\n```\n\nNow you can seed the open LDAP server with a few users. \n\nJoin your LDAP container.\n\n```sh\ndocker exec -it my-openldap-container \"/bin/bash\"\n```\n\nThe command `ldapadd` needs of a file to run.\n\nLaunch this command to create a `bootstrap.ldif` with one organization, one singers group with Johnny user and a last group with Einstein as scientist.\n\n```sh\necho -e \"\ndn: ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: organizationalUnit\nou: People\n\ndn: ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: organizationalUnit\nou: Role\n\ndn: uid=johnny,ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: johnny\ncn: Johnny\nsn: Brown\nmail: johnny@otoroshi.tools\npostalCode: 88442\nuserPassword: password\n\ndn: uid=einstein,ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: einstein\ncn: Einstein\nsn: Wilson\nmail: einstein@otoroshi.tools\npostalCode: 88443\nuserPassword: password\n\ndn: cn=singers,ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: groupOfNames\ncn: singers\nmember: uid=johnny,ou=People,dc=otoroshi,dc=tools\n\ndn: cn=scientists,ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: groupOfNames\ncn: scientists\nmember: uid=einstein,ou=People,dc=otoroshi,dc=tools\n\" > bootstrap.ldif\n\nldapadd -x -w otoroshi -D \"cn=admin,dc=otoroshi,dc=tools\" -f bootstrap.ldif -v\n```\n\n### Create an Authentication configuration\n\n- Go ahead, and navigate to http://otoroshi.oto.tools:8080\n- Click on the cog icon on the top right\n- Then `Authentication configs` button\n- And add a new configuration when clicking on the `Add item` button\n- Select the `Ldap auth. provider` in the type selector field\n- Set a basic name and description\n- Then set `ldap://localhost:389` as `LDAP Server URL`and `dc=otoroshi,dc=tools` as `Search Base`\n- Create a group filter (in the next part, we'll change this filter to spread users in different groups with given rights) with \n    - objectClass=groupOfNames as `Group filter` \n    - All as `Tenant`\n    - All as `Team`\n    - Read/Write as `Rights`\n- Set the search filter as (uid=${username})`\n- Set `cn=admin,dc=otoroshi,dc=tools` as `Admin username`\n- Set `otoroshi` as `Admin password`\n- At the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n\n At this point, your configuration should be similar to :\n \n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_09975547-a186-4a2d-a550-ca71a0a03c0c\n - wait 1000\n - screenshot-area generated-hows-to-ldap-auth-configs.png #app>div>div.container-fluid>div>div.col-sm-10.col-sm-offset-2.main\n-->\n<img src=\"../imgs/generated-hows-to-ldap-auth-configs.png\" />\n\n> Dont' forget to save on the bottom page your configuration before to quit the page.\n\n- Test the connection when clicking on `Test admin connection` button\n\nThis should display a `It works!` message\n\n- Finally, test the user connection button and set `johnny/password` or `einstein/password` as credentials.\n\nThis should display a `It works!` message\n\n> Dont' forget to save on the bottom page your configuration before to quit the page.\n\n### Connect to Otoroshi with LDAP authentication\n\nTo secure Otoroshi with your LDAP configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n- Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n- Scroll to the *BackOffice auth. settings*\n- Select your last Authentication configuration (created in the previous section)\n- Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n- Disconnect from your instance\n- Then click on the *Login using third-party* button (or navigate to http://otoroshi.oto.tools:8080/backoffice/auth0/login)\n- Set `johnny/password` or `einstein/password` as credentials\n\n> A fallback solution is always available, by going to http://otoroshi.oto.tools:8080/bo/simple/login, for administrators in case your LDAP is not available\n\n\n#### Secure an app with LDAP authentication\n\nOnce the configuration is done, you can secure any of Otoroshi services with it. \n\n- Navigate to any created service\n- Jump to the `URL Patterns` section\n- Enable your service as `Public UI`\n- Then scroll to `Authentication` section\n- Enable `Enforce user authentication`\n- Select your Authentication config inside the list\n- Enable `Strict mode`\n- Don't forget to save your configuration\n\n<!-- oto-scenario\n - goto /bo/dashboard/lines/prod/services/service_mirror_otoroshi_fr\n - wait 2000\n - click div[data-screenshot=\"ldap-tutorial-authentication\"]>div:nth-child(2)>div\n - screenshot-area generated-hows-to-secure-an-app-with-ldap.png div[data-screenshot=\"ldap-tutorial-authentication\"]\n-->\n<img src=\"../imgs/generated-hows-to-secure-an-app-with-ldap.png\">\n\nNow you can try to call your defined service and see the login module appears.\n\n#### Manage LDAP users rights on Otoroshi\n\nFor each LDAP groups, you can affect a list of rights : \n\n- on an `Organization` : only resources of an organization\n- on a `Team` : only resources belonging to this team\n- and a level of rights : `Read`, `Write` or `Read/Write`\n\n\nStart by navigate to your authentication configuration (created in @ref:[previous](#create-an-authentication-configuration) step).\n\nThen, replace the values of the `Mapping group filter` field to match LDAP groups with Otoroshi rights.\n\n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_91bb8b38-620e-4c18-9bbc-7c8d1efd63cc\n - wait 1000\n - screenshot-area generated-hows-to-ldap-manage-users.png #app>div>div.container-fluid>div>div.col-sm-10.col-sm-offset-2.main>div>div> div.row>div>div>div>form>div>div:nth-child(3)>div:nth-child(11)\n-->\n<img src=\"../imgs/generated-hows-to-ldap-manage-users.png\" />\n\nWith this configuration, Einstein is an administrator of Otoroshi with full rights (read / write) on all organizations.\n\nConversely, Johnny can't see any configuration pages (like the danger zone) because he has only the read rights on Otoroshi.\n\nYou can easily test this behaviour by @ref:[testing](#testing-your-configuration) with both credentials.\n\n\n#### Advanced usage of LDAP Authentication\n\nIn the previous section, we have set rights for each LDAP groups. But in some case, we want to have a finer granularity like set rights for a specific user.\n\nThe last 4 fields of the authentication form cover this. \n\nEach field take the `Email field name` as keys, and a json value.\n\nLet's start by adding few properties for each connected users with `Extra metadata`.\n\n```json\n// Add this configuration in extra metadata part\n{\n  \"provider\": \"OpenLDAP\"\n}\n```\n\nThe next field `Data override` is merged with extra metadata when a user connects to a `private app` (Inside Otoroshi, private app is a service secure by any authentication module) or to the UI. The `Email field name` is configured to match with the `mail` field from LDAP user data.\n\n```json \n{\n  \"johnny@otoroshi.tools\": {\n    \"stage_name\": \"Jean-Philippe Smet\"\n  }\n}\n```\n\nIf you try to connect to an app with this configuration, the user result profile should be :\n\n```json\n{\n  ...,\n  \"metadata\": {\n    \"lastname\": \"Hallyday\",\n    \"stage_name\": \"Jean-Philippe Smet\"\n  }\n}\n```\n\nLet's try to increase the Johnny rights with the `Additional rights group`.\n\nThis field supports the creation of virtual groups. A virtual group is composed of a list of users and a list of rights for each teams/organizations.\n\n```json\n// increase_johnny_rights is a virtual group which adds full access rights at johnny \n{\n  \"increase_johnny_rights\": {\n    \"rights\": [\n      {\n        \"tenant\": \"*:rw\",\n        \"teams\": [\n          \"*:rw\"\n        ]\n      }\n    ],\n    \"users\": [\n      \"johnny@otoroshi.tools\"\n    ]\n  }\n}\n```\n\nThe last field `Rights override` is useful when you want erase the rights of an user with only specific rights.\n\nThe rights override field is the last to be applied on the user rights. \n\nTo resume, when Johnny connects to Otoroshi, he receives the rights to read only on the default Organization (from `Mapping group filter`), then he is promote to administrator role (from `Additional rights group`) and finally his rights are reset with the last field `Rights override` to the read rights.\n\n```json \n{\n  \"johnny@otoroshi.tools\": [\n    {\n      \"tenant\": \"*:r\",\n      \"teams\": [\n        \"*:r\"\n      ]\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n"
  },
  {
    "name": "secure-the-communication-between-a-downstream-app-and-otoroshi.md",
    "id": "/how-to-s/secure-the-communication-between-a-downstream-app-and-otoroshi.md",
    "url": "/how-to-s/secure-the-communication-between-a-downstream-app-and-otoroshi.html",
    "title": "Secure the communication between a downstream app and Otoroshi",
    "content": "# Secure the communication between a downstream app and Otoroshi\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n1. Navigate to http://otoroshi.oto.tools:8080/bo/services and create a new service\n2. Jump to `Service exposition settings` and add http://myservice.oto.tools as `Exposed domain`\n3. Jump to `Service targets` and add http://localhost:8081/ as `Target 1`\n4. Jump to the `URL Patterns` section\n5. Enable your service as `Public UI`\n6. Don't forget to save your service\n\nWe need of a simple service which handle the exchange protocol. For this tutorial, we'll use the following application, developed in NodeJS, which supports both versions of the exchange protocol.\n\nClone this @link:[repository](https://github.com/MAIF/otoroshi/blob/master/demos/challenge) and run the installation of the dependencies.\n\n```sh\ngit clone 'git@github.com:MAIF/otoroshi.git' --depth=1\ncd ./otoroshi/demos/challenge\nnpm install\nPORT=8081 node server.js\n```\n\nThe last command should return : \n\n```sh\nchallenge-verifier listening on http://0.0.0.0:8081\n```\n\nThis project runs an express client with one middleware. The middleware handles each request, and check if the header `State token header` is present in headers. By default, the incoming expected header is `Otoroshi-State` by the application and `Otoroshi-State-Resp` header in the headers of the return request. \n\nTry to call your service via http://myservice.oto.tools:8080/. This should return a successful response with all headers received by the downstream app. \n\nNow try to disable the middleware in the nodejs file by commenting the following line. \n\n```js\n// app.use(OtoroshiMiddleware());\n```\n\nTry to call again your service. This time, Otoroshi breaks the return response from your downstream service, and returns.\n\n```sh\nDownstream microservice does not seems to be secured. Cancelling request !\n```"
  },
  {
    "name": "secure-with-apikey.md",
    "id": "/how-to-s/secure-with-apikey.md",
    "url": "/how-to-s/secure-with-apikey.html",
    "title": "Secure an api with api keys",
    "content": "# Secure an api with api keys\n\n### Before you start\n\n@@include[fetch-and-start.md](../includes/fetch-and-start.md) { #init }\n\n### Create a simple service \n\n1. Navigate to http://otoroshi.oto.tools:8080/bo/dashboard/services and click on the `create new service` button\n2. Jump to `Service exposition settings` and add http://myservice.oto.tools as `Exposed domain`\n3. Jump to `Service targets` and add https://mirror.otoroshi.io/ as `Target 1`\n4. Jump to the `URL Patterns` section\n5. Enable your service as `Public UI`\n6. Open a new tab and navigate to http://myservice.oto.tools:8080/\n\nWith this configuration, all routes are public, wihtout any authentication needed.\n\n### Secure routes with api key\n\nWith the previous configuration, all routes are public. \n\nIn our case, we want to secure all routes prefix with `/api`.\n\nLet's return to the `URL Patterns` section. Click on `Make service a private api`. This button automatically add `/api` as default in `Private patterns` array. (Note that the field supports regex like. In our case, `/api.*` covers all routes starting by `/api`).\n\nSave your app and navigate to http://myservice.oto.tools:8080/api/test again. If the service is configured, you should have a `Service Not found error`, and a success call, in the case you navigate to any other routes which are not starting by `/api/*` like http://myservice.oto.tools:8080/test/bar\n\nThis expected error on the `/api/test`, throws by the URL Patterns, indicate to the client that an api key is required to access to the downstream service.\n\n### Generate an api key to request secure services\n\nNavigate to http://otoroshi.oto.tools:8080/bo/dashboard/apikeys/add or when clicking on the `Add apikey` button on the sidebar.\n\nThe only required fields of an Otoroshi api key are : \n\n* `ApiKey id`\n* `ApiKey Secret`\n* `ApiKey Name`\n\nThese fields are automatically generated by Otoroshi. However, you can override these values and indicate an additional description.\n\nTo simplify the rest of the tutorial, set the values:\n\n* `my-first-api-key-id` as `ApiKey Id`\n* `my-first-api-key-secret` as `ApiKey Secret`\n\nClick on `Create and stay on this ApiKey` button at the bottom of the page.\n\nNow you created the key, it's time to call our previous generated service with it.\n\nOtoroshi supports two methods to achieve that. \nOnce by passing Otoroshi api key in two headers : `Otoroshi-Client-Id` and `Otoroshi-Client-Secret` (these headers names can be override on each service).\nAnd the second by passing Otoroshi api key in the authentication Header (basically the `Authorization` header) as a basic encoded value.\n\nLet's ahead and call our service :\n\n```sh\ncurl -X GET \\\n  -H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n  -H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\n  'http://myservice.oto.tools:8080/api/test' --include\n```\n\nAnd with the second method :\n\n```sh\ncurl -X GET \\\n  -H 'Authorization: Basic bXktZmlyc3QtYXBpLWtleS1pZDpteS1maXJzdC1hcGkta2V5LXNlY3JldA==' \\\n  'http://myservice.oto.tools:8080/api/test' --include\n```\n\n> Tips : To easily fill your headers, you can jump to the `Call examples` section in each api key view. In this section the header names are the default values and the service url is not set. You have to adapt these lines to your case. \n\n### Override defaults headers names for a service\n\nIn some case, we want to change the defaults headers names (and it's a quite good idea).\n\nLet's start by navigating to the `Api keys Constraints` section from the edit page of our sercice.\n\nThe first values to change are the headers names used to read the api key from client. Start by set :\n\n* `api-key-header-id` as `Custom client id header name`\n* `api-key-header-secret` as `Custom client secret header name`\n\nSave the service, and call the service again.\n\n```sh\ncurl -X GET \\\n  -H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n  -H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\n  'http://myservice.oto.tools:8080/api/test' --include\n```\n\nThis should output an error because Otoroshi are expecting the api keys in other headers.\n\n```json\n{\n  \"Otoroshi-Error\": \"No ApiKey provided\"\n}\n```\n\nCall one again the service but with the changed headers names.\n\n```sh\ncurl -X GET \\\n  -H 'api-key-header-id: my-first-api-key-id' \\\n  -H 'api-key-header-secret: my-first-api-key-secret' \\\n  'http://myservice.oto.tools:8080/api/test' --include\n```\n\nWith this configuration, all others default services will accept the api keys with the `Otoroshi-Client-Id` and `Otoroshi-Client-Secret` headers, while our service, will accept the `api-key-header-id` and `api-key-header-secret` headers.\n\n### Accept only api keys with expected values\n\nBy default, a secure service only accepts requests with api key. But all generated api keys are eligible to call our service and in some case, we want authorize only a couple of api keys.\n\nOne feature of Otoroshi is to restrict the list of accepted api keys by giving a list of `metadata` or/and `tags`. Each api key has a list of `tags` and `metadata`, which can be used by Otoroshi to forward or not a call with an api key. All api key metadata/tags can be forward to your service (see `Otoroshi exchange protocol` section of a service to get more information about `Send info. token`).\n\nLet's starting by accept only the api keys which come with the tag of `otoroshi` as value.\n\nJump to the last part of the `Api Keys Constraints` section, call `Routing constraints` (these constraints are used to route a call to a service, only if all constraint are validated).\n\nIn our first case, set `otoroshi` in `One Tag in` array and save the service.\nThen call our service with :\n```sh\ncurl -X GET \\\n  -H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n  -H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\n  'http://myservice.oto.tools:8080/api/test' --include\n```\n\nThis should output :\n```json\n// Error reason : Our api key doesn't contains the expected tag.\n{\n  \"Otoroshi-Error\": \"Bad API key\"\n}\n```\n\nNavigate to the edit page of our api key, and jump to the `Metadata and tags` section.\nIn this section, add `otoroshi` in `Tags` array, then save the api key. Call once again your call and you will normally get a successful response of our downstream service.\n\nIn this example, we have restricted our service to be callable only with keys that have `otoroshi` as a tag.\n\nBut Otoroshi provides others behaviours. For each behaviour, *Api key used should*:\n\n* `All Tags in` : have all of the following tags\n* `No Tags in` : not have one of the following tags\n* `One Tag in` : have at least one of the following tags\n\n---\n\n* `All Meta. in` : have all of the following metadata entries\n* `No Meta. in` : not have one of the following metadata entries\n* `One Meta. in` : have at least one of the following metadata entries\n  \n----\n\n* `One Meta key in` : have at least one of the following key in metadata\n* `All Meta key in` : have all of the following keys in metadata\n* `No Meta key in` : not have one of the following keys in metadata"
  },
  {
    "name": "secure-with-oauth1-client.md",
    "id": "/how-to-s/secure-with-oauth1-client.md",
    "url": "/how-to-s/secure-with-oauth1-client.html",
    "title": "Secure an app with OAuth1 client flow",
    "content": "# Secure an app with OAuth1 client flow\n\n### Before you start\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\n### Running an simple OAuth 1 server\n\nIn this tutorial, we'll instanciate a oauth 1 server with docker. If you alredy have the necessary, skip this section @ref:[to](#create-an-oauth-1-provider-module).\n\nLet's start by running the server\n\n```sh\ndocker run -d --name oauth1-server --rm \\\n    -p 5000:5000 \\\n    -e OAUTH1_CLIENT_ID=2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET \\\n    -e OAUTH1_CLIENT_SECRET=wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp \\\n    -e OAUTH1_REDIRECT_URI=http://otoroshi.oto.tools:8080/backoffice/auth0/callback \\\n    ghcr.io/beryju/oauth1-test-server\n```\n\nWe created a oauth 1 server which accepts `http://otoroshi.oto.tools:8080/backoffice/auth0/callback` as `Redirect URI`. This URL is used by Otoroshi to retrieve a token and a profile at the end of an authentication process.\n\nAfter this command, the container logs should output :\n```sh \n127.0.0.1 - - [14/Oct/2021 12:10:49] \"HEAD /api/health HTTP/1.1\" 200 -\n```\n\n### Create an OAuth 1 provider module\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:8080\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `Oauth1 provider` in the type selector field\n3. Set a basic name and description like `oauth1-provider`\n4. Set `2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET` as `Consumer key`\n5. Set `wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp` as `Consumer secret`\n6. Set `http://localhost:5000/oauth/request_token` as `Request Token URL`\n7. Set `http://localhost:5000/oauth/authorize` as `Authorize URL`\n8. Set `http://localhost:oauth/access_token` as `Access token URL`\n9. Set `http://localhost:5000/api/me` as `Profile URL`\n10. Set `http://otoroshi.oto.tools:8080/backoffice/auth0/callback` as `Callback URL`\n11. At the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n At this point, your configuration should be similar to :\n\n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_oauth1.0_provider\n - wait 1000\n - screenshot generated-hows-to-secure-with-oauth1-provider.png\n-->\n<img src=\"../imgs/generated-hows-to-secure-with-oauth1-provider.png\" />\n\nWith this configuration, the connected user will receive default access on teams and organizations. If you want to change the access rights for a specific user, you can achieve it with the `Rights override` field and a configuration like :\n\n```json\n{\n  \"foo@example.com\": [\n    {\n      \"tenant\": \"*:rw\",\n      \"teams\": [\n        \"*:rw\"\n      ]\n    }\n  ]\n}\n```\n\nSave your configuration at the bottom of the page, then navigate to the `danger zone` to use your module as a third-party connection to the Otoroshi UI.\n\n### Connect to Otoroshi with OAuth1 authentication\n\nTo secure Otoroshi with your OAuth1 configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n1. Scroll to the *BackOffice auth. settings*\n1. Select your last Authentication configuration (created in the previous section)\n1. Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to http://otoroshi.oto.tools:8080)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the oauth 1 server login page\n4. Set `example-user` as user and trust the user by clicking on `yes` button.\n5. Good work! You're connected to Otoroshi with an OAuth1 module.\n\n> A fallback solution is always available, by going to http://otoroshi.oto.tools:8080/bo/simple/login, for administrators in case your Authentication module is not available\n\n### Secure an app with OAuth 1 authentication\n\nWith the previous configuration, you can secure any of Otoroshi services with it. \n\nThe first step is to apply a little change on the previous configuration. \n\n1. Navigate to *http://otoroshi.oto.tools:8080/bo/dashboard/auth-configs*.\n2. Create a new auth module configuration with the same values.\n3. Replace the `Callback URL` field to `http://privateapps.oto.tools:8080/privateapps/generic/callback` (we changed this value because the redirection of a logged user by a third-party server is cover by an other route by Otoroshi).\n4. Disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n> Note : a Otoroshi service is call a private app when it is protected by an authentication module.\n\nOur example server supports only one redirect URI. We need to kill it, and to create a new container with `http://otoroshi.oto.tools:8080/privateapps/generic/callback` as `OAUTH1_REDIRECT_URI`\n\n```sh\ndocker rm -f oauth1-server\ndocker run -d --name oauth1-server --rm \\\n    -p 5000:5000 \\\n    -e OAUTH1_CLIENT_ID=2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET \\\n    -e OAUTH1_CLIENT_SECRET=wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp \\\n    -e OAUTH1_REDIRECT_URI=http://privateapps.oto.tools:8080/privateapps/generic/callback \\\n    ghcr.io/beryju/oauth1-test-server\n```\n\nOnce the authentication module and the new container created, we can set the authentication module on the service.\n\n1. Navigate to any created service\n2. Scroll to `Authentication` section\n3. Enable `Enforce user authentication`\n4. Select your Authentication config inside the list\n5. Enable `Strict mode`\n6.  Don't forget to save your configuration.\n\nNow you can try to call your defined service and see the login module appears.\n\n> <img src=\"../imgs/hows-to-secure-app-with-oauth1-provider-input.png\">\n\nThe allow access to the user.\n\n> <img src=\"../imgs/hows-to-secure-app-with-oauth1-provider-trust.png\">\n\nIf you had any errors, make sure of :\n\n* check if you are on http or https, and if the *secure cookie option* is enabled or not on the authentication module\n* check if your oauth1 server has the REDIRECT_URI set on *privateapps/...*\n* Make sure your server supports POST or GET oauth1 flow set on authentication module\n\nOnce the configuration is working, you can check, when connecting with an Otoroshi admin user, the `Private App session` created (use the cog at the right top of the page, and select `Priv. app sesssions`, or navigate to http://otoroshi.oto.tools:8080/bo/dashboard/sessions/private).\n\nOne interesing feature is to check the profile of the connected user. In our case, when clicking on the `Profile` button of the right user, we should have : \n\n```json\n{\n  \"email\": \"foo@example.com\",\n  \"id\": 1,\n  \"name\": \"test name\",\n  \"screen_name\": \"example-user\"\n}\n```"
  },
  {
    "name": "secure-with-oauth2-client-credentials.md",
    "id": "/how-to-s/secure-with-oauth2-client-credentials.md",
    "url": "/how-to-s/secure-with-oauth2-client-credentials.html",
    "title": "Secure an app with OAuth2 client_credential flow",
    "content": "# Secure an app with OAuth2 client_credential flow\n\nOtoroshi makes it easy for your app to implement the [OAuth2 Client Credentials Flow](https://auth0.com/docs/authorization/flows/client-credentials-flow). Following successful authentication, the calling application will have access to an Access Token, which can be used to call your protected APIs.\n\n## Deployed the Client Credential Service\n\nThe Client Credential Service must be enabled as a global plugin on your Otoroshi instance. To achieve that, navigate to your otoroshi instance (in our case http://otoroshi.oto.tools:8080) on the danger zone (`top right cog icon / Danger zone` or at [/bo/dashboard/dangerzone](http://otoroshi.oto.tools:8080/bo/dashboard/dangerzone)).\n\nTo enable a plugin in global on Otoroshi, you must add it in the `Global Plugins` section.\n\nOpen the `Global Plugin` section, click on `enabled` (if not already done), and search the plugin named `Client Credential Service` of type `Sink`.\n\nTo show and add the default configuration on this plugin, click on the `show config. panel` an on the `Inject default config.` button. This button is available on each plugin and it's useful when you want to inject the default configuration.\n\nWhen you click on the `show config. panel`, you have the documentation of the plugin and its default configuration.\n\nThe client credential plugin has by default 4 parameters : \n\n* `domain`: a regex used to exposed routes on each matching domain (`default`: *)\n* `expiration`: duration until the token expire (in ms) (`default`: 3600000)\n* `defaultKeyPair`: a key pair used to sign the jwt token. By default, Otoroshi is deployed with an otoroshi-jwt-signing that you can visualize on the jwt verifiers certificates (`default`: \"otoroshi-jwt-signing\")\n* `secure`: if enabled, Otoroshi will expose routes only in the https requests case (`default`: true)\n\nIn this tutorial, we will set the configuration as following : \n\n* `domain`: *.oto.tools\n* `expiration`: 3600000\n* `defaultKeyPair`:  otoroshi-jwt-signing\n* `secure`: false\n\nNow that the plugin is running, third routes are exposed on each matching domain of the regex.\n\n* [GET] - `/.well-known/otoroshi/oauth/jwks.json` : retrieve all public keys presents in Otoroshi\n* [POST] - `/.well-known/otoroshi/oauth/token/introspect` : validate and decode the token \n* [POST] - `/.well-known/otoroshi/oauth/token` : generate a token with the fields provided\n\nOnce the global configuration saved, we can deployed a simple service to test it.\n\nLet's navigate to the services page, and create a new service with : \n\n1. `http://foo.oto.tools:8080` as `Exposed domain` in `Service exposition settings` section\n2. `https://mirror.otoroshi.io` as `Target 1` in `Service targets` section\n3. `/.*` as `Private patterns` in `URL Patterns` section (and remove all public patterns)\n\nIn `Api Keys Constraints`, disabled `From basic auth.`, `Allow client id only usage` and `From custom headers` button then saved the service.\n\nLet's make a first call, to check if the jwks are already exposed :\n\n```sh\ncurl 'http://foo.oto.tools:8080/.well-known/otoroshi/oauth/jwks.json'\n```\n\nThis should output a list of public keys : \n```sh\n{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"e\": \"AQAB\",\n      \"kid\": \"otoroshi-intermediate-ca\",\n      ...\n    }\n    ...\n  ]\n}\n``` \n\nLet's make a call on a route of this service. \n\n```sh\ncurl 'http://foo.oto.tools:8080/'\n```\n\nThis should output the expected error: \n```json\n{\n  \"Otoroshi-Error\": \"No ApiKey provided\"\n}\n```\n\nThe first step is to generate an api key. Navigate to the api keys page, and create an item with the following values (it will be more easy to use them in the next step) :\n\n* `my-id` as `ApiKey Id`\n* `my-secret` as `ApiKey Secret`\n\nThe next step is to ask a token by calling the exposed route `/.well-known/otoroshi/oauth/jwks.json`. The required fields are the grand type, the client and the client secret corresponding to our generated api key.\n\n```sh\ncurl -X POST 'http://foo.oto.tools:8080/.well-known/otoroshi/oauth/token'\\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"grant_type\":\"client_credentials\", \"client_id\":\"my-id\", \"client_secret\":\"my-secret\"}'\n```\n\nWe have omit a parameter of the body which is named `scope`. This field can be used to set a bunch of scope on the generated access token.\n\nThe last command should output : \n\n```sh\n{\n  \"access_token\": \"generated-token-xxxxx\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600\n}\n```\n\nOnce generate, we can call our api again : \n```sh\ncurl 'http://foo.oto.tools:8080/' \\\n  -H \"Authorization: Bearer generated-token-xxxxx\"\n```\n\nThis should output a list of headers with a field named `Authorization` containing the previous access token.\n\n\n## Other possible configuration\n\nBy default, Otoroshi generate the access token with the specified key pair in the configuration. But, in some case, you want a specific key pair by client_id/client_secret.\nYou can achieve it when setting a `jwt-sign-keypair` metadata on your desired api key with the id of the key pair as value. \n"
  },
  {
    "name": "setup-otoroshi-cluster.md",
    "id": "/how-to-s/setup-otoroshi-cluster.md",
    "url": "/how-to-s/setup-otoroshi-cluster.html",
    "title": "Setup an Otoroshi cluster",
    "content": "# Setup an Otoroshi cluster\n\nIn this tutorial, we will deploy an Otoroshi cluster with one leader and 2 workers. We will add a load balancer in front of the workers and validate the installation by adding a header on the requests.\n\nLet's start by downloading the latest jar of Otoroshi.\n\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nThen create an instance of Otoroshi and indicates with the `otoroshi.cluster.mode` environment variable that it will be the leader.\n\n```sh\njava -Dhttp.port=8091 -Dhttps.port=9091 -Dotoroshi.cluster.mode=leader -jar otoroshi.jar\n```\n\nOnce created, we have to create the two workers. For both workers, we have to set the ip and the url of their leader in the `otoroshi.cluster.leader.urls` environment variable.\n\nThe first worker will listen on the `:8082/:8092` ports\n```sh\njava \\\n  -Dotoroshi.cluster.worker.name=worker-1 \\\n  -Dhttp.port=8092 \\\n  -Dhttps.port=9092 \\\n  -Dotoroshi.cluster.mode=worker \\\n  -Dotoroshi.cluster.leader.urls.0='http://127.0.0.1:8091' -jar otoroshi.jar\n```\n\nThe second worker will listen on the `:8083/:8093` ports\n```sh\njava \\\n  -Dotoroshi.cluster.worker.name=worker-2 \\\n  -Dhttp.port=8093 \\\n  -Dhttps.port=9093 \\\n  -Dotoroshi.cluster.mode=worker \\\n  -Dotoroshi.cluster.leader.urls.0='http://127.0.0.1:8091' -jar otoroshi.jar\n```\n\nOnce launched, you can navigate to the @link:[cluster view](http://otoroshi.oto.tools:8091/bo/dashboard/cluster) { open=new }. If all is configured, you will see the leader, the 2 workers and a bunch of informations about each instance.\n\nTo complete our installation, we want to spread the incoming requests accross otoroshi worker instances. \n\nIn this tutorial, we will use haproxy has a TCP loadbalancer. If you don't have haproxy installed, you can use docker to run an haproxy instance as explained below.\n\nBut first, we need an haproxy configuration file named `haproxy.cfg` with the following content :\n\n```sh\nfrontend front_nodes_http\n    bind *:8080\n    mode tcp\n    default_backend back_http_nodes\n    timeout client          1m\n\nbackend back_http_nodes\n    mode tcp\n    balance roundrobin\n    server node1 host.docker.internal:8092 # (1)\n    server node2 host.docker.internal:8093 # (1)\n    timeout connect        10s\n    timeout server          1m\n```\n\nand run haproxy with this config file\n\nno docker\n:   @@snip [run.sh](../snippets/cluster-run-ha.sh) { #no_docker }\n\ndocker (on linux)\n:   @@snip [run.sh](../snippets/cluster-run-ha.sh) { #docker_linux }\n\ndocker (on macos)\n:   @@snip [run.sh](../snippets/cluster-run-ha.sh) { #docker_mac }\n\ndocker (on windows)\n:   @@snip [run.sh](../snippets/cluster-run-ha.sh) { #docker_windows }\n\nThe last step is to create a service, add a rule to add, in the headers, a specific value to identify the worker used.\n\nCreate this service, exposed on `http://myapi.oto.tools:xxxx`, which will forward all requests to the mirror `https://mirror.otoroshi.io`.\n\n```sh\ncurl -X POST http://otoroshi-api.oto.tools:8091/api/services \\\n-H \"Content-type: application/json\" \\\n-u admin-api-apikey-id:admin-api-apikey-secret \\\n-d @- <<'EOF'\n{\n    \"enforceSecureCommunication\": false,\n    \"forceHttps\": false,\n    \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n            \"default\"\n        ]\n    },\n    \"groupId\": \"default\",\n    \"groups\": [\n        \"default\"\n    ],\n    \"id\": \"myapi\",\n    \"name\": \"myapi\",\n    \"description\": \"myapi\",\n    \"env\": \"prod\",\n    \"domain\": \"oto.tools\",\n    \"subdomain\": \"api\",\n    \"targetsLoadBalancing\": {\n        \"type\": \"RoundRobin\"\n    },\n    \"targets\": [\n        {\n            \"host\": \"mirror.otoroshi.io\",\n            \"scheme\": \"https\",\n            \"weight\": 1,\n            \"mtlsConfig\": {\n                \"certs\": [],\n                \"trustedCerts\": [],\n                \"mtls\": false,\n                \"loose\": false,\n                \"trustAll\": false\n            },\n            \"tags\": [],\n            \"metadata\": {},\n            \"protocol\": \"HTTP\\/1.1\",\n            \"predicate\": {\n                \"type\": \"AlwaysMatch\"\n            },\n            \"ipAddress\": null\n        }\n    ],\n    \"root\": \"\\/\",\n    \"matchingRoot\": null,\n    \"stripPath\": true,\n    \"enabled\": true,\n    \"publicPatterns\": [\n        \"/.*\"\n    ],\n    \"kind\": \"ServiceDescriptor\",\n    \"additionalHeaders\": {\n        \"worker-name\": \"${config.otoroshi.cluster.worker.name}\"\n    }\n}\nEOF\n```\n\nOnce created, call two times the service. If all is working, the header received by the downstream service will have `worker-1` and `worker-2` as value.\n\n```sh\ncurl 'http://api.oto.tools:8080'\n## Response headers\n{\n    ...\n    \"worker-name\": \"worker-2\"\n    ...\n}\n```\n\nThis should output `worker-1`, then `worker-2`, etc. Well done, your loadbalancing is working and your cluster is set up correctly.\n\n\n"
  },
  {
    "name": "tls-termination-using-own-certificates.md",
    "id": "/how-to-s/tls-termination-using-own-certificates.md",
    "url": "/how-to-s/tls-termination-using-own-certificates.html",
    "title": "TLS termination using own certificates",
    "content": "# TLS termination using own certificates\n\nThe goal of this tutorial is to expose a service via https using a certificate generated by openssl.\n\n@@include[initialize.md](../includes/initialize.md) { #initialize-otoroshi }\n\nTry to call the service.\n\n```sh\ncurl 'http://myservice.oto.tools:8080'\n```\n\nThis should output something like\n\n```json\n{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"headers\": {\n    \"host\": \"mirror.opunmaif.io\",\n    \"accept\": \"*/*\",\n    \"user-agent\": \"curl/7.64.1\",\n    \"x-forwarded-port\": \"443\",\n    \"opun-proxied-host\": \"mirror.otoroshi.io\",\n    \"otoroshi-request-id\": \"1463145856319359618\",\n    \"otoroshi-proxied-host\": \"myservice.oto.tools:8080\",\n    \"opun-gateway-request-id\": \"1463145856554240100\",\n    \"x-forwarded-proto\": \"https\",\n  },\n  \"body\": \"\"\n}\n```\n\nLet's try to call the service in https.\n\n```sh\ncurl 'https://myservice.oto.tools:8443'\n```\n\nThis should output\n\n```sh\ncurl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to myservice.oto.tools:8443\n```\n\nTo fix it, we have to generate a certificate and import it in Otoroshi to match the domain `myservice.oto.tools`.\n\n> If you already had a certificate you can skip the next set of commands and directly import your certificate in Otoroshi\n\nWe will use openssl to generate a private key and a self-signed certificate.\n\n```sh\nopenssl genrsa -out myservice.key 4096\n# remove pass phrase\nopenssl rsa -in myservice.key -out myservice.key\n# generate the certificate authority cert\nopenssl req -new -x509 -sha256 -days 730 -key myservice.key -out myservice.cer -subj \"/CN=myservice.oto.tools\"\n```\n\nCheck the content of the certificate \n\n```sh\nopenssl x509 -in myservice.cer -text\n```\n\nThis should contains something like\n\n```sh\nCertificate:\n    Data:\n        Version: 1 (0x0)\n        Serial Number: 9572962808320067790 (0x84d9fef455f188ce)\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: CN=myservice.oto.tools\n        Validity\n            Not Before: Nov 23 14:25:55 2021 GMT\n            Not After : Nov 23 14:25:55 2022 GMT\n        Subject: CN=myservice.oto.tools\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                Public-Key: (4096 bit)\n                Modulus:\n...\n```\n\nOnce generated, go back to Otoroshi and navigate to the certificates management page (`top right cog icon / SSL/TLS certificates` or at @link:[`/bo/dashboard/certificates`](http://otoroshi.oto.tools:8080/bo/dashboard/certificates)) and click on `Add item`.\n\nSet `myservice-certificate` as `name` and `description`.\n\nDrop the `myservice.cer` file or copy the content to the `Certificate full chain` field.\n\nDo the same action for the `myservice.key` file in the `Certificate private key` field.\n\nSet your passphrase password in the `private key password` field if you added one.\n\nLet's try the same call to the service.\n\n```sh\ncurl 'https://myservice.oto.tools:8443'\n```\n\nAn error should occurs due to the untrsuted received certificate server\n\n```sh\ncurl: (60) SSL certificate problem: self signed certificate\nMore details here: https://curl.haxx.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n```\n\nEnd this tutorial by trusting the certificate server \n\n```sh\ncurl 'https://myservice.oto.tools:8443' --cacert myservice.cer\n```\n\nThis should finally output\n\n```json\n{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"headers\": {\n    \"host\": \"mirror.opunmaif.io\",\n    \"accept\": \"*/*\",\n    \"user-agent\": \"curl/7.64.1\",\n    \"x-forwarded-port\": \"443\",\n    \"opun-proxied-host\": \"mirror.otoroshi.io\",\n    \"otoroshi-request-id\": \"1463158439730479893\",\n    \"otoroshi-proxied-host\": \"myservice.oto.tools:8443\",\n    \"opun-gateway-request-id\": \"1463158439558515871\",\n    \"x-forwarded-proto\": \"https\",\n    \"sozu-id\": \"01FN6MGKSYZNJYHEMP4R5PJ4Q5\"\n  },\n  \"body\": \"\"\n}\n```\n\n"
  },
  {
    "name": "tls-using-lets-encrypt.md",
    "id": "/how-to-s/tls-using-lets-encrypt.md",
    "url": "/how-to-s/tls-using-lets-encrypt.html",
    "title": "TLS termination using Let's Encrypt",
    "content": "# TLS termination using Let's Encrypt\n\nAs you know, Otoroshi is capable of doing TLS termination for your services. You can import your own certificates, generate certificates from scratch and you can also use the @link:[ACME protocol](https://datatracker.ietf.org/doc/html/rfc8555) to generate certificates. One of the most popular service offering ACME certificates creation is @link:[Let's Encrypt](https://letsencrypt.org/).\n\n@@@ warning\nIn order to make this tutorial work, your otoroshi instance MUST be accessible from the internet in order to be reachable by Let's Encrypt ACME process. Also, the domain name used for the certificates MUST be configured to reach your otoroshi instance at your DNS provider level.\n@@@\n\n@@@ note\nthis tutorial can work with any ACME provider with the same rules. your otoroshi instance MUST be accessible by the ACME process. Also, the domain name used for the certificates MUST be configured to reach your otoroshi instance at your DNS provider level.\n@@@\n\n## Setup let's encrypt on otoroshi\n\nGo on the danger zone page by clicking on the [`cog icon / Danger Zone`](http://otoroshi.oto.tools:8080/bo/dashboard/certificates). Scroll to the `Let's Encrypt settings` section. Enable it, and specify the address of the ACME server (for production Let's Encrypt it's `acme://letsencrypt.org`, for testing, it's `acme://letsencrypt.org/staging`. Any ACME server address should work). You can also add one or more email addresses or contact urls that will be included in your Let's Encrypt account. You don't have to fill the `public/private key` inputs as they will be automatically generated on the first usage.\n\n## Creating let's encrypt certificate from FQDNs\n\nYou can go to the certificates page by clicking on the [`cog icon / SSL/TLS Certificates`](http://otoroshi.oto.tools:8080/bo/dashboard/certificates). Here, click on the `+ Let's Encrypt certificate` button. A popup will show up to ask you the FQDN that you want for you certificate. Once done, click on the `Create` button. A few moment later, you will be redirected on a brand new certificate generated by Let's encrypt. You can now enjoy accessing your service behind the FQDN with TLS.\n\n## Creating let's encrypt certificate from a service\n\nYou can go to any service page and enable the flag `Issue Let's Encrypt cert.`. Do not forget to save your service. A few moment later, the certificates will be available in the certificates page and you can will be able to enjoy accessing your service with TLS.\n"
  },
  {
    "name": "fetch-and-start.md",
    "id": "/includes/fetch-and-start.md",
    "url": "/includes/fetch-and-start.html",
    "title": "<!--- #init --->",
    "content": "<!--- #init --->\nIf you already have an up and running otoroshi instance, you can skip the following instructions\n\nLet's start by downloading the latest Otoroshi.\n\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nthen you can run start Otoroshi :\n\n```sh\njava -Dapp.adminPassword=password -jar otoroshi.jar \n```\n\nNow you can log into Otoroshi at http://otoroshi.oto.tools:8080 with `admin@otoroshi.io/password`\n<!--- #init --->"
  },
  {
    "name": "initialize.md",
    "id": "/includes/initialize.md",
    "url": "/includes/initialize.html",
    "title": "<!--- #initialize-otoroshi --->",
    "content": "<!--- #initialize-otoroshi --->\n\nIf you already have an up and running otoroshi instance, you can skip the following instructions\n\n\n@@@div { .instructions }\n\n<div id=\"instructions-toggle\">\n<span class=\"instructions-title\">I want to follow the instructions to start an instance of Otorohi</span>\n<button id=\"instructions-toggle-button\">close</button>\n</div>\n\nLet's start by downloading the latest Otoroshi.\n\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nthen you can run start Otoroshi :\n\n```sh\njava -Dapp.adminPassword=password -jar otoroshi.jar \n```\n\nNow you can log into Otoroshi at http://otoroshi.oto.tools:8080 with `admin@otoroshi.io/password`\n\nCreate a service, exposed on `http://myservice.oto.tools:8080`, which will forward all requests to the mirror `https://mirror.otoroshi.io`. Each call to this service will returned the body and the headers received by the mirror.\n\n```sh\ncurl -X POST 'http://otoroshi-api.oto.tools:8080/api/services' \\\n  -d '{\"enforceSecureCommunication\": false, \"forceHttps\": false, \"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"groupId\":\"default\",\"groups\":[\"default\"],\"name\":\"my-service\",\"description\":\"a service\",\"env\":\"prod\",\"domain\":\"oto.tools\",\"subdomain\":\"myservice\",\"targetsLoadBalancing\":{\"type\":\"RoundRobin\"},\"targets\":[{\"host\":\"mirror.otoroshi.io\",\"scheme\":\"https\",\"weight\":1,\"mtlsConfig\":{\"certs\":[],\"trustedCerts\":[],\"mtls\":false,\"loose\":false,\"trustAll\":false},\"tags\":[],\"metadata\":{},\"protocol\":\"HTTP\\/1.1\",\"predicate\":{\"type\":\"AlwaysMatch\"},\"ipAddress\":null}],\"root\":\"\\/\",\"matchingRoot\":null,\"stripPath\":true,\"enabled\":true,\"secComHeaders\":{\"claimRequestName\":null,\"stateRequestName\":null,\"stateResponseName\":null},\"publicPatterns\":[\"\\/.*\"],\"privatePatterns\":[],\"kind\":\"ServiceDescriptor\"}' \\\n  -H \"Content-type: application/json\" \\\n  -u admin-api-apikey-id:admin-api-apikey-secret\n```\n\n<button id=\"instructions-toggle-confirm\">Confirm the installation</button>\n@@@\n<!--- #initialize-otoroshi --->"
  },
  {
    "name": "index.md",
    "id": "/index.md",
    "url": "/index.html",
    "title": "Otoroshi",
    "content": "# Otoroshi\n\n**Otoroshi** is a layer of lightweight api management on top of a modern http reverse proxy written in <a href=\"https://www.scala-lang.org/\" target=\"_blank\">Scala</a> and developped by the <a href=\"https://maif.github.io\" target=\"_blank\">MAIF OSS</a> team that can handle all the calls to and between your microservices without service locator and let you change configuration dynamicaly at runtime.\n\n\n> *The <a href=\"https://en.wikipedia.org/wiki/Gazu_Hyakki_Yagy%C5%8D#/media/File:SekienOtoroshi.jpg\" target=\"blank\">Otoroshi</a> is a large hairy monster that tends to lurk on the top of the torii gate in front of Shinto shrines. It's a hostile creature, but also said to be the guardian of the shrine and is said to leap down from the top of the gate to devour those who approach the shrine for only self-serving purposes.*\n\n@@@ div { .centered-img }\n[![build](https://github.com/MAIF/otoroshi/actions/workflows/server_build_and_test.yaml/badge.svg)](https://github.com/MAIF/otoroshi/actions/workflows/server_build_and_test.yaml) [![Join the chat at https://gitter.im/MAIF/otoroshi](https://badges.gitter.im/MAIF/otoroshi.svg)](https://gitter.im/MAIF/otoroshi?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [ ![Download](https://img.shields.io/github/release/MAIF/otoroshi.svg) ](hhttps://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar)\n@@@\n\n@@@ div { .centered-img }\n<img src=\"https://github.com/MAIF/otoroshi/raw/master/resources/otoroshi-logo.png\" width=\"300\"></img>\n@@@\n\n## Installation\n\nYou can download the latest build of Otoroshi as a @ref:[fat jar](./install/get-otoroshi.md#from-jar-file), as a @ref:[zip package](./install/get-otoroshi.md#from-zip) or as a @ref:[docker image](./install/get-otoroshi.md#from-docker).\n\nYou can install and run Otoroshi with this little bash snippet\n\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\njava -jar otoroshi.jar\n```\n\nor using docker\n\n```sh\ndocker run -p \"8080:8080\" maif/otoroshi:1.5.0-dev\n```\n\nnow open your browser to <a href=\"http://otoroshi.oto.tools:8080/\" target=\"_blank\">http://otoroshi.oto.tools:8080/</a>, **log in with the credential generated in the logs** and explore by yourself, if you want better instructions, just go to the @ref:[Quick Start](./getting-started.md) or directly to the @ref:[installation instructions](./install/get-otoroshi.md)\n\n## Documentation\n\n* @ref:[About Otoroshi](./about.md)\n* @ref:[Architecture](./architecture.md)\n* @ref:[Features](./features.md)\n* @ref:[Getting started](./getting-started.md)\n* @ref:[Install Otoroshi](./install/index.md)\n* @ref:[Main entities](./entities/index.md)\n* @ref:[Detailed topics](./topics/index.md)\n* @ref:[How to's](./how-to-s/index.md)\n* @ref:[Plugins](./plugins/index.md)\n* @ref:[Admin REST API](./api.md)\n* @ref:[Deploy to production](./deploy/index.md)\n* @ref:[Developing Otoroshi](./dev.md)\n\n## Discussion\n\nJoin the [Otoroshi](https://gitter.im/MAIF/otoroshi) channel on the [MAIF Gitter](https://gitter.im/MAIF) { open=new }\n\n## Sources\n\nThe sources of Otoroshi are available on @link:[Github](https://github.com/MAIF/otoroshi) { open=new }.\n\n## Logo\n\nYou can find the official Otoroshi logo @link:[on GitHub](https://github.com/MAIF/otoroshi/blob/master/resources/otoroshi-logo.png) { open=new }. The Otoroshi logo has been created by Franois Galioto ([@fgalioto](https://twitter.com/fgalioto))\n\n## Changelog\n\nEvery release, along with the migration instructions, is documented on the @link:[Github Releases](https://github.com/MAIF/otoroshi/releases) { open=new } page. A condensed version of the changelog is available on @link:[github](https://github.com/MAIF/otoroshi/blob/master/CHANGELOG.md) { open=new }\n\n## Patrons\n\nThe work on Otoroshi was funded by <a href=\"https://www.maif.fr/\" target=\"_blank\">MAIF</a> with the help of the community.\n\n## Licence\n\nOtoroshi is Open Source and available under the @link:[Apache 2 License](https://opensource.org/licenses/Apache-2.0)  { open=new }\n\n@@@ index\n\n* [About Otoroshi](./about.md)\n* [Architecture](./architecture.md)\n* [Features](./features.md)\n* [Getting started](./getting-started.md)\n* [Install Otoroshi](./install/index.md)\n* [Main entities](./entities/index.md)\n* [Detailed topics](./topics/index.md)\n* [How to's](./how-to-s/index.md)\n* [Plugins](./plugins/index.md)\n* [Admin REST API](./api.md)\n* [Deploy to production](./deploy/index.md)\n* [Developing Otoroshi](./dev.md)\n\n@@@\n\n"
  },
  {
    "name": "get-otoroshi.md",
    "id": "/install/get-otoroshi.md",
    "url": "/install/get-otoroshi.html",
    "title": "Get Otoroshi",
    "content": "# Get Otoroshi\n\nAll release can be bound on the releases page of the @link:[repository](https://github.com/MAIF/otoroshi/releases) { open=new }.\n\n## From zip\n\n```sh\n# Download the latest version\nwget https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi-1.5.0-dev.zip\nunzip ./otoroshi-1.5.0-dev.zip\ncd otoroshi-1.5.0-dev\n```\n\n## From jar file\n\n```sh\n# Download the latest version\nwget https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar\n```\n\n## From Docker\n\n```sh\n# Download the latest version\ndocker pull maif/otoroshi:1.5.0-dev-jdk11\n```\n\n## From Sources\n\nTo build Otoroshi from sources, just go to the @ref:[dev documentation](../dev.md)\n"
  },
  {
    "name": "index.md",
    "id": "/install/index.md",
    "url": "/install/index.html",
    "title": "Install",
    "content": "# Install\n\nIn this sections, you will find informations about how to install and run Otoroshi\n\n* @ref:[Get Otoroshi](./get-otoroshi.md)\n* @ref:[Setup Otoroshi](./setup-otoroshi.md)\n* @ref:[Run Otoroshi](./run-otoroshi.md)\n\n@@@ index\n\n* [Get Otoroshi](./get-otoroshi.md)\n* [Setup Otoroshi](./setup-otoroshi.md)\n* [Run Otoroshi](./run-otoroshi.md)\n\n@@@\n"
  },
  {
    "name": "run-otoroshi.md",
    "id": "/install/run-otoroshi.md",
    "url": "/install/run-otoroshi.html",
    "title": "Run Otoroshi",
    "content": "# Run Otoroshi\n\nNow you are ready to run Otoroshi. You can run the following command with some tweaks depending on the way you want to configure Otoroshi. If you want to pass a custom configuration file, use the `-Dconfig.file=/path/to/file.conf` flag in the following commands.\n\n## From .zip file\n\n```sh\ncd otoroshi-vx.x.x\n./bin/otoroshi\n```\n\n## From .jar file\n\nFor Java 11\n\n```sh\njava -jar otoroshi.jar\n```\n\n## From docker\n\n```sh\ndocker run -p \"8080:8080\" maif/otoroshi\n```\n\nYou can also pass useful args like :\n\n```sh\ndocker run -p \"8080:8080\" maif/otoroshi -Dconfig.file=/usr/app/otoroshi/conf/otoroshi.conf -Dlogger.file=/usr/app/otoroshi/conf/otoroshi.xml\n```\n\nIf you want to provide your own config file, you can read @ref:[the documentation about config files](./setup-otoroshi.md).\n\nYou can also provide some ENV variable using the `--env` flag to customize your Otoroshi instance.\n\nThe list of possible env variables is available @ref:[here](./setup-otoroshi.md).\n\nYou can use a volume to provide configuration like :\n\n```sh\ndocker run -p \"8080:8080\" -v \"$(pwd):/usr/app/otoroshi/conf\" maif/otoroshi\n```\n\nYou can also use a volume if you choose to use `filedb` datastore like :\n\n```sh\ndocker run -p \"8080:8080\" -v \"$(pwd)/filedb:/usr/app/otoroshi/filedb\" maif/otoroshi -Dapp.storage=file\n```\n\nYou can also use a volume if you choose to use exports files :\n\n```sh\ndocker run -p \"8080:8080\" -v \"$(pwd):/usr/app/otoroshi/imports\" maif/otoroshi -Dapp.importFrom=/usr/app/otoroshi/imports/export.json\n```\n\n## Run examples\n\n```sh\n$ java \\\n  -Xms2G \\\n  -Xmx8G \\\n  -Dhttp.port=8080 \\\n  -Dapp.importFrom=/home/user/otoroshi.json \\\n  -Dconfig.file=/home/user/otoroshi.conf \\\n  -jar ./otoroshi.jar\n\n[warn] otoroshi-in-memory-datastores - Now using InMemory DataStores\n[warn] otoroshi-env - The main datastore seems to be empty, registering some basic services\n[warn] otoroshi-env - Importing from: /home/user/otoroshi.json\n[info] play.api.Play - Application started (Prod)\n[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n```\n\nIf you choose to start Otoroshi without importing existing data, Otoroshi will create a new admin user and print the login details in the log. When you will log into the admin dashboard, Otoroshi will ask you to create another account to avoid security issues.\n\n```sh\n$ java \\\n  -Xms2G \\\n  -Xmx8G \\\n  -Dhttp.port=8080 \\\n  -jar otoroshi.jar\n\n[warn] otoroshi-in-memory-datastores - Now using InMemory DataStores\n[warn] otoroshi-env - The main datastore seems to be empty, registering some basic services\n[warn] otoroshi-env - You can log into the Otoroshi admin console with the following credentials: admin@otoroshi.io / HHUsiF2UC3OPdmg0lGngEv3RrbIwWV5W\n[info] play.api.Play - Application started (Prod)\n[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:8080\n```\n"
  },
  {
    "name": "setup-otoroshi.md",
    "id": "/install/setup-otoroshi.md",
    "url": "/install/setup-otoroshi.html",
    "title": "Setup Otoroshi",
    "content": "# Setup Otoroshi\n\nRight now, Otoroshi supports multiple datastore. You can choose one datastore over another depending on your use case.\n\n@@@div { .plugin .platform } \n<div style=\"font-size: 22px; font-weight: bold;\">Redis</div>\n\n<div class=\"element-tag recommended-tag\">Recommended</div>\n\nThe **redis** datastore is quite nice when you want to easily deploy several Otoroshi instances.\n\n<img src=\"../imgs/redis.png\" />\n\n@link:[Documentation](https://redis.io/topics/quickstart)\n@@@\n\n@@@div { .plugin .platform } \n<div style=\"font-size: 22px; font-weight: bold;\">In memory</div>\n\nThe **in-memory** datastore is kind of interesting. It can be used for testing purposes, but it is also a good candidate for production because of its fastness.\n\n<img src=\"../imgs/inmemory.png\" />\n\n@ref:[Start with](../getting-started.md)\n@@@\n\n@@@div { .plugin .platform } \n<div style=\"font-size: 22px; font-weight: bold;\">Cassandra</div>\n\n<div class=\"element-tag cluster-tag\">Clustering usage</div>\n\nExperimental support, should be used in cluster mode for leaders\n\n<img src=\"../imgs/cassandra.png\" />\n\n@link:[Documentation](https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html)\n@@@\n\n@@@div { .plugin .platform } \n<div style=\"font-size: 22px; font-weight: bold;\">Postgresql</div>\n\nOr any postgresql compatible databse like cockroachdb for instance (experimental support, should be used in cluster mode for leaders)\n\n<img src=\"../imgs/postgres.png\" />\n\n@link:[Documentation](https://www.postgresql.org/docs/10/tutorial-install.html)\n@@@\n\n@@@div { .plugin .platform } \n\n<div style=\"font-size: 22px; font-weight: bold;\">FileDB</div>\n\nThe **filedb** datastore is pretty handy for testing purposes, but is not supposed to be used in production mode. \nNot suitable for production usage.\n\n<img src=\"../imgs/filedb.png\" />\n\n@@@\n\n\n@@@ div { .centered-img }\n<img src=\"../imgs/datastores.png\" />\n@@@\n\n## Setup your configuration file\n\nThere is a lot of things you can configure in Otoroshi. By default, Otoroshi provides a configuration that should be enough for testing purpose. But you'll likely need to update this configuration when you'll need to move into production.\n\nIn this page, any configuration property can be set at runtime using a `-D` flag when launching Otoroshi like\n\n```sh\njava -Dhttp.port=8080 -jar otoroshi.jar\n```\n\nor\n\n```sh\n./bin/otoroshi -Dhttp.port=8080 \n```\n\nif you want to define your own config file and use it on an otoroshi instance, use the following flag\n\n```sh\njava -Dconfig.file=/path/to/otoroshi.conf -jar otoroshi.jar\n``` \n\n### Example of a custom. configuration file\n\n```conf\ninclude \"application.conf\"\n\nhttp.port = 8080\n\napp {\n  storage = \"inmemory\"\n  importFrom = \"./my-state.json\"\n  env = \"prod\"\n  domain = \"oto.tools\"\n  rootScheme = \"http\"\n  snowflake {\n    seed = 0\n  }\n  events {\n    maxSize = 1000\n  }\n  backoffice {\n    subdomain = \"otoroshi\"\n    session {\n      exp = 86400000\n    }\n  }\n  privateapps {\n    subdomain = \"privateapps\"\n    session {\n      exp = 86400000\n    }\n  }\n  adminapi {\n    targetSubdomain = \"otoroshi-admin-internal-api\"\n    exposedSubdomain = \"otoroshi-api\"\n    defaultValues {\n      backOfficeGroupId = \"admin-api-group\"\n      backOfficeApiKeyClientId = \"admin-api-apikey-id\"\n      backOfficeApiKeyClientSecret = \"admin-api-apikey-secret\"\n      backOfficeServiceId = \"admin-api-service\"\n    }\n  }\n  claim {\n    sharedKey = \"mysecret\"\n  }\n  filedb {\n    path = \"./filedb/state.ndjson\"\n  }\n}\n\nplay.http {\n  session {\n    secure = false\n    httpOnly = true\n    maxAge = 2592000000\n    domain = \".oto.tools\"\n    cookieName = \"oto-sess\"\n  }\n}\n```\n\n### Reference configuration\n\n@@snip [reference.conf](../snippets/reference.conf) \n\n### More config. options\n\nSee default configuration at\n\n* @link:[Base configuration](https://github.com/MAIF/otoroshi/blob/master/otoroshi/conf/base.conf) { open=new }\n* @link:[Application configuration](https://github.com/MAIF/otoroshi/blob/master/otoroshi/conf/application.conf) { open=new }\n\n## Configuration with env. variables\n\nEevery property in the configuration file can be overriden by an environment variable if it has env variable override written like `${?ENV_VARIABLE}`).\n\n## Reference configuration for env. variables\n\n@@snip [reference-env.conf](../snippets/reference-env.conf) \n\n## Setup your hosts\n\nBy default, Otoroshi starts with domain `oto.tools` that automatically targets `127.0.0.1` with no changes to you `/etc/hosts` file. Of course you can change the domain, you have to add the values in your `/etc/hosts` file according to the setting you put in Otoroshi configuration\n\n* `app.domain` => `mydomain.org`\n* `app.backoffice.subdomain` => `otoroshi`\n* `app.privateapps.subdomain` => `privateapps`\n* `app.adminapi.exposedSubdomain` => `otoroshi-api`\n* `app.adminapi.targetSubdomain` => `otoroshi-admin-internal-api`\n\nfor instance if you want to change the default domain and use something like `otoroshi.mydomain.org`, then start otoroshi like \n\n```sh\njava -Dapp.domain=mydomain.org -jar otoroshi.jar\n```\n\n@@@ warning\nOtoroshi cannot be accessed using `http://127.0.0.1:8080` or `http://localhost:8080` because Otoroshi uses Otoroshi to serve it's own UI and API. When otoroshi starts with an empty database, it will create a service descriptor for that using `app.domain` and the settings listed on this page and in the here that serve Otoroshi API and UI on `http://otoroshi-api.${app.domain}` and `http://otoroshi.${app.domain}`.\nOnce the descriptor is saved in database, if you want to change `app.domain`, you'll have to edit the descriptor in the database or restart Otoroshi with an empty database.\n@@@\n"
  },
  {
    "name": "built-in-plugins.md",
    "id": "/plugins/built-in-plugins.md",
    "url": "/plugins/built-in-plugins.html",
    "title": "Otoroshi built-in plugins",
    "content": "# Otoroshi built-in plugins\n\nOtoroshi provides some plugins out of the box. Here is the available plugins with their documentation and reference configuration\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Access log (CLF)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `AccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged in CLF format.\n\nLog format is the following:\n\n`\"$service\" $clientAddress - \"$userId\" [$timestamp] \"$host $method $path $protocol\" \"$status $statusTxt\" $size $snowflake \"$to\" \"$referer\" \"$userAgent\" $http $duration $errorMsg`\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"AccessLog\": {\n    \"enabled\": true,\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"AccessLog\" : {\n    \"enabled\" : true,\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Access log (JSON)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `AccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged in json format.\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"AccessLog\": {\n    \"enabled\": true,\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"AccessLog\" : {\n    \"enabled\" : true,\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Kafka access log\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `KafkaAccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged as an event in a kafka topic.\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"KafkaAccessLog\": {\n    \"enabled\": true,\n    \"topic\": \"otoroshi-access-log\",\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KafkaAccessLog\" : {\n    \"enabled\" : true,\n    \"topic\" : \"otoroshi-access-log\",\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Basic Auth. caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `BasicAuthCaller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using basic auth.\n\nThis plugin accepts the following configuration\n\n{\n  \"username\" : \"the_username\",\n  \"password\" : \"the_password\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Basic %s\"\n}\n\n\n\n### Default configuration\n\n```json\n{\n  \"username\" : \"the_username\",\n  \"password\" : \"the_password\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Basic %s\"\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OAuth2 caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OAuth2Caller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using OAuth2 client_credential/password flow.\nDo not forget to enable client retry to handle token generation on expire.\n\nThis plugin accepts the following configuration\n\n{\n  \"kind\" : \"the oauth2 flow, can be 'client_credentials' or 'password'\",\n  \"url\" : \"https://127.0.0.1:8080/oauth/token\",\n  \"method\" : \"POST\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Bearer %s\",\n  \"jsonPayload\" : false,\n  \"clientId\" : \"the client_id\",\n  \"clientSecret\" : \"the client_secret\",\n  \"scope\" : \"an optional scope\",\n  \"audience\" : \"an optional audience\",\n  \"user\" : \"an optional username if using password flow\",\n  \"password\" : \"an optional password if using password flow\",\n  \"cacheTokenSeconds\" : \"the number of second to wait before asking for a new token\",\n  \"tlsConfig\" : \"an optional TLS settings object\"\n}\n\n\n\n### Default configuration\n\n```json\n{\n  \"kind\" : \"the oauth2 flow, can be 'client_credentials' or 'password'\",\n  \"url\" : \"https://127.0.0.1:8080/oauth/token\",\n  \"method\" : \"POST\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Bearer %s\",\n  \"jsonPayload\" : false,\n  \"clientId\" : \"the client_id\",\n  \"clientSecret\" : \"the client_secret\",\n  \"scope\" : \"an optional scope\",\n  \"audience\" : \"an optional audience\",\n  \"user\" : \"an optional username if using password flow\",\n  \"password\" : \"an optional password if using password flow\",\n  \"cacheTokenSeconds\" : \"the number of second to wait before asking for a new token\",\n  \"tlsConfig\" : \"an optional TLS settings object\"\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Response Cache\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ResponseCache`\n\n### Description\n\nThis plugin can cache responses from target services in the otoroshi datasstore\nIt also provides a debug UI at `/.well-known/otoroshi/bodylogger`.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ResponseCache\": {\n    \"enabled\": true, // enabled cache\n    \"ttl\": 300000,  // store it for some times (5 minutes by default)\n    \"maxSize\": 5242880, // max body size (body will be cut after that)\n    \"autoClean\": true, // cleanup older keys when all bigger than maxSize\n    \"filter\": { // cache only for some status, method and paths\n      \"statuses\": [],\n      \"methods\": [],\n      \"paths\": [],\n      \"not\": {\n        \"statuses\": [],\n        \"methods\": [],\n        \"paths\": []\n      }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ResponseCache\" : {\n    \"enabled\" : true,\n    \"ttl\" : 3600000,\n    \"maxSize\" : 52428800,\n    \"autoClean\" : true,\n    \"filter\" : {\n      \"statuses\" : [ ],\n      \"methods\" : [ ],\n      \"paths\" : [ ],\n      \"not\" : {\n        \"statuses\" : [ ],\n        \"methods\" : [ ],\n        \"paths\" : [ ]\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Client certificate header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ClientCertChain`\n\n### Description\n\nThis plugin pass client certificate informations to the target in headers.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ClientCertChain\": {\n    \"pem\": { // send client cert as PEM format in a header\n      \"send\": false,\n      \"header\": \"X-Client-Cert-Pem\"\n    },\n    \"dns\": { // send JSON array of DNs in a header\n      \"send\": false,\n      \"header\": \"X-Client-Cert-DNs\"\n    },\n    \"chain\": { // send JSON representation of client cert chain in a header\n      \"send\": true,\n      \"header\": \"X-Client-Cert-Chain\"\n    },\n    \"claims\": { // pass JSON representation of client cert chain in the otoroshi JWT token\n      \"send\": false,\n      \"name\": \"clientCertChain\"\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ClientCertChain\" : {\n    \"pem\" : {\n      \"send\" : false,\n      \"header\" : \"X-Client-Cert-Pem\"\n    },\n    \"dns\" : {\n      \"send\" : false,\n      \"header\" : \"X-Client-Cert-DNs\"\n    },\n    \"chain\" : {\n      \"send\" : true,\n      \"header\" : \"X-Client-Cert-Chain\"\n    },\n    \"claims\" : {\n      \"send\" : false,\n      \"name\" : \"clientCertChain\"\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Defer Responses\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `DeferPlugin`\n\n### Description\n\nThis plugin will expect a `X-Defer` header or a `defer` query param and defer the response according to the value in milliseconds.\nThis plugin is some kind of inside joke as one a our customer ask us to make slower apis.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"DeferPlugin\": {\n    \"defaultDefer\": 0 // default defer in millis\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"DeferPlugin\" : {\n    \"defaultDefer\" : 0\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Self registration endpoints (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin add support for self registration endpoint on a specific service.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Envoy Control Plane (experimental)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `EnvoyControlPlane`\n\n### Description\n\nThis plugin will expose the otoroshi state to envoy instances using the xDS V3 API`.\n\nRight now, all the features of otoroshi cannot be exposed as is through Envoy.\n\n\n\n### Default configuration\n\n```json\n{\n  \"EnvoyControlPlane\" : {\n    \"enabled\" : true\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Geolocation endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: ``none``\n\n### Description\n\nThis plugin will expose current geolocation informations on the following endpoint.\n\n`/.well-known/otoroshi/plugins/geolocation`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Geolocation header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `GeolocationInfoHeader`\n\n### Description\n\nThis plugin will send informations extracted by the Geolocation details extractor to the target service in a header.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfoHeader\": {\n    \"headerName\": \"X-Geolocation-Info\" // header in which info will be sent\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfoHeader\" : {\n    \"headerName\" : \"X-Geolocation-Info\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## HMAC caller plugin\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `HMACCallerPlugin`\n\n### Description\n\nThis plugin can be used to call a \"protected\" api by an HMAC signature. It will adds a signature with the secret configured on the plugin.\n The signature string will always the content of the header list listed in the plugin configuration.\n\n\n\n### Default configuration\n\n```json\n{\n  \"HMACCallerPlugin\" : {\n    \"secret\" : \"my-defaut-secret\",\n    \"algo\" : \"HMAC-SHA512\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Izanami Canary Campaign\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `IzanamiCanary`\n\n### Description\n\nThis plugin allow you to perform canary testing based on an izanami experiment campaign (A/B test).\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"IzanamiCanary\" : {\n    \"experimentId\" : \"foo:bar:qix\",\n    \"configId\" : \"foo:bar:qix:config\",\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000,\n    \"mtls\" : {\n      \"certs\" : [ ],\n      \"trustedCerts\" : [ ],\n      \"mtls\" : false,\n      \"loose\" : false,\n      \"trustAll\" : false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"IzanamiCanary\" : {\n    \"experimentId\" : \"foo:bar:qix\",\n    \"configId\" : \"foo:bar:qix:config\",\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000,\n    \"mtls\" : {\n      \"certs\" : [ ],\n      \"trustedCerts\" : [ ],\n      \"mtls\" : false,\n      \"loose\" : false,\n      \"trustAll\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Izanami APIs Proxy\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `IzanamiProxy`\n\n### Description\n\nThis plugin exposes routes to proxy Izanami configuration and features tree APIs.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"IzanamiProxy\" : {\n    \"path\" : \"/api/izanami\",\n    \"featurePattern\" : \"*\",\n    \"configPattern\" : \"*\",\n    \"autoContext\" : false,\n    \"featuresEnabled\" : true,\n    \"featuresWithContextEnabled\" : true,\n    \"configurationEnabled\" : false,\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"IzanamiProxy\" : {\n    \"path\" : \"/api/izanami\",\n    \"featurePattern\" : \"*\",\n    \"configPattern\" : \"*\",\n    \"autoContext\" : false,\n    \"featuresEnabled\" : true,\n    \"featuresWithContextEnabled\" : true,\n    \"configurationEnabled\" : false,\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Html Patcher\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `HtmlPatcher`\n\n### Description\n\nThis plugin can inject elements in html pages (in the body or in the head) returned by the service\n\n\n\n### Default configuration\n\n```json\n{\n  \"HtmlPatcher\" : {\n    \"appendHead\" : [ ],\n    \"appendBody\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Body logger\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `BodyLogger`\n\n### Description\n\nThis plugin can log body present in request and response. It can just logs it, store in in the redis store with a ttl and send it to analytics.\nIt also provides a debug UI at `/.well-known/otoroshi/bodylogger`.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"BodyLogger\": {\n    \"enabled\": true, // enabled logging\n    \"log\": true, // just log it\n    \"store\": false, // store bodies in datastore\n    \"ttl\": 300000,  // store it for some times (5 minutes by default)\n    \"sendToAnalytics\": false, // send bodies to analytics\n    \"maxSize\": 5242880, // max body size (body will be cut after that)\n    \"password\": \"password\", // password for the ui, if none, it's public\n    \"filter\": { // log only for some status, method and paths\n      \"statuses\": [],\n      \"methods\": [],\n      \"paths\": [],\n      \"not\": {\n        \"statuses\": [],\n        \"methods\": [],\n        \"paths\": []\n      }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"BodyLogger\" : {\n    \"enabled\" : true,\n    \"log\" : true,\n    \"store\" : false,\n    \"ttl\" : 300000,\n    \"sendToAnalytics\" : false,\n    \"maxSize\" : 5242880,\n    \"password\" : \"password\",\n    \"filter\" : {\n      \"statuses\" : [ ],\n      \"methods\" : [ ],\n      \"paths\" : [ ],\n      \"not\" : {\n        \"statuses\" : [ ],\n        \"methods\" : [ ],\n        \"paths\" : [ ]\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Prometheus Service Metrics\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `PrometheusServiceMetrics`\n\n### Description\n\nThis plugin collects service metrics and can be used with the `Prometheus Endpoint` (in the Danger Zone) plugin to expose those metrics\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"PrometheusServiceMetrics\": {\n    \"includeUri\": false // include http uri in metrics. WARNING this could impliess performance issues, use at your own risks\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"PrometheusServiceMetrics\" : {\n    \"includeUri\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Service Metrics\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ServiceMetrics`\n\n### Description\n\nThis plugin expose service metrics in Otoroshi global metrics or on a special URL of the service `/.well-known/otoroshi/metrics`.\nMetrics are exposed in json or prometheus format depending on the accept header. You can protect it with an access key defined in the configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ServiceMetrics\": {\n    \"accessKeyValue\": \"secret\", // if not defined, public access. Can be ${config.app.health.accessKey}\n    \"accessKeyQuery\": \"access_key\"\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ServiceMetrics\" : {\n    \"accessKeyValue\" : \"${config.app.health.accessKey}\",\n    \"accessKeyQuery\" : \"access_key\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Mirroring plugin\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `MirroringPlugin`\n\n### Description\n\nThis plugin will mirror every request to other targets\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"MirroringPlugin\": {\n    \"enabled\": true, // enabled mirroring\n    \"to\": \"https://foo.bar.dev\", // the url of the service to mirror\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"MirroringPlugin\" : {\n    \"enabled\" : true,\n    \"to\" : \"https://foo.bar.dev\",\n    \"captureResponse\" : false,\n    \"generateEvents\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OAuth1 caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OAuth1Caller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using OAuth1.\n Consumer key, secret, and OAuth token et OAuth token secret can be pass through the metadata of an api key\n or via the configuration of this plugin.\n\n\n\n### Default configuration\n\n```json\n{\n  \"OAuth1Caller\" : {\n    \"algo\" : \"HmacSHA512\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OIDC headers\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OIDCHeaders`\n\n### Description\n\nThis plugin injects headers containing tokens and profile from current OIDC provider.\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCHeaders\" : {\n    \"profile\" : {\n      \"send\" : true,\n      \"headerName\" : \"X-OIDC-User\"\n    },\n    \"idtoken\" : {\n      \"send\" : false,\n      \"name\" : \"id_token\",\n      \"headerName\" : \"X-OIDC-Id-Token\",\n      \"jwt\" : true\n    },\n    \"accesstoken\" : {\n      \"send\" : false,\n      \"name\" : \"access_token\",\n      \"headerName\" : \"X-OIDC-Access-Token\",\n      \"jwt\" : true\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Security Txt\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `SecurityTxt`\n\n### Description\n\nThis plugin exposes a special route `/.well-known/security.txt` as proposed at [https://securitytxt.org/](https://securitytxt.org/).\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"SecurityTxt\": {\n    \"Contact\": \"contact@foo.bar\", // mandatory, a link or e-mail address for people to contact you about security issues\n    \"Encryption\": \"http://url-to-public-key\", // optional, a link to a key which security researchers should use to securely talk to you\n    \"Acknowledgments\": \"http://url\", // optional, a link to a web page where you say thank you to security researchers who have helped you\n    \"Preferred-Languages\": \"en, fr, es\", // optional\n    \"Policy\": \"http://url\", // optional, a link to a policy detailing what security researchers should do when searching for or reporting security issues\n    \"Hiring\": \"http://url\", // optional, a link to any security-related job openings in your organisation\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"SecurityTxt\" : {\n    \"Contact\" : \"contact@foo.bar\",\n    \"Encryption\" : \"https://...\",\n    \"Acknowledgments\" : \"https://...\",\n    \"Preferred-Languages\" : \"en, fr\",\n    \"Policy\" : \"https://...\",\n    \"Hiring\" : \"https://...\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Static Response\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `StaticResponse`\n\n### Description\n\nThis plugin returns a static response for any request\n\n\n\n### Default configuration\n\n```json\n{\n  \"StaticResponse\" : {\n    \"status\" : 200,\n    \"headers\" : {\n      \"Content-Type\" : \"application/json\"\n    },\n    \"body\" : \"{\\\"message\\\":\\\"hello world!\\\"}\",\n    \"bodyBase64\" : null\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## User-Agent endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: ``none``\n\n### Description\n\nThis plugin will expose current user-agent informations on the following endpoint.\n\n`/.well-known/otoroshi/plugins/user-agent`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## User-Agent header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `UserAgentInfoHeader`\n\n### Description\n\nThis plugin will sent informations extracted by the User-Agent details extractor to the target service in a header.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"UserAgentInfoHeader\": {\n    \"headerName\": \"X-User-Agent-Info\" // header in which info will be sent\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"UserAgentInfoHeader\" : {\n    \"headerName\" : \"X-User-Agent-Info\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Workflow endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `WorkflowEndpoint`\n\n### Description\n\nThis plugin runs a workflow and return the response\n\n\n\n### Default configuration\n\n```json\n{\n  \"WorkflowEndpoint\" : {\n    \"workflow\" : { }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Biscuit token validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nThis plugin validates a Biscuit token.\n\n\n\n### Default configuration\n\n```json\n{\n  \"publicKey\" : \"xxxxxx\",\n  \"secret\" : \"secret\",\n  \"checks\" : [ ],\n  \"facts\" : [ ],\n  \"resources\" : [ ],\n  \"rules\" : [ ],\n  \"revocation_ids\" : [ ],\n  \"enforce\" : false,\n  \"sealed\" : false,\n  \"extractor\" : {\n    \"type\" : \"header\",\n    \"name\" : \"Authorization\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client Certificate + Api Key only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nCheck if a client certificate is present in the request and that the apikey used matches the client certificate.\nYou can set the client cert. DN in an apikey metadata named `allowed-client-cert-dn`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client certificate matching (over http)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasClientCertMatchingHttpValidator`\n\n### Description\n\nCheck if client certificate matches the following configuration\n\nexpected response from http service is\n\n```json\n{\n  \"serialNumbers\": [],   // allowed certificated serial numbers\n  \"subjectDNs\": [],      // allowed certificated DNs\n  \"issuerDNs\": [],       // allowed certificated issuer DNs\n  \"regexSubjectDNs\": [], // allowed certificated DNs matching regex\n  \"regexIssuerDNs\": [],  // allowed certificated issuer DNs matching regex\n}\n```\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\": {\n    \"url\": \"...\",   // url for the call\n    \"headers\": {},  // http header for the call\n    \"ttl\": 600000,  // cache ttl,\n    \"mtlsConfig\": {\n      \"certId\": \"xxxxx\",\n       \"mtls\": false,\n       \"loose\": false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasClientCertMatchingHttpValidator\" : {\n    \"url\" : \"http://foo.bar\",\n    \"ttl\" : 600000,\n    \"headers\" : { },\n    \"mtlsConfig\" : {\n      \"certId\" : \"...\",\n      \"mtls\" : false,\n      \"loose\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client certificate matching\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasClientCertMatchingValidator`\n\n### Description\n\nCheck if client certificate matches the following configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\": {\n    \"serialNumbers\": [],   // allowed certificated serial numbers\n    \"subjectDNs\": [],      // allowed certificated DNs\n    \"issuerDNs\": [],       // allowed certificated issuer DNs\n    \"regexSubjectDNs\": [], // allowed certificated DNs matching regex\n    \"regexIssuerDNs\": [],  // allowed certificated issuer DNs matching regex\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\" : {\n    \"serialNumbers\" : [ ],\n    \"subjectDNs\" : [ ],\n    \"issuerDNs\" : [ ],\n    \"regexSubjectDNs\" : [ ],\n    \"regexIssuerDNs\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client Certificate Only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nCheck if a client certificate is present in the request\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## External Http Validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `ExternalHttpValidator`\n\n### Description\n\nCalls an external http service to know if a user has access or not. Uses cache for performances.\n\nThe sent payload is the following:\n\n```json\n{\n  \"apikey\": {...},\n  \"user\": {...},\n  \"service\": : {...},\n  \"chain\": \"...\",  // PEM cert chain\n  \"fingerprints\": [...]\n}\n```\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ExternalHttpValidator\": {\n    \"url\": \"...\",                      // url for the http call\n    \"host\": \"...\",                     // value of the host header for the call. default is host of the url\n    \"goodTtl\": 600000,                 // ttl in ms for a validated call\n    \"badTtl\": 60000,                   // ttl in ms for a not validated call\n    \"method\": \"POST\",                  // http methode\n    \"path\": \"/certificates/_validate\", // http uri path\n    \"timeout\": 10000,                  // http call timeout\n    \"noCache\": false,                  // use cache or not\n    \"allowNoClientCert\": false,        //\n    \"headers\": {},                      // headers for the http call if needed\n    \"mtlsConfig\": {\n      \"certId\": \"xxxxx\",\n       \"mtls\": false,\n       \"loose\": false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ExternalHttpValidator\" : {\n    \"url\" : \"http://foo.bar\",\n    \"host\" : \"api.foo.bar\",\n    \"goodTtl\" : 600000,\n    \"badTtl\" : 60000,\n    \"method\" : \"POST\",\n    \"path\" : \"/certificates/_validate\",\n    \"timeout\" : 10000,\n    \"noCache\" : false,\n    \"allowNoClientCert\" : false,\n    \"headers\" : { },\n    \"mtlsConfig\" : {\n      \"certId\" : \"...\",\n      \"mtls\" : false,\n      \"loose\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## HMAC access validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HMACAccessValidator`\n\n### Description\n\nThis plugin can be used to check if a HMAC signature is present and valid in Authorization header.\n\n\n\n### Default configuration\n\n```json\n{\n  \"HMACAccessValidator\" : {\n    \"secret\" : \"\"\n  }\n}\n```\n\n\n\n### Documentation\n\n\n The HMAC signature needs to be set on the `Authorization` or `Proxy-Authorization` header.\n The format of this header should be : `hmac algorithm=\"<ALGORITHM>\", headers=\"<HEADER>\", signature=\"<SIGNATURE>\"`\n As example, a simple nodeJS call with the expected header\n ```js\n const crypto = require('crypto');\n const fetch = require('node-fetch');\n\n const date = new Date()\n const secret = \"my-secret\" // equal to the api key secret by default\n\n const algo = \"sha512\"\n const signature = crypto.createHmac(algo, secret)\n    .update(date.getTime().toString())\n    .digest('base64');\n\n fetch('http://myservice.oto.tools:9999/api/test', {\n    headers: {\n        \"Otoroshi-Client-Id\": \"my-id\",\n        \"Otoroshi-Client-Secret\": \"my-secret\",\n        \"Date\": date.getTime().toString(),\n        \"Authorization\": `hmac algorithm=\"hmac-${algo}\", headers=\"Date\", signature=\"${signature}\"`,\n        \"Accept\": \"application/json\"\n    }\n })\n    .then(r => r.json())\n    .then(console.log)\n ```\n In this example, we have an Otoroshi service deployed on http://myservice.oto.tools:9999/api/test, protected by api keys.\n The secret used is the secret of the api key (by default, but you can change it and define a secret on the plugin configuration).\n We send the base64 encoded date of the day, signed by the secret, in the Authorization header. We specify the headers signed and the type of algorithm used.\n You can sign more than one header but you have to list them in the headers fields (each one separate by a space, example : headers=\"Date KeyId\").\n The algorithm used can be HMAC-SHA1, HMAC-SHA256, HMAC-SHA384 or HMAC-SHA512.\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## OIDC access_token validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `OIDCAccessTokenValidator`\n\n### Description\n\nThis plugin will use the third party apikey configuration and apply it while keeping the apikey mecanism of otoroshi.\nUse it to combine apikey validation and OIDC access_token validation.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\": {\n    \"enabled\": true,\n    \"atLeastOne\": false,\n    // config is optional and can be either an object config or an array of objects\n    \"config\": {\n  \"enabled\" : true,\n  \"quotasEnabled\" : true,\n  \"uniqueApiKey\" : false,\n  \"type\" : \"OIDC\",\n  \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n  \"localVerificationOnly\" : false,\n  \"mode\" : \"Tmp\",\n  \"ttl\" : 0,\n  \"headerName\" : \"Authorization\",\n  \"throttlingQuota\" : 100,\n  \"dailyQuota\" : 10000000,\n  \"monthlyQuota\" : 10000000,\n  \"excludedPatterns\" : [ ],\n  \"scopes\" : [ ],\n  \"rolesPath\" : [ ],\n  \"roles\" : [ ]\n}\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\" : {\n    \"enabled\" : true,\n    \"atLeastOne\" : false,\n    \"config\" : {\n      \"enabled\" : true,\n      \"quotasEnabled\" : true,\n      \"uniqueApiKey\" : false,\n      \"type\" : \"OIDC\",\n      \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n      \"localVerificationOnly\" : false,\n      \"mode\" : \"Tmp\",\n      \"ttl\" : 0,\n      \"headerName\" : \"Authorization\",\n      \"throttlingQuota\" : 100,\n      \"dailyQuota\" : 10000000,\n      \"monthlyQuota\" : 10000000,\n      \"excludedPatterns\" : [ ],\n      \"scopes\" : [ ],\n      \"rolesPath\" : [ ],\n      \"roles\" : [ ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Instance quotas\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `InstanceQuotas`\n\n### Description\n\nThis plugin will enforce global quotas on the current instance\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"InstanceQuotas\": {\n    \"callsPerDay\": -1,     // max allowed api calls per day\n    \"callsPerMonth\": -1,   // max allowed api calls per month\n    \"maxDescriptors\": -1,  // max allowed service descriptors\n    \"maxApiKeys\": -1,      // max allowed apikeys\n    \"maxGroups\": -1,       // max allowed service groups\n    \"maxScripts\": -1,      // max allowed apikeys\n    \"maxCertificates\": -1, // max allowed certificates\n    \"maxVerifiers\": -1,    // max allowed jwt verifiers\n    \"maxAuthModules\": -1,  // max allowed auth modules\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"InstanceQuotas\" : {\n    \"callsPerDay\" : -1,\n    \"callsPerMonth\" : -1,\n    \"maxDescriptors\" : -1,\n    \"maxApiKeys\" : -1,\n    \"maxGroups\" : -1,\n    \"maxScripts\" : -1,\n    \"maxCertificates\" : -1,\n    \"maxVerifiers\" : -1,\n    \"maxAuthModules\" : -1\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Public quotas\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `ServiceQuotas`\n\n### Description\n\nThis plugin will enforce public quotas on the current service\n\n\n\n\n\n\n\n### Default configuration\n\n```json\n{\n  \"ServiceQuotas\" : {\n    \"throttlingQuota\" : 100,\n    \"dailyQuota\" : 10000000,\n    \"monthlyQuota\" : 10000000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Allowed users only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasAllowedUsersValidator`\n\n### Description\n\nThis plugin only let allowed users pass\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasAllowedUsersValidator\": {\n    \"usernames\": [],   // allowed usernames\n    \"emails\": [],      // allowed user email addresses\n    \"emailDomains\": [], // allowed user email domains\n    \"metadataMatch\": [], // json path expressions to match against user metadata. passes if one match\n    \"metadataNotMatch\": [], // json path expressions to match against user metadata. passes if none match\n    \"profileMatch\": [], // json path expressions to match against user profile. passes if one match\n    \"profileNotMatch\": [], // json path expressions to match against user profile. passes if none match\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasAllowedUsersValidator\" : {\n    \"usernames\" : [ ],\n    \"emails\" : [ ],\n    \"emailDomains\" : [ ],\n    \"metadataMatch\" : [ ],\n    \"metadataNotMatch\" : [ ],\n    \"profileMatch\" : [ ],\n    \"profileNotMatch\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Apikey auth module\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `ApikeyAuthModule`\n\n### Description\n\nThis plugin adds basic auth on service where credentials are valid apikeys on the current service.\n\n\n\n### Default configuration\n\n```json\n{\n  \"ApikeyAuthModule\" : {\n    \"realm\" : \"apikey-auth-module-realm\",\n    \"noneTagIn\" : [ ],\n    \"oneTagIn\" : [ ],\n    \"allTagsIn\" : [ ],\n    \"noneMetaIn\" : [ ],\n    \"oneMetaIn\" : [ ],\n    \"allMetaIn\" : [ ],\n    \"noneMetaKeysIn\" : [ ],\n    \"oneMetaKeyIn\" : [ ],\n    \"allMetaKeysIn\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Client certificate as apikey\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `CertificateAsApikey`\n\n### Description\n\nThis plugin uses client certificate as an apikey. The apikey will be stored for classic apikey usage\n\n\n\n### Default configuration\n\n```json\n{\n  \"CertificateAsApikey\" : {\n    \"readOnly\" : false,\n    \"allowClientIdOnly\" : false,\n    \"throttlingQuota\" : 100,\n    \"dailyQuota\" : 10000000,\n    \"monthlyQuota\" : 10000000,\n    \"constrainedServicesOnly\" : false,\n    \"tags\" : [ ],\n    \"metadata\" : { }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Client Credential Flow ApiKey extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: ``none``\n\n### Description\n\nThis plugin can extract an apikey from an opaque access_token generate by the `ClientCredentialFlow` plugin\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Apikey from Biscuit token extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: ``none``\n\n### Description\n\nThis plugin extract an from a Biscuit token where the biscuit has an #authority fact 'client_id' containing\napikey client_id and an #authority fact 'client_sign' that is the HMAC256 signature of the apikey client_id with the apikey client_secret\n\n\n\n### Default configuration\n\n```json\n{\n  \"publicKey\" : \"xxxxxx\",\n  \"secret\" : \"secret\",\n  \"checks\" : [ ],\n  \"facts\" : [ ],\n  \"resources\" : [ ],\n  \"rules\" : [ ],\n  \"revocation_ids\" : [ ],\n  \"enforce\" : false,\n  \"sealed\" : false,\n  \"extractor\" : {\n    \"type\" : \"header\",\n    \"name\" : \"Authorization\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Service discovery target selector (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin select a target in the pool of discovered targets for this service.\nUse in combination with either `DiscoverySelfRegistrationSink` or `DiscoverySelfRegistrationTransformer` to make it work using the `self registration` pattern.\nOr use an implementation of `DiscoveryJob` for the `third party registration pattern`.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Geolocation details extractor (using IpStack api)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `GeolocationInfo`\n\n### Description\n\nThis plugin extract geolocation informations from ip address using the [IpStack dbs](https://ipstack.com/).\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfo\": {\n    \"apikey\": \"xxxxxxx\",\n    \"timeout\": 2000, // timeout in ms\n    \"log\": false // will log geolocation details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfo\" : {\n    \"apikey\" : \"xxxxxxx\",\n    \"timeout\" : 2000,\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Geolocation details extractor (using Maxmind db)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `GeolocationInfo`\n\n### Description\n\nThis plugin extract geolocation informations from ip address using the [Maxmind dbs](https://www.maxmind.com/en/geoip2-databases).\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfo\": {\n    \"path\": \"/foo/bar/cities.mmdb\", // file path, can be \"global\"\n    \"log\": false // will log geolocation details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfo\" : {\n    \"path\" : \"global\",\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Jwt user extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `JwtUserExtractor`\n\n### Description\n\nThis plugin extract a user from a JWT token\n\n\n\n### Default configuration\n\n```json\n{\n  \"JwtUserExtractor\" : {\n    \"verifier\" : \"\",\n    \"strict\" : true,\n    \"namePath\" : \"name\",\n    \"emailPath\" : \"email\",\n    \"metaPath\" : null\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## OIDC access_token as apikey\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `OIDCAccessTokenAsApikey`\n\n### Description\n\nThis plugin will use the third party apikey configuration to generate an apikey\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\": {\n    \"enabled\": true,\n    \"atLeastOne\": false,\n    // config is optional and can be either an object config or an array of objects\n    \"config\": {\n  \"enabled\" : true,\n  \"quotasEnabled\" : true,\n  \"uniqueApiKey\" : false,\n  \"type\" : \"OIDC\",\n  \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n  \"localVerificationOnly\" : false,\n  \"mode\" : \"Tmp\",\n  \"ttl\" : 0,\n  \"headerName\" : \"Authorization\",\n  \"throttlingQuota\" : 100,\n  \"dailyQuota\" : 10000000,\n  \"monthlyQuota\" : 10000000,\n  \"excludedPatterns\" : [ ],\n  \"scopes\" : [ ],\n  \"rolesPath\" : [ ],\n  \"roles\" : [ ]\n}\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCAccessTokenAsApikey\" : {\n    \"enabled\" : true,\n    \"atLeastOne\" : false,\n    \"config\" : {\n      \"enabled\" : true,\n      \"quotasEnabled\" : true,\n      \"uniqueApiKey\" : false,\n      \"type\" : \"OIDC\",\n      \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n      \"localVerificationOnly\" : false,\n      \"mode\" : \"Tmp\",\n      \"ttl\" : 0,\n      \"headerName\" : \"Authorization\",\n      \"throttlingQuota\" : 100,\n      \"dailyQuota\" : 10000000,\n      \"monthlyQuota\" : 10000000,\n      \"excludedPatterns\" : [ ],\n      \"scopes\" : [ ],\n      \"rolesPath\" : [ ],\n      \"roles\" : [ ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## User-Agent details extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `UserAgentInfo`\n\n### Description\n\nThis plugin extract informations from User-Agent header such as browsser version, OS version, etc.\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"UserAgentInfo\": {\n    \"log\": false // will log user-agent details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"UserAgentInfo\" : {\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Client Credential Service\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `ClientCredentialService`\n\n### Description\n\nThis plugin add an an oauth client credentials service (`https://unhandleddomain/.well-known/otoroshi/oauth/token`) to create an access_token given a client id and secret.\n\n```json\n{\n  \"ClientCredentialService\" : {\n    \"domain\" : \"*\",\n    \"expiration\" : 3600000,\n    \"defaultKeyPair\" : \"otoroshi-jwt-signing\",\n    \"secure\" : true\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ClientCredentialService\" : {\n    \"domain\" : \"*\",\n    \"expiration\" : 3600000,\n    \"defaultKeyPair\" : \"otoroshi-jwt-signing\",\n    \"secure\" : true\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Global self registration endpoints (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin add support for self registration endpoint on specific hostnames.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Kubernetes admission validator webhook\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: ``none``\n\n### Description\n\nThis plugin exposes a webhook to kubernetes to handle manifests validation\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Kubernetes sidecar injector webhook\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: ``none``\n\n### Description\n\nThis plugin exposes a webhook to kubernetes to inject otoroshi-sidecar in pods\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Prometheus Endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `PrometheusEndpoint`\n\n### Description\n\nThis plugin exposes metrics collected by `Prometheus Service Metrics` on a `/prometheus` endpoint.\nYou can protect it with an access key defined in the configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"PrometheusEndpoint\": {\n    \"accessKeyValue\": \"secret\", // if not defined, public access. Can be ${config.app.health.accessKey}\n    \"accessKeyQuery\": \"access_key\",\n    \"includeMetrics\": false\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"PrometheusEndpoint\" : {\n    \"accessKeyValue\" : \"${config.app.health.accessKey}\",\n    \"accessKeyQuery\" : \"access_key\",\n    \"includeMetrics\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes Ingress Controller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin enables Otoroshi as an Ingress Controller\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes Otoroshi CRDs Controller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin enables Otoroshi CRDs Controller\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes to Otoroshi certs. synchronizer\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin syncs. TLS secrets from Kubernetes to Otoroshi\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Otoroshi certs. to Kubernetes secrets synchronizer\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin syncs. Otoroshi certs to Kubernetes TLS secrets\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Workflow job\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `WorkflowJob`\n\n### Description\n\nPeriodically run a custom workflow\n\n\n\n### Default configuration\n\n```json\n{\n  \"WorkflowJob\" : {\n    \"input\" : {\n      \"namespace\" : \"otoroshi\",\n      \"service\" : \"otoroshi-dns\"\n    },\n    \"intervalMillis\" : \"60000\",\n    \"workflow\" : {\n      \"name\" : \"some-workflow\",\n      \"description\" : \"a nice workflow\",\n      \"tasks\" : [ {\n        \"name\" : \"call-dns\",\n        \"type\" : \"http\",\n        \"request\" : {\n          \"method\" : \"PATCH\",\n          \"url\" : \"http://${env.KUBERNETES_SERVICE_HOST}:${env.KUBERNETES_SERVICE_PORT}/apis/v1/namespaces/${input.namespace}/services/${input.service}\",\n          \"headers\" : {\n            \"accept\" : \"application/json\",\n            \"content-type\" : \"application/json\",\n            \"authorization\" : \"Bearer ${file:///var/run/secrets/kubernetes.io/serviceaccount/token}\"\n          },\n          \"tls\" : {\n            \"mtls\" : true,\n            \"trustAll\" : true\n          },\n          \"body\" : [ {\n            \"op\" : \"replace\",\n            \"path\" : \"/spec/selector\",\n            \"value\" : {\n              \"app\" : \"otoroshi\",\n              \"component\" : \"dns\"\n            }\n          } ]\n        },\n        \"success\" : {\n          \"statuses\" : [ 200 ]\n        }\n      } ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n\n\n"
  },
  {
    "name": "create-plugins.md",
    "id": "/plugins/create-plugins.md",
    "url": "/plugins/create-plugins.html",
    "title": "Create plugins",
    "content": "# Create plugins\n\n@@@ warning\nThis section is under rewrite. The following content is deprecated\n@@@\n\nWhen everything has failed and you absolutely need a feature in Otoroshi to make your use case work, there is a solution. Plugins is the feature in Otoroshi that allow you to code how Otoroshi should behave when receiving, validating and routing an http request. With request plugin, you can change request / response headers and request / response body the way you want, provide your own apikey, etc.\n\n## Plugin types\n\nthere are many plugin types\n\n* `request sinks` plugins: used when no services are matched in otoroshi. Can reply with any content\n* `pre-routes` plugins: used to extract values (like custom apikeys) and provide them to other plugins or otoroshi engine\n* `access validation` plugins: used to validate if a request can pass or not based on whatever you want\n* `request transformer` plugins: used to transform request, responses and their body. Can be used to return arbitrary content\n* `event listener` plugins: any plugin type can listen to otoroshi internal events and react to thems\n* `job` plugins: tasks taht can run automatically once, on be scheduled with a cron expression or every defined interval\n\n## Code and signatures\n\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/requestsink.scala#L14-L19\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/routing.scala#L75-L78\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/accessvalidator.scala#L65-L85\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/script.scala#269-L540\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/eventlistener.scala#L27-L48\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/job.scala#L69-L164\n* https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/script/job.scala#L108-L110\n\n\nfor more information about APIs you can use\n\n* https://www.playframework.com/documentation/2.8.x/api/scala/index.html#package\n* https://www.playframework.com/documentation/2.8.x/api/scala/index.html#play.api.mvc.Results\n* https://github.com/MAIF/otoroshi\n* https://doc.akka.io/docs/akka/2.5/stream/index.html\n* https://doc.akka.io/api/akka/current/akka/stream/index.html\n* https://doc.akka.io/api/akka/current/akka/stream/scaladsl/Source.html\n\n## Plugin examples\n\n@ref:[A lot of plugins](./built-in-plugins.md) comes with otoroshi, you can find them on [github](https://github.com/MAIF/otoroshi/tree/master/otoroshi/app/plugins)\n\n## Writing a plugin from Otoroshi UI\n\nLog into Otoroshi and go to `Settings (cog icon) / Plugins`. Here you can create multiple request transformer scripts and associate it with service descriptor later.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/scripts-1.png\" />\n@@@\n\nwhen you write for instance a transformer in the Otoroshi UI, do the following\n\n```scala\nimport akka.stream.Materializer\nimport env.Env\nimport models.{ApiKey, PrivateAppsUser, ServiceDescriptor}\nimport otoroshi.script._\nimport play.api.Logger\nimport play.api.mvc.{Result, Results}\nimport scala.util._\nimport scala.concurrent.{ExecutionContext, Future}\n\nclass MyTransformer extends RequestTransformer {\n\n  val logger = Logger(\"my-transformer\")\n\n  // implements the methods you want\n}\n\n// WARN: do not forget this line to provide a working instance of your transformer to Otoroshi\nnew MyTransformer()\n```\n\nYou can use the compile button to check if the script compiles, or code the transformer in your IDE (see next point).\n\nThen go to a service descriptor, scroll to the bottom of the page, and select your transformer in the list\n\n@@@ div { .centered-img }\n<img src=\"../imgs/scripts-2.png\" />\n@@@\n\n## Providing a transformer from Java classpath\n\nYou can write your own transformer using your favorite IDE. Just create an SBT project with the following dependencies. It can be quite handy to manage the source code like any other piece of code, and it avoid the compilation time for the script at Otoroshi startup.\n\n```scala\nlazy val root = (project in file(\".\")).\n  settings(\n    inThisBuild(List(\n      organization := \"com.example\",\n      scalaVersion := \"2.12.7\",\n      version      := \"0.1.0-SNAPSHOT\"\n    )),\n    name := \"request-transformer-example\",\n    libraryDependencies += \"fr.maif\" %% \"otoroshi\" % \"1.x.x\"\n  )\n```\n\n@@@ warning\nyou MUST provide plugins that lies in the `otoroshi_plugins` package or in a sub-package of `otoroshi_plugins`. If you do not, your plugin will not be found by otoroshi. for example\n\n```scala\npackage otoroshi_plugins.com.my.company.myplugin\n```\n\nalso you don't have to instanciate your plugin at the end of the file like in the Otoroshi UI\n@@@\n\nWhen your code is ready, create a jar file \n\n```\nsbt package\n```\n\nand add the jar file to the Otoroshi classpath\n\n```sh\njava -cp \"/path/to/transformer.jar:$/path/to/otoroshi.jar\" play.core.server.ProdServerStart\n```\n\nthen, in your service descriptor, you can chose your transformer in the list. If you want to do it from the API, you have to defined the transformerRef using `cp:` prefix like \n\n```json\n{\n  \"transformerRef\": \"cp:otoroshi_plugins.my.class.package.MyTransformer\"\n}\n```\n\n## Getting custom configuration from the Otoroshi config. file\n\nLet say you need to provide custom configuration values for a script, then you can customize a configuration file of Otoroshi\n\n```hocon\ninclude \"application.conf\"\n\notoroshi {\n  scripts {\n    enabled = true\n  }\n}\n\nmy-transformer {\n  env = \"prod\"\n  maxRequestBodySize = 2048\n  maxResponseBodySize = 2048\n}\n```\n\nthen start Otoroshi like\n\n```sh\njava -Dconfig.file=/path/to/custom.conf -jar otoroshi.jar\n```\n\nthen, in your transformer, you can write something like \n\n```scala\npackage otoroshi_plugins.com.example.otoroshi\n\nimport akka.stream.Materializer\nimport akka.stream.scaladsl._\nimport akka.util.ByteString\nimport env.Env\nimport models.{ApiKey, PrivateAppsUser, ServiceDescriptor}\nimport otoroshi.script._\nimport play.api.Logger\nimport play.api.mvc.{Result, Results}\nimport scala.util._\nimport scala.concurrent.{ExecutionContext, Future}\n\nclass BodyLengthLimiter extends RequestTransformer {\n\n  override def def transformResponseWithCtx(ctx: TransformerResponseContext)(implicit env: Env, ec: ExecutionContext, mat: Materializer): Source[ByteString, _] = {\n    val max = env.configuration.getOptional[Long](\"my-transformer.maxResponseBodySize\").getOrElse(Long.MaxValue)\n    ctx.body.limitWeighted(max)(_.size)\n  }\n\n  override def transformRequestWithCtx(ctx: TransformerRequestContext)(implicit env: Env, ec: ExecutionContext, mat: Materializer): Source[ByteString, _] = {\n    val max = env.configuration.getOptional[Long](\"my-transformer.maxRequestBodySize\").getOrElse(Long.MaxValue)\n    ctx.body.limitWeighted(max)(_.size)\n  }\n}\n```\n\n## Using a library that is not embedded in Otoroshi\n\nJust use the `classpath` option when running Otoroshi\n\n```sh\njava -cp \"/path/to/library.jar:$/path/to/otoroshi.jar\" play.core.server.ProdServerStart\n```\n\nBe carefull as your library can conflict with other libraries used by Otoroshi and affect its stability\n\n## Enabling plugins\n\nplugins can be enabled per service from the service settings page or globally from the danger zone in the plugins section.\n\n## Full example\n\na full external plugin example can be found @link:[here](https://github.com/mathieuancelin/otoroshi-wasmer-plugin)\n"
  },
  {
    "name": "index.md",
    "id": "/plugins/index.md",
    "url": "/plugins/index.html",
    "title": "Otoroshi plugins",
    "content": "# Otoroshi plugins\n\nIn this sections, you will find informations about Otoroshi plugins system\n\n* @ref:[Plugins system](./plugins.md)\n* @ref:[Create plugins](./create-plugins.md)\n* @ref:[Built in plugins](./built-in-plugins.md)\n\n@@@ index\n\n* [Plugins system](./plugins.md)\n* [Create plugins](./create-plugins.md)\n* [Built in plugins](./built-in-plugins.md)\n\n@@@\n"
  },
  {
    "name": "plugins.md",
    "id": "/plugins/plugins.md",
    "url": "/plugins/plugins.html",
    "title": "Otoroshi plugins system",
    "content": "# Otoroshi plugins system\n\nOtoroshi includes several extension points that allows you to create your own plugins and support stuff not supported by default\n\n## Available plugins\n\n@@@ div { .plugin .script }\n## Request Sink\n### Description\nUsed when no services are matched in Otoroshi. Can reply with any content.\n@@@\n\n@@@ div { .plugin .script }\n## Pre routing\n### Description\nUsed to extract values (like custom apikeys) and provide them to other plugins or Otoroshi engine\n@@@\n\n@@@ div { .plugin .script }\n## Access Validator\n### Description\nUsed to validate if a request can pass or not based on whatever you want\n@@@\n\n@@@ div { .plugin .script }\n## Request Transformer\n### Description\nUsed to transform request, responses and their body. Can be used to return arbitrary content\n@@@\n\n@@@ div { .plugin .script }\n## Event listener\n### Description\nAny plugin type can listen to Otoroshi internal events and react to thems\n@@@\n\n@@@ div { .plugin .script }\n## Job\n### Description\nTasks that can run automatically once, on be scheduled with a cron expression or every defined interval\n@@@\n\n@@@ div { .plugin .script }\n## Exporter\n### Description\nUsed to export events and Otoroshi alerts to an external source\n@@@\n\n@@@ div { .plugin .script }\n## Request handler\n### Description\nUsed to handle traffic without passing through Otoroshi routing and apply own rules\n@@@\n\n@@@ div { .plugin .script }\n## Nano app\n### Description\nUsed to write an api directly in Otoroshi in Scala language\n@@@"
  },
  {
    "name": "chaos-engineering.md",
    "id": "/topics/chaos-engineering.md",
    "url": "/topics/chaos-engineering.html",
    "title": "Chaos engineering with the Snow Monkey",
    "content": "# Chaos engineering with the Snow Monkey\n\nNihonzaru (the Snow Monkey) is the chaos engineering tool provided by Otoroshi. You can access it at `Settings (cog icon) / Snow Monkey`.\n\n@@@ div { .centered-img }\n<img src=\"https://github.com/MAIF/otoroshi/raw/master/resources/nihonzaru-logo.png\" />\n@@@\n\n## Chaos engineering\n\nOtoroshi offers some tools to introduce [chaos engineering](https://principlesofchaos.org/) in your everyday life. With chaos engineering, you will improve the resilience of your architecture by creating faults in production on running systems. With [Nihonzaru (the snow monkey)](https://en.wikipedia.org/wiki/Japanese_macaque) Otoroshi helps you to create faults on http request/response handled by Otoroshi. \n\n@@@ div { .centered-img }\n<img src=\"../imgs/snow-monkey.png\" />\n@@@\n\n## Settings\n\n@@@ div { .centered-img }\n<img src=\"../imgs/snow-monkey-settings.png\" />\n@@@\n\nThe snow monkey let you define a few settings to work properly :\n\n* **Include user facing apps.**: you want to create fault in production, but maybe you don't want your users to enjoy some nice snow monkey generated error pages. Using this switch let you include of not user facing apps (ui apps). Each service descriptor has a `User facing app switch` that will be used by the snow monkey.\n* **Dry run**: when dry run is enabled, outages will be registered and will generate events and alerts (in the otoroshi eventing system) but requests won't be actualy impacted. It's a good way to prepare applications to the snow monkey habits\n* **Outage strategy**: Either `AllServicesPerGroup` or `OneServicePerGroup`. It means that only one service per group or all services per groups will have `n` outages (see next bullet point) during the snow monkey working period\n* **Outages per day**: during snow monkey working period, each service per group or one service per group will have only `n` outages registered \n* **Working period**: the snow monkey only works during a working period. Here you can defined when it starts and when it stops\n* **Outage duration**: here you can defined the bounds for the random outage duration when an outage is created on a service\n* **Impacted groups**: here you can define a list of service groups impacted by the snow monkey. If none is specified, then all service groups will be impacted\n\n## Faults\n\nWith the snow monkey, you can generate four types of faults\n\n* **Large request fault**: Add trailing bytes at the end of the request body (if one)\n* **Large response fault**: Add trailing bytes at the end of the response body\n* **Latency injection fault**: Add random response latency between two bounds\n* **Bad response injection fault**: Create predefined responses with custom headers, body and status code\n\nEach fault let you define a ratio for impacted requests. If you specify a ratio of `0.2`, then 20% of the requests for the impacte service will be impacted by this fault\n\n@@@ div { .centered-img }\n<img src=\"../imgs/snow-monkey-faults.png\" />\n@@@\n\nThen you juste have to start the snow monkey and enjoy the show ;)\n\n@@@ div { .centered-img }\n<img src=\"../imgs/snow-monkey-start.png\" />\n@@@\n\n## Current outages\n\nIn the last section of the snow monkey page, you can see current outages (per service), when they started, their duration, etc ...\n\n@@@ div { .centered-img }\n<img src=\"../imgs/snow-monkey-outages.png\" />\n@@@"
  },
  {
    "name": "dev-portal.md",
    "id": "/topics/dev-portal.md",
    "url": "/topics/dev-portal.html",
    "title": "Developer portal with Daikoku",
    "content": "# Developer portal with Daikoku\n\nWhile Otoroshi is the perfect tool to manage your webapps in a technical point of view it lacked of business perspective. This is not the case anymore with Daikoku.\n\nWhile Otoroshi is a standalone, Daikoku is a developer portal which stands in front of Otoroshi and provides some business feature.\n\nWhether you want to use Daikoku for your public APIs, you want to monetize or with your private APIs to provide some documentation, facilitation and self-service feature, it will be the perfect portal for Otoroshi.\n\n@@@div { .plugin .platform }\n## Daikoku\n\nRun your first Daikoku with a simple jar or with one Docker command.\n\n<img src=\"../imgs/daikoku-logo.png\" />\n<div style=\"font-weight: bold; text-align: center; width: 100%\">\nTry Daikoku \n</div>\n@link:[With jar](https://maif.github.io/daikoku/devmanual/getdaikoku/frombinaries.html)\n@link:[With Docker](https://maif.github.io/daikoku/devmanual/getdaikoku/fromdocker.html)\n@@@\n\n@@@div { .plugin .platform }\n## Contribute\n\nDaikoku is opensource, so all contributions are welcome.\n\n<img src=\"../imgs/opensource.png\" />\n@link:[Show the repository](https://github.com/MAIF/daikoku)\n@@@\n\n@@@div { .plugin .platform }\n## Documentation\n\nDaikoku and its UI are fully documented.\n\n<img src=\"../imgs/documentation.png\" />\n@link:[Read the documentation](https://maif.github.io/daikoku/devmanual/)\n@@@\n\n"
  },
  {
    "name": "events-and-analytics.md",
    "id": "/topics/events-and-analytics.md",
    "url": "/topics/events-and-analytics.html",
    "title": "Events and analytics",
    "content": "# Events and analytics\n\nOtoroshi is a solution fully traced : calls to services, access to UI, creation of resources, etc.\n\n@@@ warning\nYou have to use [Elastic](https://www.elastic.co) to enable analytics features in Otoroshi\n@@@\n\n## Events\n\n* Analytics event\n* Gateway event\n* TCP event\n* Healthcheck event\n\n## Event log\n\nOtoroshi can read his own exported events from an Elasticsearch instance, set up in the danger zone. Theses events are available from the UI, at the following route: `https://xxxxx/bo/dashboard/events`.\n\nThe `Global events` page display all events of **GatewayEvent** type. This page is a way to quickly read an interval of events and can be used in addition of a Kibana instance.\n\nFor each event, a list of information will be displayed and an additional button `content` to watch the full content of the event, at the JSON format. \n\n## Alerts \n\n* `MaxConcurrentRequestReachedAlert`: happening when the handled requests number are greater than the limit of concurrent requests indicated in the global configuration of Otoroshi\n* `CircuitBreakerOpenedAlert`: happening when the circuit breaker pass from closed to opened\n* `CircuitBreakerClosedAlert`: happening when the circuit breaker pass from opened to closed\n* `SessionDiscardedAlert`: send when an admin discarded an admin sessions\n* `SessionsDiscardedAlert`: send when an admin discarded all admin sessions\n* `PanicModeAlert`: send when panic mode is enabled\n* `OtoroshiExportAlert`: send when otoroshi global configuration is exported\n* `U2FAdminDeletedAlert`: send when an admin has deleted an other admin user\n* `BlackListedBackOfficeUserAlert`: send when a blacklisted user has tried to acccess to the UI\n* `AdminLoggedInAlert`: send when an user admin has logged to the UI\n* `AdminFirstLogin`: send when an user admin has successfully logged to the UI for the first time\n* `AdminLoggedOutAlert`: send when an user admin has logged out from Otoroshi\n* `GlobalConfigModification`: send when an user amdin has changed the global configuration of Otoroshi\n* `RevokedApiKeyUsageAlert`: send when an user admin has revoked an apikey\n* `ServiceGroupCreatedAlert`: send when an user admin has created a service group\n* `ServiceGroupUpdatedAlert`: send when an user admin has updated a service group\n* `ServiceGroupDeletedAlert`: send when an user admin has deleted a service group\n* `ServiceCreatedAlert`: send when an user admin has created a tcp service\n* `ServiceUpdatedAlert`: send when an user admin has updated a tcp service\n* `ServiceDeletedAlert`: send when an user admin has deleted a tcp service\n* `ApiKeyCreatedAlert`: send when an user admin has crated a new apikey\n* `ApiKeyUpdatedAlert`: send when an user admin has updated a new apikey\n* `ApiKeyDeletedAlert`: send when an user admin has deleted a new apikey\n\n## Audit\n\nWith Otoroshi, any admin action and any sucpicious/alert action is recorded. These records are stored in Otoroshis datastore (only the last n records, defined by the app.events.maxSize config key). All the records can be send through the analytics mechanism (WebHook, Kafka, Elastic) for external and/or further usage. We recommand sending away those records for security reasons.\n\nOtoroshi keep the following list of information for each executed action:\n\n* `Date`: moment of the action\n* `User`: name of the owner\n* `From`: IP of the concerned user\n* `Action`: action performed by the person. The possible actions are:\n\n    * `ACCESS_APIKEY`: User accessed a apikey\n    * `ACCESS_ALL_APIKEYS`: User accessed all apikeys\n    * `CREATE_APIKEY`: User created a apikey\n    * `UPDATE_APIKEY`: User updated a apikey\n    * `DELETE_APIKEY`: User deleted a apikey\n    * `ACCESS_AUTH_MODULE`: User accessed an Auth. module\n    * `ACCESS_ALL_AUTH_MODULES`: User accessed all Auth. modules\n    * `CREATE_AUTH_MODULE`: User created an Auth. module\n    * `UPDATE_AUTH_MODULE`: User updated an Auth. module\n    * `DELETE_AUTH_MODULE`: User deleted an Auth. module\n    * `ACCESS_CERTIFICATE`: User accessed a certificate\n    * `ACCESS_ALL_CERTIFICATES`: User accessed all certificates\n    * `CREATE_CERTIFICATE`: User created a certificate\n    * `UPDATE_CERTIFICATE`: User updated a certificate\n    * `DELETE_CERTIFICATE`: User deleted a certificate\n    * `ACCESS_CLIENT_CERT_VALIDATOR`: User accessed a client cert. validator\n    * `ACCESS_ALL_CLIENT_CERT_VALIDATORS`: User accessed all client cert. validators\n    * `CREATE_CLIENT_CERT_VALIDATOR`: User created a client cert. validator\n    * `UPDATE_CLIENT_CERT_VALIDATOR`: User updated a client cert. validator\n    * `DELETE_CLIENT_CERT_VALIDATOR`: User deleted a client cert. validator\n    * `ACCESS_DATA_EXPORTER_CONFIG`: User accessed a data exporter config\n    * `ACCESS_ALL_DATA_EXPORTER_CONFIG`: User accessed all data exporter config\n    * `CREATE_DATA_EXPORTER_CONFIG`: User created a data exporter config\n    * `UPDATE_DATA_EXPORTER_CONFIG`: User updated a data exporter config\n    * `DELETE_DATA_EXPORTER_CONFIG`: User deleted a data exporter config\n    * `ACCESS_GLOBAL_JWT_VERIFIER`: User accessed a global jwt verifier\n    * `ACCESS_ALL_GLOBAL_JWT_VERIFIERS`: User accessed all global jwt verifiers\n    * `CREATE_GLOBAL_JWT_VERIFIER`: User created a global jwt verifier\n    * `UPDATE_GLOBAL_JWT_VERIFIER`: User updated a global jwt verifier\n    * `DELETE_GLOBAL_JWT_VERIFIER`: User deleted a global jwt verifier\n    * `ACCESS_SCRIPT`: User accessed a script\n    * `ACCESS_ALL_SCRIPTS`: User accessed all scripts\n    * `CREATE_SCRIPT`: User created a script\n    * `UPDATE_SCRIPT`: User updated a script\n    * `DELETE_SCRIPT`: User deleted a Script\n    * `ACCESS_SERVICES_GROUP`: User accessed a service group\n    * `ACCESS_ALL_SERVICES_GROUPS`: User accessed all services groups\n    * `CREATE_SERVICE_GROUP`: User created a service group\n    * `UPDATE_SERVICE_GROUP`: User updated a service group\n    * `DELETE_SERVICE_GROUP`: User deleted a service group\n    * `ACCESS_SERVICES_FROM_SERVICES_GROUP`: User accessed all services from a services group\n    * `ACCESS_TCP_SERVICE`: User accessed a tcp service\n    * `ACCESS_ALL_TCP_SERVICES`: User accessed all tcp services\n    * `CREATE_TCP_SERVICE`: User created a tcp service\n    * `UPDATE_TCP_SERVICE`: User updated a tcp service\n    * `DELETE_TCP_SERVICE`: User deleted a tcp service\n    * `ACCESS_TEAM`: User accessed a Team\n    * `ACCESS_ALL_TEAMS`: User accessed all teams\n    * `CREATE_TEAM`: User created a team\n    * `UPDATE_TEAM`: User updated a team\n    * `DELETE_TEAM`: User deleted a team\n    * `ACCESS_TENANT`: User accessed a Tenant\n    * `ACCESS_ALL_TENANTS`: User accessed all tenants\n    * `CREATE_TENANT`: User created a tenant\n    * `UPDATE_TENANT`: User updated a tenant\n    * `DELETE_TENANT`: User deleted a tenant\n    * `SERVICESEARCH`: User searched for a service\n    * `ACTIVATE_PANIC_MODE`: Admin activated panic mode\n\n\n* `Message`: explicit message about the action (example: the `SERVICESEARCH` action happened when an `user searched for a service`)\n* `Content`: all information at JSON format\n\n## Global metrics\n\nThe global metrics are displayed on the index page of the Otoroshi UI. Otoroshi provides information about :\n\n* the number of requests served\n* the amount of data received and sended\n* the number of concurrent requests\n* the number of requests per second\n* the current overhead\n\nMore metrics can be found on the **Global analytics** page (available at https://xxxxxx/bo/dashboard/stats).\n\n## Monitoring services\n\nOnce you have declared services, you can monitor them with Otoroshi. \n\nLet's starting by setup Otoroshi to push events to an elastic cluster via a data exporter. Then you will can setup Otoroshi events read from an elastic cluster. Go to `settings (cog icon) / Danger Zone` and expand the `Analytics: Elastic cluster (read)` section.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/push-to-elastic.png\" />\n@@@\n\n### Service healthcheck\n\nIf you have defined an health check URL in the service descriptor, you can access the health check page from the sidebar of the service page.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/service-healthcheck.png\" />\n@@@\n\n### Service live stats\n\nYou can also monitor live stats like total of served request, average response time, average overhead, etc. The live stats page can be accessed from the sidebar of the service page.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/service-live-stats.png\" />\n@@@\n\n### Service analytics\n\nYou can also get some aggregated metrics. The analytics page can be accessed from the sidebar of the service page.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/service-analytics.png\" />\n@@@\n"
  },
  {
    "name": "expression-language.md",
    "id": "/topics/expression-language.md",
    "url": "/topics/expression-language.html",
    "title": "Expression language",
    "content": "# Expression language\n\n- [Documentation and examples](#documentation-and-examples)\n- [Test the expression language](#test-the-expression-language)\n\nThe expression language provides an important mechanism for accessing and manipulating Otoroshi data on different inputs. For example, with this mechanism, you can mapping a claim of an inconming token directly in a claim of a generated token (using @ref:[JWT verifiers](../entities/jwt-verifiers.md)). You can add information of the service descriptor traversed such as the domain of the service or the name of the service. This information can be useful on the downstream service.\n\n## Documentation and examples\n<!-- Documentation is in expression-language.js and it build when page is rendered -->\n@@@div { #expressions }\n&nbsp;\n@@@\n\nIf an input contains a string starting by `${`, Otoroshi will try to evaluate the content. If the content doesn't match a known expression,\nthe 'bad-expr' value will be set.\n\n## Test the expression language\n\nYou can test to get the same values than the right part by creating these following services. \n\n```sh\n# Let's start by downloading the latest Otoroshi.\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n\n# Once downloading, run Otoroshi.\njava -Dapp.adminPassword=password -jar otoroshi.jar \n\n# Create a proxy of the mirror.otoroshi.io on http://myservice.oto.tools:8080\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/services \\\n-H \"Otoroshi-Client-Id: admin-api-apikey-id\" \\\n-H \"Otoroshi-Client-Secret: admin-api-apikey-secret\" \\\n-H 'Content-Type: application/json; charset=utf-8' \\\n-d @- <<'EOF'\n{\"enforceSecureCommunication\":false,\"forceHttps\":false,\"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"groupId\":\"default\",\"groups\":[\"default\"],\"id\":\"expression-language-api-service\",\"name\":\"expression-language\",\"description\":\"expression-language\",\"env\":\"prod\",\"domain\":\"oto.tools\",\"subdomain\":\"api\",\"targetsLoadBalancing\":{\"type\":\"RoundRobin\"},\"targets\":[{\"host\":\"mirror.otoroshi.io\",\"scheme\":\"https\",\"weight\":1,\"mtlsConfig\":{\"certs\":[],\"trustedCerts\":[],\"mtls\":false,\"loose\":false,\"trustAll\":false},\"tags\":[],\"metadata\":{},\"protocol\":\"HTTP\\/1.1\",\"predicate\":{\"type\":\"AlwaysMatch\"},\"ipAddress\":null}],\"root\":\"\\/\",\"matchingRoot\":null,\"stripPath\":true,\"enabled\":true,\"secComHeaders\":{\"claimRequestName\":null,\"stateRequestName\":null,\"stateResponseName\":null},\"publicPatterns\":[],\"privatePatterns\":[\"/.*\"],\"kind\":\"ServiceDescriptor\",\"additionalHeaders\":{\"my-expr-header.date\":\"${date}\",\"my-expr-header.date-with-format\":\"${date.format('yyy-MM-dd')}\",\"my-expr-header.request.full-url\":\"${req.fullUrl}\",\"my-expr-header.request.path\":\"${req.path}\",\"my-expr-header.request.uri\":\"${req.uri}\",\"my-expr-header.request.host\":\"${req.host}\",\"my-expr-header.request.domain\":\"${req.domain}\",\"my-expr-header.request.method\":\"${req.method}\",\"my-expr-header.request.protocol\":\"${req.protocol}\",\"my-expr-header.request.unknown-header\":\"${req.headers.foob:default value}\",\"my-expr-header.request.header\":\"${req.headers.foo}\",\"my-expr-header.request.unknown-query\":\"${req.query.foob:default value}\",\"my-expr-header.request.query\":\"${req.query.foo}\",\"my-expr-header.service-domain\":\"${service.domain}\",\"my-expr-header.service-subdomain\":\"${service.subdomain}\",\"my-expr-header.service-tld\":\"${service.tld}\",\"my-expr-header.service-env\":\"${service.env}\",\"my-expr-header.service-id\":\"${service.id}\",\"my-expr-header.service-name\":\"${service.name}\",\"my-expr-header.service-unknown-group\":\"${service.groups['0':'unkown group']}\",\"my-expr-header.service-group\":\"${service.groups['0']}\",\"my-expr-header.service-unknown-metadata\":\"${service.metadata.test:default-value}\",\"my-expr-header.service-metadata\":\"${service.metadata.foo}\",\"my-expr-header.apikey.name\":\"${apikey.name}\",\"my-expr-header.apikey.id\":\"${apikey.id}\",\"my-expr-header.apikey.unknown-metadata\":\"${apikey.metadata.myfield:default value}\",\"my-expr-header.apikey.metadata\":\"${apikey.metadata.foo}\",\"my-expr-header.apikey.unknown-tag\":\"${apikey.tags['0':'no-found-tag']}\",\"my-expr-header.apikey.tag\":\"${apikey.tags['0']}\",\"my-expr-header.token.replace-header-value\":\"${token.foo.replace('o','a')}\",\"my-expr-header.token.replace-header-all-value\":\"${token.foo.replaceAll('o','a')}\",\"my-expr-header.token.unknown-fields\":\"${token.foob|token.foob2:not-found}\",\"my-expr-header.token.foo-field\":\"${token.foob|token.foo}\",\"my-expr-header.token.unknown-foo-field\":\"${token.foob:not-found-foob}\",\"my-expr-header.token.unknown-foo\":\"${token.foo}\",\"my-expr-header.env.unknown-field\":\"${env.java_h:not-found-java_h}\",\"my-expr-header.env.path\":\"${env.PATH}\",\"my-expr-header.config.unknown-port-field\":\"${config.http.ports:not-found}\",\"my-expr-header.config.port\":\"${config.http.port}\",\"my-expr-header.ctx.replace-field-value\":\"${ctx.foo.replace('o','a')}\",\"my-expr-header.ctx.replace-field-all-value\":\"${ctx.foo.replaceAll('o','a')}\",\"my-expr-header.ctx.unknown-fields\":\"${ctx.foob|ctx.foot:not-found}\",\"my-expr-header.ctx.foo-field\":\"${ctx.foob|ctx.foo}\",\"my-expr-header.ctx.default-value\":\"${ctx.foob:other}\",\"my-expr-header.ctx.foo\":\"${ctx.foo}\",\"my-expr-header.ctx.useragent\":\"${ctx.useragent.foo}\",\"my-expr-header.ctx.geolocation\":\"${ctx.geolocation.foo}\"}}\nEOF\n\n# Create an authentication module to protect the next service.\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/auths \\\n-H \"Otoroshi-Client-Id: admin-api-apikey-id\" \\\n-H \"Otoroshi-Client-Secret: admin-api-apikey-secret\" \\\n-H 'Content-Type: application/json; charset=utf-8' \\\n-d @- <<'EOF'\n{\"type\":\"basic\",\"id\":\"auth_mod_in_memory_auth\",\"name\":\"in-memory-auth\",\"desc\":\"in-memory-auth\",\"users\":[{\"name\":\"User Otoroshi\",\"password\":\"$2a$10$oIf4JkaOsfiypk5ZK8DKOumiNbb2xHMZUkYkuJyuIqMDYnR/zXj9i\",\"email\":\"user@foo.bar\",\"metadata\":{\"username\":\"roger\"},\"tags\":[\"foo\"],\"webauthn\":null,\"rights\":[{\"tenant\":\"*:r\",\"teams\":[\"*:r\"]}]}],\"sessionCookieValues\":{\"httpOnly\":true,\"secure\":false}}\nEOF\n\n# Create the same proxy but protected by an authentication memory module (in order to retrieve the user's information after they have successfully logged in)\ncurl -X POST http://otoroshi-api.oto.tools:8080/api/services \\\n-H \"Otoroshi-Client-Id: admin-api-apikey-id\" \\\n-H \"Otoroshi-Client-Secret: admin-api-apikey-secret\" \\\n-H 'Content-Type: application/json; charset=utf-8' \\\n-d @- <<'EOF'\n{\"enforceSecureCommunication\":false,\"forceHttps\":false,\"_loc\":{\"tenant\":\"default\",\"teams\":[\"default\"]},\"groupId\":\"default\",\"groups\":[\"default\"],\"id\":\"expression-language-webapp\",\"name\":\"webapp\",\"description\":\"webapp\",\"env\":\"prod\",\"domain\":\"oto.tools\",\"subdomain\":\"webapp\",\"targetsLoadBalancing\":{\"type\":\"RoundRobin\"},\"targets\":[{\"host\":\"mirror.otoroshi.io\",\"scheme\":\"https\",\"weight\":1,\"mtlsConfig\":{\"certs\":[],\"trustedCerts\":[],\"mtls\":false,\"loose\":false,\"trustAll\":false},\"tags\":[],\"metadata\":{},\"protocol\":\"HTTP\\/1.1\",\"predicate\":{\"type\":\"AlwaysMatch\"},\"ipAddress\":null}],\"root\":\"\\/\",\"authConfigRef\":\"auth_mod_in_memory_auth\",\"matchingRoot\":null,\"stripPath\":true,\"enabled\":true,\"secComHeaders\":{\"claimRequestName\":null,\"stateRequestName\":null,\"stateResponseName\":null},\"publicPatterns\":[\"/.*\"],\"privateApp\":true,\"privatePatterns\":[],\"kind\":\"ServiceDescriptor\",\"additionalHeaders\":{\"my-expr-header.user\":\"${user.name}\",\"my-expr-header.user.email\":\"${user.email}\",\"my-expr-header.user.unknown-metadata\":\"${user.metadata.foo:'not-found'}\",\"my-expr-header.user.metadata\":\"${user.metadata.username}\",\"my-expr-header.user.unknown-profile-field\":\"${user.profile.username:'not-found'}\",\"my-expr-header.user.profile-field\":\"${user.profile.name}\"}}\nEOF\n```\n\nThen try to call the first service.\n\n```sh\ncurl http://api.oto.tools:8080/api/\\?foo\\=bar \\\n-H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJmb28iOiJiYXIifQ.lV130dFXR3bNtWBkwwf9dLmfsRVmnZhfYF9gvAaRzF8\" \\\n-H \"Otoroshi-Client-Id: admin-api-apikey-id\" \\\n-H \"Otoroshi-Client-Secret: admin-api-apikey-secret\" \\\n-H \"foo: bar\" | jq\n```\n\nThis will returns the list of the received headers by the mirror.\n\n```json\n{\n  ...\n  \"headers\": {\n    ...\n    \"my-expr-header.date\": \"2021-11-26T10:54:51.112+01:00\",\n    \"my-expr-header.ctx.foo\": \"no-ctx-foo\",\n    \"my-expr-header.env.path\": \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\",\n    \"my-expr-header.apikey.id\": \"admin-api-apikey-id\",\n    \"my-expr-header.apikey.tag\": \"one-tag\",\n    \"my-expr-header.service-id\": \"expression-language-api-service\",\n    \"my-expr-header.apikey.name\": \"Otoroshi Backoffice ApiKey\",\n    \"my-expr-header.config.port\": \"8080\",\n    \"my-expr-header.request.uri\": \"/api/?foo=bar\",\n    \"my-expr-header.service-env\": \"prod\",\n    \"my-expr-header.service-tld\": \"oto.tools\",\n    \"my-expr-header.request.host\": \"api.oto.tools:8080\",\n    \"my-expr-header.request.path\": \"/api/\",\n    \"my-expr-header.service-name\": \"expression-language\",\n    \"my-expr-header.ctx.foo-field\": \"no-ctx-foob-foo\",\n    \"my-expr-header.ctx.useragent\": \"no-ctx-useragent.foo\",\n    \"my-expr-header.request.query\": \"bar\",\n    \"my-expr-header.service-group\": \"default\",\n    \"my-expr-header.request.domain\": \"api.oto.tools\",\n    \"my-expr-header.request.header\": \"bar\",\n    \"my-expr-header.request.method\": \"GET\",\n    \"my-expr-header.service-domain\": \"api.oto.tools\",\n    \"my-expr-header.apikey.metadata\": \"bar\",\n    \"my-expr-header.ctx.geolocation\": \"no-ctx-geolocation.foo\",\n    \"my-expr-header.token.foo-field\": \"no-token-foob-foo\",\n    \"my-expr-header.date-with-format\": \"2021-11-26\",\n    \"my-expr-header.request.full-url\": \"http://api.oto.tools:8080/api/?foo=bar\",\n    \"my-expr-header.request.protocol\": \"http\",\n    \"my-expr-header.service-metadata\": \"no-meta-foo\",\n    \"my-expr-header.ctx.default-value\": \"other\",\n    \"my-expr-header.env.unknown-field\": \"not-found-java_h\",\n    \"my-expr-header.service-subdomain\": \"api\",\n    \"my-expr-header.token.unknown-foo\": \"no-token-foo\",\n    \"my-expr-header.apikey.unknown-tag\": \"one-tag\",\n    \"my-expr-header.ctx.unknown-fields\": \"not-found\",\n    \"my-expr-header.token.unknown-fields\": \"not-found\",\n    \"my-expr-header.request.unknown-query\": \"default value\",\n    \"my-expr-header.service-unknown-group\": \"default\",\n    \"my-expr-header.request.unknown-header\": \"default value\",\n    \"my-expr-header.apikey.unknown-metadata\": \"default value\",\n    \"my-expr-header.ctx.replace-field-value\": \"no-ctx-foo\",\n    \"my-expr-header.token.unknown-foo-field\": \"not-found-foob\",\n    \"my-expr-header.service-unknown-metadata\": \"default-value\",\n    \"my-expr-header.config.unknown-port-field\": \"not-found\",\n    \"my-expr-header.token.replace-header-value\": \"no-token-foo\",\n    \"my-expr-header.ctx.replace-field-all-value\": \"no-ctx-foo\",\n    \"my-expr-header.token.replace-header-all-value\": \"no-token-foo\",\n  }\n}\n```\n\nThen try the second call to the webapp. Navigate on your browser to `http://webapp.oto.tools:8080`. Continue with `user@foo.bar` as user and `password` as credential.\n\nThis should output:\n\n```json\n{\n  ...\n  \"headers\": {\n    ...\n    \"my-expr-header.user\": \"User Otoroshi\",\n    \"my-expr-header.user.email\": \"user@foo.bar\",\n    \"my-expr-header.user.metadata\": \"roger\",\n    \"my-expr-header.user.profile-field\": \"User Otoroshi\",\n    \"my-expr-header.user.unknown-metadata\": \"not-found\",\n    \"my-expr-header.user.unknown-profile-field\": \"not-found\",\n  }\n}\n```"
  },
  {
    "name": "index.md",
    "id": "/topics/index.md",
    "url": "/topics/index.html",
    "title": "Detailed topics",
    "content": "# Detailed topics\n\nIn this sections, you will find informations about various Otoroshi topics  \n\n* @ref:[Chaos engineering](./chaos-engineering.md)\n* @ref:[TLS](./tls.md)\n* @ref:[Otoroshi's PKI](./pki.md)\n* @ref:[Monitoring](./monitoring.md)\n* @ref:[Events and analytics](./events-and-analytics.md)\n* @ref:[Developer portal with Daikoku](./dev-portal.md)\n* @ref:[Sessions management](./sessions-mgmt.md)\n* @ref:[The Otoroshi communication protocol](./otoroshi-protocol.md)\n* @ref:[Expression language](./expression-language.md)\n* @ref:[Otoroshi user rights](./user-rights.md)\n\n@@@ index\n\n* [Chaos engineering](./chaos-engineering.md)\n* [TLS](./tls.md)\n* [Otoroshi's PKI](./pki.md)\n* [Monitoring](./monitoring.md)\n* [Events and analytics](./events-and-analytics.md)\n* [Developer portal with Daikoku](./dev-portal.md)\n* [Sessions management](./sessions-mgmt.md)\n* [The Otoroshi communication protocol](./otoroshi-protocol.md)\n* [Expression language](./expression-language.md)\n* [Otoroshi user rights](./user-rights.md)\n  \n@@@\n"
  },
  {
    "name": "monitoring.md",
    "id": "/topics/monitoring.md",
    "url": "/topics/monitoring.html",
    "title": "Monitoring",
    "content": "# Monitoring\n\nThe Otoroshi API exposes two endpoints to know more about instance health. All the following endpoint are exposed on the instance host through it's ip address. It is also exposed on the otoroshi api hostname and the otoroshi backoffice hostname\n\n* `/health`: the health of the Otoroshi instance\n* `/metrics`: the metrics of the Otoroshi instance, either in JSON or Prometheus format using the `Accept` header (with `application/json` / `application/prometheus` values) or the `format` query param (with `json` or `prometheus` values)\n* `/live`: returns an http 200 response `{\"live\": true}` when the service is alive\n* `/ready`: return an http 200 response `{\"ready\": true}` when the instance is ready to accept traffic (certs synced, plugins compiled, etc). if not, returns http 503 `{\"ready\": false}`\n* `/startup`: return an http 200 response `{\"started\": true}` when the instance is ready to accept traffic (certs synced, plugins compiled, etc). if not, returns http 503 `{\"started\": false}`\n\nthose routes are also available on any hostname leading to otoroshi with a twist in the URL\n\n* http://xxxxxxxx.xxxxx.xx/.well-known/otoroshi/monitoring/health\n* http://xxxxxxxx.xxxxx.xx/.well-known/otoroshi/monitoring/metrics\n* http://xxxxxxxx.xxxxx.xx/.well-known/otoroshi/monitoring/live\n* http://xxxxxxxx.xxxxx.xx/.well-known/otoroshi/monitoring/ready\n* http://xxxxxxxx.xxxxx.xx/.well-known/otoroshi/monitoring/startup\n\n## Endpoints security\n\nThe two endpoints are exposed publicly on the Otoroshi admin api. But you can remove the corresponding public pattern and query the endpoints using standard apikeys. If you don't want to use apikeys but don't want to expose the endpoints publicly, you can defined two config. variables (`app.health.accessKey` or `HEALTH_ACCESS_KEY` and `otoroshi.metrics.accessKey` or `OTOROSHI_METRICS_ACCESS_KEY`) that will hold an access key for the endpoints. Then you can call the endpoints with an `access_key` query param with the value defined in the config. If you don't defined `otoroshi.metrics.accessKey` but define `app.health.accessKey`, `otoroshi.metrics.accessKey` will have the value of `app.health.accessKey`.\n \n## Examples\n\nlet say `app.health.accessKey` has value `MILpkVv6f2kG9Xmnc4mFIYRU4rTxHVGkxvB0hkQLZwEaZgE2hgbOXiRsN1DBnbtY`\n\n```sh\n$ curl http://otoroshi-api.oto.tools:8080/health\\?access_key\\=MILpkVv6f2kG9Xmnc4mFIYRU4rTxHVGkxvB0hkQLZwEaZgE2hgbOXiRsN1DBnbtY\n{\"otoroshi\":\"healthy\",\"datastore\":\"healthy\"}\n\n$ curl -H 'Accept: application/json' http://otoroshi-api.oto.tools:8080/metrics\\?access_key\\=MILpkVv6f2kG9Xmnc4mFIYRU4rTxHVGkxvB0hkQLZwEaZgE2hgbOXiRsN1DBnbtY\n{\"version\":\"4.0.0\",\"gauges\":{\"attr.app.commit\":{\"value\":\"xxxx\"},\"attr.app.id\":{\"value\":\"xxxx\"},\"attr.cluster.mode\":{\"value\":\"Leader\"},\"attr.cluster.name\":{\"value\":\"otoroshi-leader-0\"},\"attr.instance.env\":{\"value\":\"prod\"},\"attr.instance.id\":{\"value\":\"xxxx\"},\"attr.instance.number\":{\"value\":\"0\"},\"attr.jvm.cpu.usage\":{\"value\":136},\"attr.jvm.heap.size\":{\"value\":1409},\"attr.jvm.heap.used\":{\"value\":112},\"internals.0.concurrent-requests\":{\"value\":1},\"internals.global.throttling-quotas\":{\"value\":2},\"jvm.attr.name\":{\"value\":\"2085@xxxx\"},\"jvm.attr.uptime\":{\"value\":2296900},\"jvm.attr.vendor\":{\"value\":\"JDK11\"},\"jvm.gc.PS-MarkSweep.count\":{\"value\":3},\"jvm.gc.PS-MarkSweep.time\":{\"value\":261},\"jvm.gc.PS-Scavenge.count\":{\"value\":12},\"jvm.gc.PS-Scavenge.time\":{\"value\":161},\"jvm.memory.heap.committed\":{\"value\":1477967872},\"jvm.memory.heap.init\":{\"value\":1690304512},\"jvm.memory.heap.max\":{\"value\":3005218816},\"jvm.memory.heap.usage\":{\"value\":0.03916456777568639},\"jvm.memory.heap.used\":{\"value\":117698096},\"jvm.memory.non-heap.committed\":{\"value\":166445056},\"jvm.memory.non-heap.init\":{\"value\":7667712},\"jvm.memory.non-heap.max\":{\"value\":994050048},\"jvm.memory.non-heap.usage\":{\"value\":0.1523920694986979},\"jvm.memory.non-heap.used\":{\"value\":151485344},\"jvm.memory.pools.CodeHeap-'non-nmethods'.committed\":{\"value\":2555904},\"jvm.memory.pools.CodeHeap-'non-nmethods'.init\":{\"value\":2555904},\"jvm.memory.pools.CodeHeap-'non-nmethods'.max\":{\"value\":5832704},\"jvm.memory.pools.CodeHeap-'non-nmethods'.usage\":{\"value\":0.28408093398876405},\"jvm.memory.pools.CodeHeap-'non-nmethods'.used\":{\"value\":1656960},\"jvm.memory.pools.CodeHeap-'non-profiled-nmethods'.committed\":{\"value\":11796480},\"jvm.memory.pools.CodeHeap-'non-profiled-nmethods'.init\":{\"value\":2555904},\"jvm.memory.pools.CodeHeap-'non-profiled-nmethods'.max\":{\"value\":122912768},\"jvm.memory.pools.CodeHeap-'non-profiled-nmethods'.usage\":{\"value\":0.09536102872567315},\"jvm.memory.pools.CodeHeap-'non-profiled-nmethods'.used\":{\"value\":11721088},\"jvm.memory.pools.CodeHeap-'profiled-nmethods'.committed\":{\"value\":37355520},\"jvm.memory.pools.CodeHeap-'profiled-nmethods'.init\":{\"value\":2555904},\"jvm.memory.pools.CodeHeap-'profiled-nmethods'.max\":{\"value\":122912768},\"jvm.memory.pools.CodeHeap-'profiled-nmethods'.usage\":{\"value\":0.2538573047187417},\"jvm.memory.pools.CodeHeap-'profiled-nmethods'.used\":{\"value\":31202304},\"jvm.memory.pools.Compressed-Class-Space.committed\":{\"value\":14942208},\"jvm.memory.pools.Compressed-Class-Space.init\":{\"value\":0},\"jvm.memory.pools.Compressed-Class-Space.max\":{\"value\":367001600},\"jvm.memory.pools.Compressed-Class-Space.usage\":{\"value\":0.033858838762555805},\"jvm.memory.pools.Compressed-Class-Space.used\":{\"value\":12426248},\"jvm.memory.pools.Metaspace.committed\":{\"value\":99794944},\"jvm.memory.pools.Metaspace.init\":{\"value\":0},\"jvm.memory.pools.Metaspace.max\":{\"value\":375390208},\"jvm.memory.pools.Metaspace.usage\":{\"value\":0.25168142904782426},\"jvm.memory.pools.Metaspace.used\":{\"value\":94478744},\"jvm.memory.pools.PS-Eden-Space.committed\":{\"value\":349700096},\"jvm.memory.pools.PS-Eden-Space.init\":{\"value\":422576128},\"jvm.memory.pools.PS-Eden-Space.max\":{\"value\":1110966272},\"jvm.memory.pools.PS-Eden-Space.usage\":{\"value\":0.07505125052077188},\"jvm.memory.pools.PS-Eden-Space.used\":{\"value\":83379408},\"jvm.memory.pools.PS-Eden-Space.used-after-gc\":{\"value\":0},\"jvm.memory.pools.PS-Old-Gen.committed\":{\"value\":1127219200},\"jvm.memory.pools.PS-Old-Gen.init\":{\"value\":1127219200},\"jvm.memory.pools.PS-Old-Gen.max\":{\"value\":2253914112},\"jvm.memory.pools.PS-Old-Gen.usage\":{\"value\":0.014950035505168354},\"jvm.memory.pools.PS-Old-Gen.used\":{\"value\":33696096},\"jvm.memory.pools.PS-Old-Gen.used-after-gc\":{\"value\":23791152},\"jvm.memory.pools.PS-Survivor-Space.committed\":{\"value\":1048576},\"jvm.memory.pools.PS-Survivor-Space.init\":{\"value\":70254592},\"jvm.memory.pools.PS-Survivor-Space.max\":{\"value\":1048576},\"jvm.memory.pools.PS-Survivor-Space.usage\":{\"value\":0.59375},\"jvm.memory.pools.PS-Survivor-Space.used\":{\"value\":622592},\"jvm.memory.pools.PS-Survivor-Space.used-after-gc\":{\"value\":622592},\"jvm.memory.total.committed\":{\"value\":1644412928},\"jvm.memory.total.init\":{\"value\":1697972224},\"jvm.memory.total.max\":{\"value\":3999268864},\"jvm.memory.total.used\":{\"value\":269184904},\"jvm.thread.blocked.count\":{\"value\":0},\"jvm.thread.count\":{\"value\":82},\"jvm.thread.daemon.count\":{\"value\":11},\"jvm.thread.deadlock.count\":{\"value\":0},\"jvm.thread.deadlocks\":{\"value\":[]},\"jvm.thread.new.count\":{\"value\":0},\"jvm.thread.runnable.count\":{\"value\":25},\"jvm.thread.terminated.count\":{\"value\":0},\"jvm.thread.timed_waiting.count\":{\"value\":10},\"jvm.thread.waiting.count\":{\"value\":47}},\"counters\":{},\"histograms\":{},\"meters\":{},\"timers\":{}}\n\n$ curl -H 'Accept: application/prometheus' http://otoroshi-api.oto.tools:8080/metrics\\?access_key\\=MILpkVv6f2kG9Xmnc4mFIYRU4rTxHVGkxvB0hkQLZwEaZgE2hgbOXiRsN1DBnbtY\n# TYPE attr_jvm_cpu_usage gauge\nattr_jvm_cpu_usage 83.0\n# TYPE attr_jvm_heap_size gauge\nattr_jvm_heap_size 1409.0\n# TYPE attr_jvm_heap_used gauge\nattr_jvm_heap_used 220.0\n# TYPE internals_0_concurrent_requests gauge\ninternals_0_concurrent_requests 1.0\n# TYPE internals_global_throttling_quotas gauge\ninternals_global_throttling_quotas 3.0\n# TYPE jvm_attr_uptime gauge\njvm_attr_uptime 2372614.0\n# TYPE jvm_gc_PS_MarkSweep_count gauge\njvm_gc_PS_MarkSweep_count 3.0\n# TYPE jvm_gc_PS_MarkSweep_time gauge\njvm_gc_PS_MarkSweep_time 261.0\n# TYPE jvm_gc_PS_Scavenge_count gauge\njvm_gc_PS_Scavenge_count 12.0\n# TYPE jvm_gc_PS_Scavenge_time gauge\njvm_gc_PS_Scavenge_time 161.0\n# TYPE jvm_memory_heap_committed gauge\njvm_memory_heap_committed 1.477967872E9\n# TYPE jvm_memory_heap_init gauge\njvm_memory_heap_init 1.690304512E9\n# TYPE jvm_memory_heap_max gauge\njvm_memory_heap_max 3.005218816E9\n# TYPE jvm_memory_heap_usage gauge\njvm_memory_heap_usage 0.07680553268571043\n# TYPE jvm_memory_heap_used gauge\njvm_memory_heap_used 2.30817432E8\n# TYPE jvm_memory_non_heap_committed gauge\njvm_memory_non_heap_committed 1.66510592E8\n# TYPE jvm_memory_non_heap_init gauge\njvm_memory_non_heap_init 7667712.0\n# TYPE jvm_memory_non_heap_max gauge\njvm_memory_non_heap_max 9.94050048E8\n# TYPE jvm_memory_non_heap_usage gauge\njvm_memory_non_heap_usage 0.15262878997416435\n# TYPE jvm_memory_non_heap_used gauge\njvm_memory_non_heap_used 1.51720656E8\n# TYPE jvm_memory_pools_CodeHeap__non_nmethods__committed gauge\njvm_memory_pools_CodeHeap__non_nmethods__committed 2555904.0\n# TYPE jvm_memory_pools_CodeHeap__non_nmethods__init gauge\njvm_memory_pools_CodeHeap__non_nmethods__init 2555904.0\n# TYPE jvm_memory_pools_CodeHeap__non_nmethods__max gauge\njvm_memory_pools_CodeHeap__non_nmethods__max 5832704.0\n# TYPE jvm_memory_pools_CodeHeap__non_nmethods__usage gauge\njvm_memory_pools_CodeHeap__non_nmethods__usage 0.28408093398876405\n# TYPE jvm_memory_pools_CodeHeap__non_nmethods__used gauge\njvm_memory_pools_CodeHeap__non_nmethods__used 1656960.0\n# TYPE jvm_memory_pools_CodeHeap__non_profiled_nmethods__committed gauge\njvm_memory_pools_CodeHeap__non_profiled_nmethods__committed 1.1862016E7\n# TYPE jvm_memory_pools_CodeHeap__non_profiled_nmethods__init gauge\njvm_memory_pools_CodeHeap__non_profiled_nmethods__init 2555904.0\n# TYPE jvm_memory_pools_CodeHeap__non_profiled_nmethods__max gauge\njvm_memory_pools_CodeHeap__non_profiled_nmethods__max 1.22912768E8\n# TYPE jvm_memory_pools_CodeHeap__non_profiled_nmethods__usage gauge\njvm_memory_pools_CodeHeap__non_profiled_nmethods__usage 0.09610562183417755\n# TYPE jvm_memory_pools_CodeHeap__non_profiled_nmethods__used gauge\njvm_memory_pools_CodeHeap__non_profiled_nmethods__used 1.1812608E7\n# TYPE jvm_memory_pools_CodeHeap__profiled_nmethods__committed gauge\njvm_memory_pools_CodeHeap__profiled_nmethods__committed 3.735552E7\n# TYPE jvm_memory_pools_CodeHeap__profiled_nmethods__init gauge\njvm_memory_pools_CodeHeap__profiled_nmethods__init 2555904.0\n# TYPE jvm_memory_pools_CodeHeap__profiled_nmethods__max gauge\njvm_memory_pools_CodeHeap__profiled_nmethods__max 1.22912768E8\n# TYPE jvm_memory_pools_CodeHeap__profiled_nmethods__usage gauge\njvm_memory_pools_CodeHeap__profiled_nmethods__usage 0.25493618368435084\n# TYPE jvm_memory_pools_CodeHeap__profiled_nmethods__used gauge\njvm_memory_pools_CodeHeap__profiled_nmethods__used 3.1334912E7\n# TYPE jvm_memory_pools_Compressed_Class_Space_committed gauge\njvm_memory_pools_Compressed_Class_Space_committed 1.4942208E7\n# TYPE jvm_memory_pools_Compressed_Class_Space_init gauge\njvm_memory_pools_Compressed_Class_Space_init 0.0\n# TYPE jvm_memory_pools_Compressed_Class_Space_max gauge\njvm_memory_pools_Compressed_Class_Space_max 3.670016E8\n# TYPE jvm_memory_pools_Compressed_Class_Space_usage gauge\njvm_memory_pools_Compressed_Class_Space_usage 0.03386023385184152\n# TYPE jvm_memory_pools_Compressed_Class_Space_used gauge\njvm_memory_pools_Compressed_Class_Space_used 1.242676E7\n# TYPE jvm_memory_pools_Metaspace_committed gauge\njvm_memory_pools_Metaspace_committed 9.9794944E7\n# TYPE jvm_memory_pools_Metaspace_init gauge\njvm_memory_pools_Metaspace_init 0.0\n# TYPE jvm_memory_pools_Metaspace_max gauge\njvm_memory_pools_Metaspace_max 3.75390208E8\n# TYPE jvm_memory_pools_Metaspace_usage gauge\njvm_memory_pools_Metaspace_usage 0.25170985813247426\n# TYPE jvm_memory_pools_Metaspace_used gauge\njvm_memory_pools_Metaspace_used 9.4489416E7\n# TYPE jvm_memory_pools_PS_Eden_Space_committed gauge\njvm_memory_pools_PS_Eden_Space_committed 3.49700096E8\n# TYPE jvm_memory_pools_PS_Eden_Space_init gauge\njvm_memory_pools_PS_Eden_Space_init 4.22576128E8\n# TYPE jvm_memory_pools_PS_Eden_Space_max gauge\njvm_memory_pools_PS_Eden_Space_max 1.110966272E9\n# TYPE jvm_memory_pools_PS_Eden_Space_usage gauge\njvm_memory_pools_PS_Eden_Space_usage 0.17698545577448457\n# TYPE jvm_memory_pools_PS_Eden_Space_used gauge\njvm_memory_pools_PS_Eden_Space_used 1.96624872E8\n# TYPE jvm_memory_pools_PS_Eden_Space_used_after_gc gauge\njvm_memory_pools_PS_Eden_Space_used_after_gc 0.0\n# TYPE jvm_memory_pools_PS_Old_Gen_committed gauge\njvm_memory_pools_PS_Old_Gen_committed 1.1272192E9\n# TYPE jvm_memory_pools_PS_Old_Gen_init gauge\njvm_memory_pools_PS_Old_Gen_init 1.1272192E9\n# TYPE jvm_memory_pools_PS_Old_Gen_max gauge\njvm_memory_pools_PS_Old_Gen_max 2.253914112E9\n# TYPE jvm_memory_pools_PS_Old_Gen_usage gauge\njvm_memory_pools_PS_Old_Gen_usage 0.014950035505168354\n# TYPE jvm_memory_pools_PS_Old_Gen_used gauge\njvm_memory_pools_PS_Old_Gen_used 3.3696096E7\n# TYPE jvm_memory_pools_PS_Old_Gen_used_after_gc gauge\njvm_memory_pools_PS_Old_Gen_used_after_gc 2.3791152E7\n# TYPE jvm_memory_pools_PS_Survivor_Space_committed gauge\njvm_memory_pools_PS_Survivor_Space_committed 1048576.0\n# TYPE jvm_memory_pools_PS_Survivor_Space_init gauge\njvm_memory_pools_PS_Survivor_Space_init 7.0254592E7\n# TYPE jvm_memory_pools_PS_Survivor_Space_max gauge\njvm_memory_pools_PS_Survivor_Space_max 1048576.0\n# TYPE jvm_memory_pools_PS_Survivor_Space_usage gauge\njvm_memory_pools_PS_Survivor_Space_usage 0.59375\n# TYPE jvm_memory_pools_PS_Survivor_Space_used gauge\njvm_memory_pools_PS_Survivor_Space_used 622592.0\n# TYPE jvm_memory_pools_PS_Survivor_Space_used_after_gc gauge\njvm_memory_pools_PS_Survivor_Space_used_after_gc 622592.0\n# TYPE jvm_memory_total_committed gauge\njvm_memory_total_committed 1.644478464E9\n# TYPE jvm_memory_total_init gauge\njvm_memory_total_init 1.697972224E9\n# TYPE jvm_memory_total_max gauge\njvm_memory_total_max 3.999268864E9\n# TYPE jvm_memory_total_used gauge\njvm_memory_total_used 3.82665128E8\n# TYPE jvm_thread_blocked_count gauge\njvm_thread_blocked_count 0.0\n# TYPE jvm_thread_count gauge\njvm_thread_count 82.0\n# TYPE jvm_thread_daemon_count gauge\njvm_thread_daemon_count 11.0\n# TYPE jvm_thread_deadlock_count gauge\njvm_thread_deadlock_count 0.0\n# TYPE jvm_thread_new_count gauge\njvm_thread_new_count 0.0\n# TYPE jvm_thread_runnable_count gauge\njvm_thread_runnable_count 25.0\n# TYPE jvm_thread_terminated_count gauge\njvm_thread_terminated_count 0.0\n# TYPE jvm_thread_timed_waiting_count gauge\njvm_thread_timed_waiting_count 10.0\n# TYPE jvm_thread_waiting_count gauge\njvm_thread_waiting_count 47.0\n```"
  },
  {
    "name": "otoroshi-protocol.md",
    "id": "/topics/otoroshi-protocol.md",
    "url": "/topics/otoroshi-protocol.html",
    "title": "The Otoroshi communication protocol",
    "content": "# The Otoroshi communication protocol\n\nThe exchange protocol secure the communication with an app. When it's enabled, Otoroshi will send for each request a value in pre-selected token header, and will check the same header in the return request.\n\n### V1 challenge\n\nIf you enable secure communication for a given service with `V1 - simple values exchange` activated, you will have to add a filter on the target application that will take the `Otoroshi-State` header and return it in a header named `Otoroshi-State-Resp`. \n\n@@@ div { .centered-img }\n<img src=\"../imgs/exchange.png\" />\n@@@\n\nyou can find an example project that implements V1 challenge [here](https://github.com/MAIF/otoroshi/tree/master/demos/challenge)\n\n### V2 challenge\n\nIf you enable secure communication for a given service with `V2 - signed JWT token exhange` activated, you will have to add a filter on the target application that will take the `Otoroshi-State` header value containing a JWT token, verify it's content signature then extract a claim named `state` and return a new JWT token in a header named `Otoroshi-State-Resp` with the `state` value in a claim named `state-resp`. By default, the signature algorithm is HMAC+SHA512 but can you can choose your own. The sent and returned JWT tokens have short TTL to avoid being replayed. You must be validate the tokens TTL. The audience of the response token must be `Otoroshi` and you have to specify `iat`, `nbf` and `exp`.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/exchange-2.png\" />\n@@@\n\nyou can find an example project that implements V2 challenge [here](https://github.com/MAIF/otoroshi/tree/master/demos/challenge)\n\n### Info. token\n\nOtoroshi is also sending a JWT token in a header named `Otoroshi-Claim` that the target app can validate too.\n\nThe `Otoroshi-Claim` is a JWT token containing some informations about the service that is called and the client if available. You can choose between a legacy version of the token and a new one that is more clear and structured.\n\nBy default, the otoroshi jwt token is signed with the `app.claim.sharedKey` config property (or using the `$CLAIM_SHAREDKEY` env. variable) and uses the `HMAC512` signing algorythm. But it is possible to customize how the token is signed from the service descriptor page in the `Otoroshi exchange protocol` section. \n\n@@@ div { .centered-img }\n<img src=\"../imgs/sec-com-signing-bis.png\" />\n@@@\n\nusing another signing algo.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/sec-com-signing-2-bis.png\" />\n@@@\n\nhere you can choose the signing algorithm and the secret/keys used. You can use syntax like `${env.MY_ENV_VAR}` or `${config.my.config.path}` to provide secret/keys values. \n\nFor example, for a service named `my-service` with a signing key `secret` with `HMAC512` signing algorythm, the basic JWT token that will be sent should look like the following\n\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiItLSIsImF1ZCI6Im15LXNlcnZpY2UiLCJpc3MiOiJPdG9yb3NoaSIsImV4cCI6MTUyMTQ0OTkwNiwiaWF0IjoxNTIxNDQ5ODc2LCJqdGkiOiI3MTAyNWNjMTktMmFjNy00Yjk3LTljYzctMWM0ODEzYmM1OTI0In0.mRcfuFVFPLUV1FWHyL6rLHIJIu0KEpBkKQCk5xh-_cBt9cb6uD6enynDU0H1X2VpW5-bFxWCy4U4V78CbAQv4g\n```\n\nif you decode it, the payload will look something like\n\n```json\n{\n  \"sub\": \"apikey_client_id\",\n  \"aud\": \"my-service\",\n  \"iss\": \"Otoroshi\",\n  \"exp\": 1521449906,\n  \"iat\": 1521449876,\n  \"jti\": \"71025cc19-2ac7-4b97-9cc7-1c4813bc5924\"\n}\n```\n\nIf you want to validate the `Otoroshi-Claim` on the target app side to ensure that the input requests only comes from `Otoroshi`, you will have to write an HTTP filter to do the job. For instance, if you want to write a filter to make sure that requests only comes from Otoroshi, you can write something like the following (using playframework 2.6).\n\nScala\n:   @@snip [filter.scala](../snippets/filter.scala)\n\nJava\n:   @@snip [filter.java](../snippets/filter.java)\n"
  },
  {
    "name": "pki.md",
    "id": "/topics/pki.md",
    "url": "/topics/pki.html",
    "title": "Otoroshi's PKI",
    "content": "# Otoroshi's PKI\n\nWith Otoroshi, you can add your own certificates, your own CA and even create self signed certificates or certificates from CAs. You can enable auto renewal of thoses self signed certificates or certificates generated. Certificates have to be created with the certificate chain and the private key in PEM format.\n\nAn Otoroshi instance always starts with 5 auto-generated certificates. \n\nThe highest certificate is the **Otoroshi Default Root CA Certificate**. This certificate is used by Otoroshi to sign the intermediate CA.\n\n**Otoroshi Default Intermediate CA Certificate**: first intermediate CA that must be used to issue new certificates in Otoroshi. Creating certificates directly from the CA root certificate increases the risk of root certificate compromise, and if the CA root certificate is compromised, the entire trust infrastructure built by the SSL provider will fail\n\nThis intermediate CA signed three certificates :\n\n*  **Otoroshi Default Client certificate**: \n*  **Otoroshi Default Jwt Signing Keypair**: default keypair (composed of a public and private key), exposed on `https://xxxxxx/.well-known/jwks.json`, that can be used to sign and verify JWT verifier\n*  **Otoroshi Default Wildcard Certificate**: this certificate has `*.oto.tools` as common name. It can be very useful to the development phase\n\n## The PKI API\n\nThe Otoroshi's PKI can be managed using the admin api of otoroshi (by default admin api is exposed on https://otoroshi-api.xxxxx)\n\nLink to the complete swagger section about PKI : https://maif.github.io/otoroshi/swagger-ui/index.html#/pki\n\n* `POST`    [/api/pki/certs/_letencrypt](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genLetsEncryptCert): generates a certificate using Let's Encrypt or any ACME compatible system\n* `POST`    [/api/pki/certs/_p12](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.importCertFromP12): import a .p12 file as client certificates\n* `POST`    [/api/pki/certs/_valid](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.certificateIsValid): check if a certificate is valid (based on its own data)\n* `POST`    [/api/pki/certs/_data](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.certificateData): extract data from a certificate\n* `POST`    [/api/pki/certs](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genSelfSignedCert): generates a self signed certificates\n* `POST`    [/api/pki/csrs](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genCsr) : generates a CSR\n* `POST`    [/api/pki/keys](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genKeyPair) : generates a keypair\n* `POST`    [/api/pki/cas](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genSelfSignedCA)  : generates a self signed CA\n* `POST`    [/api/pki/cas/:ca/certs/_sign](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.signCert): sign a certificate based on CSR\n* `POST`    [/api/pki/cas/:ca/certs](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genCert): generates a certificate\n* `POST`    [/api/pki/cas/:ca/cas](https://maif.github.io/otoroshi/swagger-ui/index.html#/pki/otoroshi.controllers.adminapi.PkiController.genSubCA) : generates a sub-CA\n\n## The PKI UI\n\nAll generated certificates are listed in the `https://xxxxxx/bo/dashboard/certificates` page. All those certificates can be used to serve traffic with TLS, perform mTLS calls, sign and verify JWT tokens.\n\nThe PKI UI are composed of these following actions:\n\n* **Add item**: redirects the user on the certificate creation page. Its useful when you already had a certificate (like a pem file) and that you want to load it in Otoroshi.\n* **Let's Encrypt certificate**: asks a certificate matching a given host to Lets encrypt\n* **Create certificate**: issues a certificate with an existing Otoroshi certificate as CA. You can create a client certificate, a server certificate or a keypair certiciate that will be used to verify and sign JWT tokens.\n* **Import .p12 file**: loads a p12 file as certificate\n\nUnder these buttons, you have the list of current certificates, imported or generated, revoked or not. For each certificate, you will find: \n\n* a **name** \n* a **description** \n* the **subject** \n* the **type** of certificate (CA / client / keypair / certificate)\n* the **revoked reason** (empty if not) \n* the **creation date** following by its **expiration date**.\n\n## Exposed public keys\n\nThe Otoroshi certificate can be turned and used as keypair (simple action that can be executed by editing a certificate or during its creation, or using the admin api). A Otoroski keypair can be used to sign and verify JWT tokens with asymetric signature. Once a jwt token is signed with a keypair, it can be necessary to provide a way to the services to verify the tokens received by Otoroshi. This usage is cover by Otoroshi by the flag `Public key exposed`, available on each certificate.\n\nOtoroshi exposes each keypair with the flag enabled, on the following routes:\n\n* `https://xxxxxxxxx.xxxxxxx.xx/.well-known/otoroshi/security/jwks.json`\n* `https://otoroshi-api.xxxxxxx.xx/.well-known/jwks.json`\n\nOn these routes, you will find the list of public keys exposed using [the JWK standard](https://datatracker.ietf.org/doc/html/rfc7517)\n\n\n## OCSP Responder\n\nOtoroshi is able to revocate a certificate, directly from the UI, and to add a revocation status to specifiy the reason. The revocation reason can be :\n\n* `VALID`: The certificate is not revoked\n* `UNSPECIFIED`: Can be used to revoke certificates for reasons other than the specific codes.\n* `KEY_COMPROMISE`: It is known or suspected that the subject's private key or other aspects have been compromised.\n* `CA_COMPROMISE`: It is known or suspected that the subject's private key or other aspects have been compromised.\n* `AFFILIATION_CHANGED`: The subject's name or other information in the certificate has been modified but there is no cause to suspect that the private key has been compromised.\n* `SUPERSEDED`: The certificate has been superseded but there is no cause to suspect that the private key has been compromised\n* `CESSATION_OF_OPERATION`: The certificate is no longer needed for the purpose for which it was issued but there is no cause to suspect that the private key has been compromised\n* `CERTIFICATE_HOLD`: The certificate is temporarily revoked but there is no cause to suspect that the private kye has been compromised\n* `REMOVE_FROM_CRL`: The certificate has been unrevoked\n* `PRIVILEGE_WITH_DRAWN`: The certificate was revoked because a privilege contained within that certificate has been withdrawn\n* `AA_COMPROMISE`: It is known or suspected that aspects of the AA validated in the attribute certificate, have been compromised\n\nOtoroshi supports the Online Certificate Status Protocol for obtaining the revocation status of its certificates. The OCSP endpoint is also add to any generated certificate. This endpoint is available at `https://otoroshi-api.xxxxxx/.well-known/otoroshi/security/ocsp`\n\n## A.I.A : Authority Information Access\n\nOtoroshi provides a way to add the A.I.A in the certificate. This certificate extension contains :\n\n* Information about how to get the issuer of this certificate (CA issuer access method)\n* Address of the OCSP responder from where revocation of this certificate can be checked (OCSP access method)\n\n`https://xxxxxxxxxx/.well-known/otoroshi/security/certificates/:cert-id`"
  },
  {
    "name": "sessions-mgmt.md",
    "id": "/topics/sessions-mgmt.md",
    "url": "/topics/sessions-mgmt.html",
    "title": "Sessions management",
    "content": "# Sessions management\n\n## Admins\n\nAll logged users to an Otoroshi instance are administrators. An user session is created for each sucessfull connection to the UI. \n\nThese sessions are listed in the `Admin users sessions` (available at this location of your instance */bo/dashboard/sessions/admin*).\n\nAn admin user session is composed of: \n\n* `name`: the name of the connected user\n* `email`: the unique email\n* `Created at`: the creation date of the user session\n* `Expires at`: date until the user session is drop\n* `Profile`: user profile, at JSON format, containing name, email and others linked metadatas\n* `Rights`: list of rules to authorize the connected user on each tenant and teams.\n* `Discard session`: action to kill a session. On click, a modal will appear with the session ID\n\nIn the `Admin users sessions` page, you have two more actions:\n\n* `Discard all sessions`: kills all current sessions (including the session of the owner of this action)\n* `Discard old sessions`: kill all outdated sessions\n\n## Private apps\n\nAll logged users to a protected application has an private user session.\n\nThese sessions are listed in the `Private apps users sessions` (available at this location of your instance */bo/dashboard/sessions/private*).\n\nAn private user session is composed of: \n\n* `name`: the name of the connected user\n* `email`: the unique email\n* `Created at`: the creation date of the user session\n* `Expires at`: date until the user session is drop\n* `Profile`: user profile, at JSON format, containing name, email and others linked metadatas\n* `Meta.`: list of metadatas added by the authentication module.\n* `Tokens`: list of tokens received from the identity provider used. In the case of a memory authentication, this part will keep empty.\n* `Discard session`: action to kill a session. On click, a modal will appear with the session ID\n"
  },
  {
    "name": "tls.md",
    "id": "/topics/tls.md",
    "url": "/topics/tls.html",
    "title": "TLS",
    "content": "# TLS\n\nas you might have understand, otoroshi can store TLS certificates and use them dynamically. It means that once a certificate is imported or created in otoroshi, you can immediately use it to serve http request over TLS, to call https backends that requires mTLS or that do not have certicates signed by a globally knowned authority.\n\n## TLS termination\n\nany certficate added to otoroshi with a valid `CN` and `SANs` can be used in the following seconds to serve https requests. If you do not provide a private key with a certificate chain, the certificate will only be trusted like a CA. If you want to perform mTLS calls on you otoroshi instance, do not forget to enabled it (it is disabled by default for performance reasons as the TLS handshake is bigger with mTLS enabled)\n\n```sh\notoroshi.ssl.fromOutside.clientAuth=None|Want|Need\n```\n\nor using env. variables\n\n```sh\nSSL_OUTSIDE_CLIENT_AUTH=None|Want|Need\n```\n\n### TLS termination configuration\n\nYou can configure TLS termination statically using config. file or env. variables. Everything is available at `otoroshi.tls`\n\n```conf\notoroshi {\n  tls {\n    # the cipher suites used by otoroshi TLS termination\n    cipherSuitesJDK11 = [\"TLS_AES_128_GCM_SHA256\", \"TLS_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\", \"TLS_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_RSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_RSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\", \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\"]\n    cipherSuitesJDK8 = [\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\", \"TLS_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\", \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_RSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\", \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\", \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_RSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\", \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\", \"SSL_RSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\", \"TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\", \"SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA\", \"SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\", \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\"]\n    cipherSuites = []\n    # the protocols used by otoroshi TLS termination\n    protocolsJDK11 = [\"TLSv1.3\", \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\"]\n    protocolsJDK8 = [\"SSLv2Hello\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"]\n    protocols = []\n    # the JDK cacert access\n    cacert {\n      path = \"$JAVA_HOME/lib/security/cacerts\"\n      password = \"changeit\"\n    }\n    # the mtls mode\n    fromOutside {\n      clientAuth = \"None\"\n      clientAuth = ${?SSL_OUTSIDE_CLIENT_AUTH}\n    }\n    # the default trust mode\n    trust {\n      all = false\n      all = ${?OTOROSHI_SSL_TRUST_ALL}\n    }\n    # some initial cacert access, useful to include non standard CA when starting (file paths)\n    initialCacert = ${?CLUSTER_WORKER_INITIAL_CACERT}\n    initialCacert = ${?INITIAL_CACERT}\n    initialCert = ${?CLUSTER_WORKER_INITIAL_CERT}\n    initialCert = ${?INITIAL_CERT}\n    initialCertKey = ${?CLUSTER_WORKER_INITIAL_CERT_KEY}\n    initialCertKey = ${?INITIAL_CERT_KEY}\n    # initialCerts = [] \n  }\n}\n```\n\n\n### TLS termination settings\n\nIt is possible to adjust the behavior of the TLS termination from the `danger zone` at the `Tls Settings` section. Here you can either define that a non-matching SNI call will use a random TLS certtificate to reply or will use a default domain (the TLS certificate associated to this domain) to reply. Here you can also choose if you want to trust all the CAs trusted by your JDK when performing TLS calls `Trust JDK CAs (client)` or when receiving mTLS calls `Trust JDK CAs (server)`. If you disable the later, it is possible to select the list of CAs presented to the client during mTLS handshake.\n\n### Certificates auto generation\n\nit is also possible to generate non-existing certificate on the fly without losing the request. If you are interested by this feature, you can enable it in the `danger zone` at the `Auto Generate Certificates` section. Here you'll have to enable it and select the CA that will generate the certificate. Of course, the client will have to trust the selected CA. You can also add filters to choose which domain are allowed to generate certificates or not. The `Reply Nicely` flag is used to reply a nice error message (ie. human readable) telling that it's not possible to have an auto certficate for the current domain. \n\n## Backends TLS and mTLS calls\n\nFor any call to a backend, it is possible to customize the TLS behavior \n\n@@@ div { .centered-img }\n<img src=\"../imgs/tls-call-settings.png\" />\n@@@\n\nhere you can define your level of trust (trust all, loose verification) or even select on or more CAs you will trust for the following backend calls. You can also select the client certificate that will be used for the following backend calls\n\n## Keypair for signing and verification\n\nIt is also possible to use the keypair contained in a certificate to sign and verificate JWT token signature. You can mark an existing certificate in otoroshi as a keypair using the `keypair` on the certificate page.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/jwt-token-keypair-validation.png\" />\n@@@\n"
  },
  {
    "name": "user-rights.md",
    "id": "/topics/user-rights.md",
    "url": "/topics/user-rights.html",
    "title": "Otoroshi user rights",
    "content": "# Otoroshi user rights\n\nIn Otoroshi, all users are considered **Administrators**. This choice is reinforced by the fact that Otoroshi is designed to be an administrator user interface and not an interface for users who simply want to view information. For this type of use, we encourage to use the admin API rather than giving access to the user interface.\n\nThe Otoroshi rights are split by a list of authorizations on **organizations** and **teams**. \n\nLet's taking an example where we want to authorize an administrator user on all organizations and teams.\n\nThe list of rights will be :\n\n```json\n[\n  {\n    \"tenant\": \"*:rw\", # (1)\n    \"teams\": [\"*:rw\"] # (2)\n  }\n]\n```\n\n* (1): this field, separated by a colon, indicates the name of the tenant and the associated rights. In our case, we set `*` to apply the rights to all tenants, and the `rw` to get the read and write access on them.\n* (2): the `teams` array field, represents the list of rights, applied by team. The behaviour is the same as the tenant field, we define the team or the wildcard, followed by the rights\n\nif you want to have an user that is administrator only for one organization, the rights will be :\n\n```json\n[\n  {\n    \"tenant\": \"orga-1:rw\",\n    \"teams\": [\"*:rw\"]\n  }\n]\n```\n\nif you want to have an user that is administrator only for two organization, the rights will be :\n\n```json\n[\n  {\n    \"tenant\": \"orga-1:rw\",\n    \"teams\": [\"*:rw\"]\n  },\n  {\n    \"tenant\": \"orga-2:rw\",\n    \"teams\": [\"*:rw\"]\n  }\n]\n```\n\nif you want to have an user that can only see 3 teams of one organization and one team in the other, the rights will be :\n\n```json\n[\n  {\n    \"tenant\": \"orga-1:rw\",\n    \"teams\": [\n      \"team-1:rw\",\n      \"team-2:rw\",\n      \"team-3:rw\",\n    ]\n  },\n  {\n    \"tenant\": \"orga-2:rw\",\n    \"teams\": [\n      \"team-4:rw\"\n    ]\n  }\n]\n```\n\nThe list of possible rights for an organization or a team is:\n\n* **r**: read access\n* **w**: write access\n* **not**: none access to the resource\n\nThe list of possible tenant and teams are your created tenants and teams, and the wildcard to define rights to all resources once.\n\nThe user rights is defined by the @ref:[authentication modules](../entities/auth-modules.md).\n"
  }
]
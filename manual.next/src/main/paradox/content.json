[{"name":"about.md","id":"/about.md","url":"/about.html","title":"About Otoroshi","content":"# About Otoroshi\n\nAt the beginning of 2017, we had the need to create a new environment to be able to create new \"digital\" products very quickly in an agile fashion at <a href=\"https://www.maif.fr/\" target=\"_blank\">MAIF</a>. Naturally we turned to PaaS solutions and chose the excellent <a href=\"https://www.clever-cloud.com/\">Clever-Cloud</a> product to run our apps. \n\nWe also chose that every feature team will have the freedom to choose its own technological stack to build its product. It was a nice move but it has also introduced some challenges in terms of homogeneity for traceability, security, logging, ... because we did not want to force library usage in the products. We could have used something like <a href=\"http://philcalcado.com/2017/08/03/pattern_service_mesh.html\" target=\"_blank\">Service Mesh Pattern</a> but the deployement model of <a href=\"https://www.clever-cloud.com/\">Clever-Cloud</a> prevented us to do it.\n\nThe right solution was to use a reverse proxy or some kind of API Gateway able to provide tracability, logging, security with apikeys, quotas, DNS as a service locator, etc. We needed something easy to use, with a human friendly UI, a nice API to extends its features, true hot reconfiguration, able to generate internal events for third party usage. A couple of solutions were available at that time, but not one seems to fit our needs, there was always something missing, too complicated for our needs or not playing well with <a href=\"https://www.clever-cloud.com/\">Clever-Cloud</a> deployment model.\n\nAt some point, we tried to write a small prototype to explore what could be our dream reverse proxy. The design was very simple, there were some rough edges but every major feature needed was there waiting to be enhanced.\n\n**Otoroshi** was born and we decided to move ahead with our hairy monster :)\n\n## Philosophy \n\nEvery OSS product build at <a href=\"https://www.maif.fr/\" target=\"_blank\">MAIF</a> like <a href=\"https://maif.github.io/izanami/\" target=\"_blank\">Izanami</a> follow a common philosophy. \n\n* the services or API provided should be technology agnostic.\n* http first: http is the right answer to the previous quote   \n* api First: The UI is just another client of the api. \n* secured: The services exposed need authentication for both humans or machines  \n* event based: The services should expose a way to get notified of what happened inside.  \n"},{"name":"api.md","id":"/api.md","url":"/api.html","title":"Admin REST API","content":"# Admin REST API\n\nOtoroshi provides a fully featured REST admin API to perform almost every operation possible in the Otoroshi dashboard. The Otoroshi dashbaord is just a regular consumer of the admin API.\n\nUsing the admin API, you can do whatever you want and enhance your Otoroshi instances with a lot of features that will feet your needs.\n\n## Swagger descriptor\n\nThe Otoroshi admin API is described using OpenAPI format and is available at :\n\nhttps://maif.github.io/otoroshi/manual/code/openapi.json\n\nEvery Otoroshi instance provides its own embedded OpenAPI descriptor at :\n\nhttp://otoroshi.oto.tools:8080/api/openapi.json\n\n## Swagger documentation\n\nYou can read the OpenAPI descriptor in a more human friendly fashion using `Swagger UI`. The swagger UI documentation of the Otoroshi admin API is available at :\n\nhttps://maif.github.io/otoroshi/swagger-ui/index.html\n\nEvery Otoroshi instance provides its own embedded OpenAPI descriptor at :\n\nhttp://otoroshi.oto.tools:8080/api/swagger/ui\n\nYou can also read the swagger UI documentation of the Otoroshi admin API below :\n\n@@@ div { .swagger-frame }\n\n\n@@@\n"},{"name":"architecture.md","id":"/architecture.md","url":"/architecture.html","title":"Architecture","content":"# Architecture\n\nWhen we started the development of Otoroshi, we had several classical patterns in mind like `Service gateway`, `Service locator`, `Circuit breakers`, etc ...\n\nAt start we thought about providing a bunch of librairies that would be included in each microservice or app to perform these tasks. But the more we were thinking about it, the more it was feeling weird, unagile, etc, it also prevented us to use any technical stack we wanted to use. So we decided to change our approach to something more universal.\n\nWe chose to make Otoroshi the central part of our microservices system, something between a reverse-proxy, a service gateway and a service locator where each call to a microservice (even from another microservice) must pass through Otoroshi. There are multiple benefits to do that, each call can be logged, audited, monitored, integrated with a circuit breaker, etc without imposing libraries and technical stack. Any service is exposed through its own domain and we rely only on DNS to handle the service location part. Any access to a service is secured by default with an api key and is supervised by a circuit breaker to avoid cascading failures.\n\n@@@ div { .centered-img }\n<img src=\"./img/architecture-1-bis.png\" />\n@@@\n\nOtoroshi tries to embrace our @ref:[global philosophy](./about.md#philosophy) by providing a full featured REST admin api, a gorgeous admin dashboard written in [React](https://reactjs.org/) that uses the api, by generating traffic events, alerts events, audit events that can be consumed by several channels. Otoroshi also supports a bunch of datastores to better match with different use cases.\n\n@@@ div { .centered-img }\n<img src=\"./img/architecture-2-bis.png\" />\n@@@\n"},{"name":"aws.md","id":"/deploy/aws.md","url":"/deploy/aws.html","title":"AWS - Elastic Beanstalk","content":"# AWS - Elastic Beanstalk\n\nNow you want to use Otoroshi on AWS. There are multiple options to deploy Otoroshi on AWS, \nfor instance :\n\n* You can deploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) on [Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html)\n* You can create a basic [Amazon EC2](https://docs.aws.amazon.com/fr_fr/AWSEC2/latest/UserGuide/concepts.html), access it via SSH, then \ndeploy the @ref:[otoroshi.jar](../install/get-otoroshi.md#from-jar-file)     \n* Or you can use [AWS Elastic Beanstalk](https://aws.amazon.com/fr/elasticbeanstalk)\n\nIn this section we are going to cover how to deploy Otoroshi on [AWS Elastic Beanstalk](https://aws.amazon.com/fr/elasticbeanstalk). \n\n## AWS Elastic Beanstalk Overview\nUnlike Clever Cloud, to deploy an application on AWS Elastic Beanstalk, you don't link your app to your VCS repository, push your code and expect it to be built and run.\n\nAWS Elastic Beanstalk does only the run part. So you have to handle your own build pipeline, upload a Zip file containing your runnable, then AWS Elastic Beanstalk will take it from there.  \n  \nEg: for apps running on the JVM (Scala/Java/Kotlin) a Zip with the jar inside would suffice, for apps running in a Docker container, a Zip with the DockerFile would be enough.   \n\n\n## Prepare your deployment target\nActually, there are 2 options to build your target. \n\nEither you create a DockerFile from this @ref:[Docker image](../install/get-otoroshi.md#from-docker), build a zip, and do all the Otoroshi custom configuration using ENVs.\n\nOr you download the @ref:[otoroshi.jar](../install/get-otoroshi.md#from-jar-file), do all the Otoroshi custom configuration using your own otoroshi.conf, and create a DockerFile that runs the jar using your otoroshi.conf. \n\nFor the second option your DockerFile would look like this :\n\n```dockerfile\nFROM openjdk:8\nVOLUME /tmp\nEXPOSE 8080\nADD otoroshi.jar otoroshi.jar\nADD otoroshi.conf otoroshi.conf\nRUN sh -c 'touch /otoroshi.jar'\nENV JAVA_OPTS=\"\"\nENTRYPOINT [ \"sh\", \"-c\", \"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -Dconfig.file=/otoroshi.conf -jar /otoroshi.jar\" ]\n``` \n \nI'd recommend the second option.\n       \nNow Zip your target (Jar + Conf + DockerFile) and get ready for deployment.     \n\n## Create an Otoroshi instance on AWS Elastic Beanstalk\nFirst, go to [AWS Elastic Beanstalk Console](https://eu-west-3.console.aws.amazon.com/elasticbeanstalk/home?region=eu-west-3#/welcome), don't forget to sign in and make sure that you are in the good region (eg : eu-west-3 for Paris).\n\nHit **Get started** \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-0.png\" />\n@@@\n\nSpecify the **Application name** of your application, Otoroshi for example.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-1.png\" />\n@@@\n \nChoose the **Platform** of the application you want to create, in your case use Docker.\n\nFor **Application code** choose **Upload your code** then hit **Upload**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-2.png\" />\n@@@\n\nBrowse the zip created in the [previous section](#prepare-your-deployment-target) from your machine. \n\nAs you can see in the image above, you can also choose an S3 location, you can imagine that at the end of your build pipeline you upload your Zip to S3, and then get it from there (I wouldn't recommend that though).\n  \nWhen the upload is done, hit **Configure more options**.\n   \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-3.png\" />\n@@@ \n \nRight now an AWS Elastic Beanstalk application has been created, and by default an environment named Otoroshi-env is being created as well.\n\nAWS Elastic Beanstalk can manage multiple environments of the same application, for instance environments can be (prod, preprod, expriments...).  \n\nOtoroshi is a bit particular, it doesn't make much sense to have multiple environments, since Otoroshi will handle all the requests from/to downstream services regardless of the environment.        \n \nAs you see in the image above, we are now configuring the Otoroshi-env, the one and only environment of Otoroshi.\n  \nFor **Configuration presets**, choose custom configuration, now you have a load balancer for your environment with the capacity of at least one instance and at most four.\nI'd recommend at least 2 instances, to change that, on the **Capacity** card hit **Modify**.         \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-4.png\" />\n@@@\n\nChange the **Instances** to min 2, max 4 then hit **Save**. For the **Scaling triggers**, I'd keep the default values, but know that you can edit the capacity config any time you want, it only costs a redeploy, which will be done automatically by the way.\n       \nInstances size is by default t2.micro, which is a bit small for running Otoroshi, I'd recommend a t2.medium.     \nOn the **Instances** card hit **Modify**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-5.png\" />\n@@@\n\nFor **Instance type** choose t2.medium, then hit **Save**, no need to change the volume size, unless you have a lot of http call faults, which means a lot more logs, in that case the default volume size may not be enough.\n\nThe default environment created for Otoroshi, for instance Otoroshi-env, is a web server environment which fits in your case, but the thing is that on AWS Elastic Beanstalk by default a web server environment for a docker-based application, runs behind an Nginx proxy.\nWe have to remove that proxy. So on the **Software** card hit **Modify**.\n        \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-6.png\" />\n@@@        \n    \nFor **Proxy server** choose None then hit **Save**.\n\nAlso note that you can set Envs for Otoroshi in same page (see image below). \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-7.png\" />\n@@@  \n\nTo finalise the creation process, hit **Create app** on the bottom right.\n\nThe Otoroshi app is now created, and it's running which is cool, but we still don't have neither a **datastore** nor **https**.\n  \n## Create an Otoroshi datastore on AWS ElastiCache\n\nBy default Otoroshi uses non persistent memory to store it's data, Otoroshi supports many kinds of datastores. In this section we will be covering Redis datastore.   \n\nBefore starting, using a datastore hosted by AWS is not at all mandatory, feel free to use your own if you like, but if you want to learn more about ElastiCache, this section may interest you, otherwise you can skip it.\n\nGo to [AWS ElastiCache](https://eu-west-3.console.aws.amazon.com/elasticache/home?region=eu-west-3#) and hit **Get Started Now**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-8.png\" />\n@@@  \n\nFor **Cluster engine** keep Redis.\n\nChoose a **Name** for your datastore, for instance otoroshi-datastore.\n\nYou can keep all the other default values and hit **Create** on the bottom right of the page.\n\nOnce your Redis Cluster is created, it would look like the image below.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-9.png\" />\n@@@  \n\n\nFor applications in the same security group as your cluster, redis cluster is accessible via the **Primary Endpoint**. Don't worry the default security group is fine, you don't need any configuration to access the cluster from Otoroshi.\n\nTo make Otoroshi use the created cluster, you can either use Envs `APP_STORAGE=redis`, `REDIS_HOST` and `REDIS_PORT`, or set `app.storage=redis`, `app.redis.host` and `app.redis.port` in your otoroshi.conf.\n\n## Create SSL certificate and configure your domain\n\nOtoroshi has now a datastore, but not yet ready for use. \n\nIn order to get it ready you need to :\n\n* Configure Otoroshi with your domain \n* Create a wildcard SSL certificate for your domain\n* Configure Otoroshi AWS Elastic Beanstalk instance with the SSL certificate \n* Configure your DNS to redirect all traffic on your domain to Otoroshi  \n  \n### Configure Otoroshi with your domain\n\nYou can use ENVs or you can use a custom otoroshi.conf in your Docker container.\n\nFor the second option your otoroshi.conf would look like this :\n\n``` \n   include \"application.conf\"\n   http.port = 8080\n   app {\n     env = \"prod\"\n     domain = \"mysubdomain.oto.tools\"\n     rootScheme = \"https\"\n     snowflake {\n       seed = 0\n     }\n     events {\n       maxSize = 1000\n     }\n     backoffice {\n       subdomain = \"otoroshi\"\n       session {\n         exp = 86400000\n       }\n     }\n     \n     storage = \"redis\"\n     redis {\n        host=\"myredishost\"\n        port=myredisport\n     }\n   \n     privateapps {\n       subdomain = \"privateapps\"\n     }\n   \n     adminapi {\n       targetSubdomain = \"otoroshi-admin-internal-api\"\n       exposedSubdomain = \"otoroshi-api\"\n       defaultValues {\n         backOfficeGroupId = \"admin-api-group\"\n         backOfficeApiKeyClientId = \"admin-client-id\"\n         backOfficeApiKeyClientSecret = \"admin-client-secret\"\n         backOfficeServiceId = \"admin-api-service\"\n       }\n       proxy {\n         https = true\n         local = false\n       }\n     }\n     claim {\n       sharedKey = \"myclaimsharedkey\"\n     }\n   }\n   \n   play.http {\n     session {\n       secure = false\n       httpOnly = true\n       maxAge = 2147483646\n       domain = \".mysubdomain.oto.tools\"\n       cookieName = \"oto-sess\"\n     }\n   }\n``` \n\n### Create a wildcard SSL certificate for your domain\n\nGo to [AWS Certificate Manager](https://eu-west-3.console.aws.amazon.com/acm/home?region=eu-west-3#/firstrun).\n\nBelow **Provision certificates** hit **Get started**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-10.png\" />\n@@@   \n \nKeep the default selected value **Request a public certificate** and hit **Request a certificate**.\n \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-11.png\" />\n@@@  \n\nPut your **Domain name**, use *. for wildcard, for instance *\\*.mysubdomain.oto.tools*, then hit **Next**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-12.png\" />\n@@@  \n\nYou can choose between **Email validation** and **DNS validation**, I'd recommend **DNS validation**, then hit **Review**.    \n    \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-13.png\" />\n@@@ \n \nVerify that you did put the right **Domain name** then hit **Confirm and request**.   \n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-14.png\" />\n@@@\n \nAs you see in the image above, to let Amazon do the validation you have to add the `CNAME` record to your DNS configuration. Normally this operation takes around one day.\n  \n### Configure Otoroshi AWS Elastic Beanstalk instance with the SSL certificate \n\nOnce the certificate is validated, you need to modify the configuration of Otoroshi-env to add the SSL certificate for HTTPS. \nFor that you need to go to [AWS Elastic Beanstalk applications](https://eu-west-3.console.aws.amazon.com/elasticbeanstalk/home?region=eu-west-3#/applications),\nhit **Otoroshi-env**, then on the left side hit **Configuration**, then on the **Load balancer** card hit **Modify**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-15.png\" />\n@@@\n\nIn the **Application Load Balancer** section hit **Add listener**.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-16.png\" />\n@@@\n\nFill the popup as the image above, then hit **Add**.   \n\nYou should now be seeing something like this : \n   \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-17.png\" />\n@@@   \n \n \nMake sure that your listener is enabled, and on the bottom right of the page hit **Apply**.\n\nNow you have **https**, so let's use Otoroshi.\n\n### Configure your DNS to redirect all traffic on your domain to Otoroshi\n  \nIt's actually pretty simple, you just need to add a `CNAME` record to your DNS configuration, that redirects *\\*.mysubdomain.oto.tools* to the DNS name of Otoroshi's load balancer.\n\nTo find the DNS name of Otoroshi's load balancer go to [AWS Ec2](https://eu-west-3.console.aws.amazon.com/ec2/v2/home?region=eu-west-3#LoadBalancers:tag:elasticbeanstalk:environment-name=Otoroshi-env;sort=loadBalancerName)\n\nYou would find something like this : \n  \n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-elb-18.png\" />\n@@@   \n\nThere is your DNS name, so add your `CNAME` record. \n \nOnce all these steps are done, the AWS Elastic Beanstalk Otoroshi instance, would now be handling all the requests on your domain. ;)    \n"},{"name":"clever-cloud.md","id":"/deploy/clever-cloud.md","url":"/deploy/clever-cloud.html","title":"Clever-Cloud","content":"# Clever-Cloud\n\nNow you want to use Otoroshi on Clever Cloud. Otoroshi has been designed and created to run on Clever Cloud and a lot of choices were made because of how Clever Cloud works.\n\n## Create an Otoroshi instance on CleverCloud\n\nIf you want to customize the configuration @ref:[use env. variables](../install/setup-otoroshi.md#environnement-variables), you can use [the example provided below](#example-of-clevercloud-env-variables)\n\nCreate a new CleverCloud app based on a clevercloud git repo (not empty) or a github project of your own (not empty).\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-jar-0.png\" />\n@@@\n\nThen choose what kind of app your want to create, for Otoroshi, choose `Java + Jar`\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-jar-1.png\" />\n@@@\n\nNext, set up choose instance size and auto-scalling. Otoroshi can run on small instances, especially if you just want to test it.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-2.png\" />\n@@@\n\nFinally, choose a name for your app\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-3.png\" />\n@@@\n\nNow you just need to customize environnment variables\n\nat this point, you can also add other env. variables to configure Otoroshi like in [the example provided below](#example-of-clevercloud-env-variables)\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-4-bis.png\" />\n@@@\n\nYou can also use expert mode :\n\n@@@ div { .centered-img }\n<img src=\"../imgs/deploy-cc-4.png\" />\n@@@\n\nNow, your app is ready, don't forget to add a custom domains name on the CleverCloud app matching the Otoroshi app domain. \n\n## Example of CleverCloud env. variables\n\nYou can add more env variables to customize your Otoroshi instance like the following. Use the expert mode to copy/paste all the values in one shot. If you want an real datastore, create a redis addon on clevercloud, link it to your otoroshi app and change the `APP_STORAGE` variable to `redis`\n\n<div id=\"clevercloud-envvars\"></div>\n\n<div class=\"hide\">\n```\nADMIN_API_CLIENT_ID=xxxx\nADMIN_API_CLIENT_SECRET=xxxxx\nADMIN_API_GROUP=xxxxxx\nADMIN_API_SERVICE_ID=xxxxxxx\nCLAIM_SHAREDKEY=xxxxxxx\nOTOROSHI_INITIAL_ADMIN_LOGIN=youremailaddress\nOTOROSHI_INITIAL_ADMIN_PASSWORD=yourpassword\nPLAY_CRYPTO_SECRET=xxxxxx\nSESSION_NAME=oto-session\nAPP_DOMAIN=yourdomain.tech\nAPP_ENV=prod\nAPP_STORAGE=inmemory\nAPP_ROOT_SCHEME=https\nCC_PRE_BUILD_HOOK=curl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/${latest_otoroshi_version}/otoroshi.jar'\nCC_JAR_PATH=./otoroshi.jar\nCC_JAVA_VERSION=11\nPORT=8080\nSESSION_DOMAIN=.yourdomain.tech\nSESSION_MAX_AGE=604800000\nSESSION_SECURE_ONLY=true\nUSER_AGENT=otoroshi\nMAX_EVENTS_SIZE=1\nWEBHOOK_SIZE=100\nAPP_BACKOFFICE_SESSION_EXP=86400000\nAPP_PRIVATEAPPS_SESSION_EXP=86400000\nENABLE_METRICS=true\nOTOROSHI_ANALYTICS_PRESSURE_ENABLED=true\nUSE_CACHE=true\n```\n</div>"},{"name":"clustering.md","id":"/deploy/clustering.md","url":"/deploy/clustering.html","title":"Otoroshi clustering","content":"# Otoroshi clustering\n\n@@@ warning\nTODO\n@@@"},{"name":"index.md","id":"/deploy/index.md","url":"/deploy/index.html","title":"Deploy to production","content":"# Deploy to production\n\nNow it's time to deploy Otoroshi in production, in this chapter we will see what kind of things you can do.\n\n* @ref:[Clustering](./clustering.md)\n* @ref:[Kubernetes](./kubernetes.md)\n* @ref:[Clever Cloud](./clever-cloud.md)\n* @ref:[AWS - Elastic Beanstalk](./aws.md)\n* @ref:[others](./other.md)  \n* @ref:[Scaling](./scaling.md)  \n\n@@@ index\n\n* [Clustering](./clustering.md)\n* [Kubernetes](./kubernetes.md)\n* [Clever Cloud](./clever-cloud.md)\n* [AWS - Elastic Beanstalk](./aws.md)\n* [others](./other.md)  \n* [Scaling](./scaling.md)  \n\n@@@"},{"name":"kubernetes.md","id":"/deploy/kubernetes.md","url":"/deploy/kubernetes.html","title":"Kubernetes","content":"# Kubernetes\n\nStarting at version 1.5.0, Otoroshi provides a native Kubernetes support. Multiple otoroshi jobs (that are actually kubernetes controllers) are provided in order to\n\n- sync kubernetes secrets of type `kubernetes.io/tls` to otoroshi certificates\n- act as a standard ingress controller (supporting `Ingress` objects)\n- provide Custom Resource Definitions (CRDs) to manage Otoroshi entities from Kubernetes and act as an ingress controller with its own resources\n\n## Installing otoroshi on your kubernetes cluster\n\n@@@ warning\nYou need to have cluster admin privileges to install otoroshi and its service account, role mapping and CRDs on a kubernetes cluster. We also advise you to create a dedicated namespace (you can name it `otoroshi` for example) to install otoroshi\n@@@\n\nIf you want to deploy otoroshi into your kubernetes cluster, you can download the deployment descriptors from https://github.com/MAIF/otoroshi/tree/master/kubernetes and use kustomize to create your own overlay.\n\nYou can also create a `kustomization.yaml` file with a remote base\n\n```yaml\nbases:\n- github.com/MAIF/otoroshi/kubernetes/kustomize/overlays/simple/?ref=v1.5.0-dev\n```\n\nThen deploy it with `kubectl apply -k ./overlays/myoverlay`. \n\nYou can also use Helm to deploy a simple otoroshi cluster on your kubernetes cluster\n\n```sh\nhelm repo add otoroshi https://maif.github.io/otoroshi/helm\nhelm install my-otoroshi otoroshi/otoroshi\n```\n\nBelow, you will find example of deployment. Do not hesitate to adapt them to your needs. Those descriptors have value placeholders that you will need to replace with actual values like \n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: ${domain}\n```\n\nyou will have to edit it to make it look like\n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: 'apis.my.domain'\n```\n\nif you don't want to use placeholders and environment variables, you can create a secret containing the configuration file of otoroshi\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: otoroshi-config\ntype: Opaque\nstringData:\n  oto.conf: >\n    include \"application.conf\"\n    app {\n      storage = \"redis\"\n      domain = \"apis.my.domain\"\n    }\n```\n\nand mount it in the otoroshi container\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: otoroshi-deployment\nspec:\n  selector:\n    matchLabels:\n      run: otoroshi-deployment\n  template:\n    metadata:\n      labels:\n        run: otoroshi-deployment\n    spec:\n      serviceAccountName: otoroshi-admin-user\n      terminationGracePeriodSeconds: 60\n      hostNetwork: false\n      containers:\n      - image: maif/otoroshi:1.5.0-dev-jdk11\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        args: ['-Dconfig.file=/usr/app/otoroshi/conf/oto.conf']\n        ports:\n          - containerPort: 8080\n            name: \"http\"\n            protocol: TCP\n          - containerPort: 8443\n            name: \"https\"\n            protocol: TCP\n        volumeMounts:\n        - name: otoroshi-config\n          mountPath: \"/usr/app/otoroshi/conf\"\n          readOnly: true\n      volumes:\n      - name: otoroshi-config\n        secret:\n          secretName: otoroshi-config\n        ...\n```\n\nYou can also create several secrets for each placeholder, mount them to the otoroshi container then use their file path as value\n\n```yaml\n env:\n  - name: APP_STORAGE_ROOT\n    value: otoroshi\n  - name: APP_DOMAIN\n    value: 'file:///the/path/of/the/secret/file'\n```\n\nyou can use the same trick in the config. file itself\n\n### Note on bare metal kubernetes cluster installation\n\n@@@ note\nBare metal kubernetes clusters don't come with support for external loadbalancers (service of type `LoadBalancer`). So you will have to provide this feature in order to route external TCP traffic to Otoroshi containers running inside the kubernetes cluster. You can use projects like [MetalLB](https://metallb.universe.tf/) that provide software `LoadBalancer` services to bare metal clusters or you can use and customize examples below.\n@@@\n\n@@@ warning\nWe don't recommand running Otoroshi behind an existing ingress controller (or something like that) as you will not be able to use features like TCP proxying, TLS, mTLS, etc. Also, this additional layer of reverse proxy will increase call latencies.\n@@@\n\n### Common manifests\n\nthe following manifests are always needed. They create otoroshi CRDs, tokens, role, etc. Redis deployment is not mandatory, it's just an example. You can use your own existing setup.\n\nrbac.yaml\n:   @@snip [rbac.yaml](../snippets/kubernetes/kustomize/base/rbac.yaml) \n\ncrds.yaml\n:   @@snip [crds.yaml](../snippets/kubernetes/kustomize/base/crds.yaml) \n\nredis.yaml\n:   @@snip [redis.yaml](../snippets/kubernetes/kustomize/base/redis.yaml) \n\n\n### Deploy a simple otoroshi instanciation on a cloud provider managed kubernetes cluster\n\nHere we have 2 replicas connected to the same redis instance. Nothing fancy. We use a service of type `LoadBalancer` to expose otoroshi to the rest of the world. You have to setup your DNS to bind otoroshi domain names to the `LoadBalancer` external `CNAME` (see the example below)\n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple/deployment.yaml) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple/dns.example) \n\n### Deploy a simple otoroshi instanciation on a bare metal kubernetes cluster\n\nHere we have 2 replicas connected to the same redis instance. Nothing fancy. The otoroshi instance are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple-baremetal/deployment.yaml) \n\nhaproxy.example\n:   @@snip [haproxy.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/haproxy.example) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal/dns.example) \n\n\n### Deploy a simple otoroshi instanciation on a bare metal kubernetes cluster using a DaemonSet\n\nHere we have one otoroshi instance on each kubernetes node (with the `otoroshi-kind: instance` label) with redis persistance. The otoroshi instances are exposed as `hostPort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/deployment.yaml) \n\nhaproxy.example\n:   @@snip [haproxy.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/haproxy.example) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/simple-baremetal-daemonset/dns.example) \n\n### Deploy an otoroshi cluster on a cloud provider managed kubernetes cluster\n\nHere we have 2 replicas of an otoroshi leader connected to a redis instance and 2 replicas of an otoroshi worker connected to the leader. We use a service of type `LoadBalancer` to expose otoroshi leader/worker to the rest of the world. You have to setup your DNS to bind otoroshi domain names to the `LoadBalancer` external `CNAME` (see the example below)\n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster/deployment.yaml) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster/dns.example) \n\n### Deploy an otoroshi cluster on a bare metal kubernetes cluster\n\nHere we have 2 replicas of otoroshi leader connected to the same redis instance and 2 replicas for otoroshi worker. The otoroshi instances are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/deployment.yaml) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/dns.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal/dns.example) \n\n### Deploy an otoroshi cluster on a bare metal kubernetes cluster using DaemonSet\n\nHere we have 1 otoroshi leader instance on each kubernetes node (with the `otoroshi-kind: leader` label) connected to the same redis instance and 1 otoroshi worker instance on each kubernetes node (with the `otoroshi-kind: worker` label). The otoroshi instances are exposed as `nodePort` so you'll have to add a loadbalancer in front of your kubernetes nodes to route external traffic (TCP) to your otoroshi instances. You have to setup your DNS to bind otoroshi domain names to your loadbalancer (see the example below). \n\ndeployment.yaml\n:   @@snip [deployment.yaml](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/deployment.yaml) \n\nnginx.example\n:   @@snip [nginx.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/nginx.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/dns.example) \n\ndns.example\n:   @@snip [dns.example](../snippets/kubernetes/kustomize/overlays/cluster-baremetal-daemonset/dns.example) \n\n## Using Otoroshi as an Ingress Controller\n\nIf you want to use Otoroshi as an [Ingress Controller](https://kubernetes.io/fr/docs/concepts/services-networking/ingress/), just go to the danger zone, and in `Global scripts` add the job named `Kubernetes Ingress Controller`.\n\nThen add the following configuration for the job (with your own tweaks of course)\n\n```json\n{\n  \"KubernetesConfig\": {\n    \"enabled\": true,\n    \"endpoint\": \"https://127.0.0.1:6443\",\n    \"token\": \"eyJhbGciOiJSUzI....F463SrpOehQRaQ\",\n    \"namespaces\": [\n      \"*\"\n    ]\n  }\n}\n```\n\nthe configuration can have the following values \n\n```javascript\n{\n  \"KubernetesConfig\": {\n    \"endpoint\": \"https://127.0.0.1:6443\", // the endpoint to talk to the kubernetes api, optional\n    \"token\": \"xxxx\", // the bearer token to talk to the kubernetes api, optional\n    \"userPassword\": \"user:password\", // the user password tuple to talk to the kubernetes api, optional\n    \"caCert\": \"/etc/ca.cert\", // the ca cert file path to talk to the kubernetes api, optional\n    \"trust\": false, // trust any cert to talk to the kubernetes api, optional\n    \"namespaces\": [\"*\"], // the watched namespaces\n    \"labels\": [\"label\"], // the watched namespaces\n    \"ingressClasses\": [\"otoroshi\"], // the watched kubernetes.io/ingress.class annotations, can be *\n    \"defaultGroup\": \"default\", // the group to put services in otoroshi\n    \"ingresses\": true, // sync ingresses\n    \"crds\": false, // sync crds\n    \"kubeLeader\": false, // delegate leader election to kubernetes, to know where the sync job should run\n    \"restartDependantDeployments\": true, // when a secret/cert changes from otoroshi sync, restart dependant deployments\n    \"templates\": { // template for entities that will be merged with kubernetes entities. can be \"default\" to use otoroshi default templates\n      \"service-group\": {},\n      \"service-descriptor\": {},\n      \"apikeys\": {},\n      \"global-config\": {},\n      \"jwt-verifier\": {},\n      \"tcp-service\": {},\n      \"certificate\": {},\n      \"auth-module\": {},\n      \"data-exporter\": {},\n      \"script\": {},\n      \"organization\": {},\n      \"team\": {},\n      \"data-exporter\": {}\n    }\n  }\n}\n```\n\nIf `endpoint` is not defined, Otoroshi will try to get it from `$KUBERNETES_SERVICE_HOST` and `$KUBERNETES_SERVICE_PORT`.\nIf `token` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/token`.\nIf `caCert` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`.\nIf `$KUBECONFIG` is defined, `endpoint`, `token` and `caCert` will be read from the current context of the file referenced by it.\n\nNow you can deploy your first service ;)\n\n### Deploy an ingress route\n\nnow let's say you want to deploy an http service and route to the outside world through otoroshi\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-app-deployment\nspec:\n  selector:\n    matchLabels:\n      run: http-app-deployment\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        run: http-app-deployment\n    spec:\n      containers:\n      - image: kennethreitz/httpbin\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        ports:\n          - containerPort: 80\n            name: \"http\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-app-service\nspec:\n  ports:\n    - port: 8080\n      targetPort: http\n      name: http\n  selector:\n    run: http-app-deployment\n---\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: otoroshi\nspec:\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\nonce deployed, otoroshi will sync with kubernetes and create the corresponding service to route your app. You will be able to access your app with\n\n```sh\ncurl -X GET https://httpapp.foo.bar/get\n```\n\n### Support for Ingress Classes\n\nSince Kubernetes 1.18, you can use `IngressClass` type of manifest to specify which ingress controller you want to use for a deployment (https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#extended-configuration-with-ingress-classes). Otoroshi is fully compatible with this new manifest `kind`. To use it, configure the Ingress job to match your controller\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"ingressClasses\": [\"otoroshi.io/ingress-controller\"],\n    ...\n  }\n}\n```\n\nthen you have to deploy an `IngressClass` to declare Otoroshi as an ingress controller\n\n```yaml\napiVersion: \"networking.k8s.io/v1beta1\"\nkind: \"IngressClass\"\nmetadata:\n  name: \"otoroshi-ingress-controller\"\nspec:\n  controller: \"otoroshi.io/ingress-controller\"\n  parameters:\n    apiGroup: \"proxy.otoroshi.io/v1alpha\"\n    kind: \"IngressParameters\"\n    name: \"otoroshi-ingress-controller\"\n```\n\nand use it in your `Ingress`\n\n```yaml\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\nspec:\n  ingressClassName: otoroshi-ingress-controller\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\n### Use multiple ingress controllers\n\nIt is of course possible to use multiple ingress controller at the same time (https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/#using-multiple-ingress-controllers) using the annotation `kubernetes.io/ingress.class`. By default, otoroshi reacts to the class `otoroshi`, but you can make it the default ingress controller with the following config\n\n```json\n{\n  \"KubernetesConfig\": {\n    ...\n    \"ingressClass\": \"*\",\n    ...\n  }\n}\n```\n\n### Supported annotations\n\nif you need to customize the service descriptor behind an ingress rule, you can use some annotations. If you need better customisation, just go to the CRDs part. The following annotations are supported :\n\n- `ingress.otoroshi.io/groups`\n- `ingress.otoroshi.io/group`\n- `ingress.otoroshi.io/groupId`\n- `ingress.otoroshi.io/name`\n- `ingress.otoroshi.io/targetsLoadBalancing`\n- `ingress.otoroshi.io/stripPath`\n- `ingress.otoroshi.io/enabled`\n- `ingress.otoroshi.io/userFacing`\n- `ingress.otoroshi.io/privateApp`\n- `ingress.otoroshi.io/forceHttps`\n- `ingress.otoroshi.io/maintenanceMode`\n- `ingress.otoroshi.io/buildMode`\n- `ingress.otoroshi.io/strictlyPrivate`\n- `ingress.otoroshi.io/sendOtoroshiHeadersBack`\n- `ingress.otoroshi.io/readOnly`\n- `ingress.otoroshi.io/xForwardedHeaders`\n- `ingress.otoroshi.io/overrideHost`\n- `ingress.otoroshi.io/allowHttp10`\n- `ingress.otoroshi.io/logAnalyticsOnServer`\n- `ingress.otoroshi.io/useAkkaHttpClient`\n- `ingress.otoroshi.io/useNewWSClient`\n- `ingress.otoroshi.io/tcpUdpTunneling`\n- `ingress.otoroshi.io/detectApiKeySooner`\n- `ingress.otoroshi.io/letsEncrypt`\n- `ingress.otoroshi.io/publicPatterns`\n- `ingress.otoroshi.io/privatePatterns`\n- `ingress.otoroshi.io/additionalHeaders`\n- `ingress.otoroshi.io/additionalHeadersOut`\n- `ingress.otoroshi.io/missingOnlyHeadersIn`\n- `ingress.otoroshi.io/missingOnlyHeadersOut`\n- `ingress.otoroshi.io/removeHeadersIn`\n- `ingress.otoroshi.io/removeHeadersOut`\n- `ingress.otoroshi.io/headersVerification`\n- `ingress.otoroshi.io/matchingHeaders`\n- `ingress.otoroshi.io/ipFiltering.whitelist`\n- `ingress.otoroshi.io/ipFiltering.blacklist`\n- `ingress.otoroshi.io/api.exposeApi`\n- `ingress.otoroshi.io/api.openApiDescriptorUrl`\n- `ingress.otoroshi.io/healthCheck.enabled`\n- `ingress.otoroshi.io/healthCheck.url`\n- `ingress.otoroshi.io/jwtVerifier.ids`\n- `ingress.otoroshi.io/jwtVerifier.enabled`\n- `ingress.otoroshi.io/jwtVerifier.excludedPatterns`\n- `ingress.otoroshi.io/authConfigRef`\n- `ingress.otoroshi.io/redirection.enabled`\n- `ingress.otoroshi.io/redirection.code`\n- `ingress.otoroshi.io/redirection.to`\n- `ingress.otoroshi.io/clientValidatorRef`\n- `ingress.otoroshi.io/transformerRefs`\n- `ingress.otoroshi.io/transformerConfig`\n- `ingress.otoroshi.io/accessValidator.enabled`\n- `ingress.otoroshi.io/accessValidator.excludedPatterns`\n- `ingress.otoroshi.io/accessValidator.refs`\n- `ingress.otoroshi.io/accessValidator.config`\n- `ingress.otoroshi.io/preRouting.enabled`\n- `ingress.otoroshi.io/preRouting.excludedPatterns`\n- `ingress.otoroshi.io/preRouting.refs`\n- `ingress.otoroshi.io/preRouting.config`\n- `ingress.otoroshi.io/issueCert`\n- `ingress.otoroshi.io/issueCertCA`\n- `ingress.otoroshi.io/gzip.enabled`\n- `ingress.otoroshi.io/gzip.excludedPatterns`\n- `ingress.otoroshi.io/gzip.whiteList`\n- `ingress.otoroshi.io/gzip.blackList`\n- `ingress.otoroshi.io/gzip.bufferSize`\n- `ingress.otoroshi.io/gzip.chunkedThreshold`\n- `ingress.otoroshi.io/gzip.compressionLevel`\n- `ingress.otoroshi.io/cors.enabled`\n- `ingress.otoroshi.io/cors.allowOrigin`\n- `ingress.otoroshi.io/cors.exposeHeaders`\n- `ingress.otoroshi.io/cors.allowHeaders`\n- `ingress.otoroshi.io/cors.allowMethods`\n- `ingress.otoroshi.io/cors.excludedPatterns`\n- `ingress.otoroshi.io/cors.maxAge`\n- `ingress.otoroshi.io/cors.allowCredentials`\n- `ingress.otoroshi.io/clientConfig.useCircuitBreaker`\n- `ingress.otoroshi.io/clientConfig.retries`\n- `ingress.otoroshi.io/clientConfig.maxErrors`\n- `ingress.otoroshi.io/clientConfig.retryInitialDelay`\n- `ingress.otoroshi.io/clientConfig.backoffFactor`\n- `ingress.otoroshi.io/clientConfig.connectionTimeout`\n- `ingress.otoroshi.io/clientConfig.idleTimeout`\n- `ingress.otoroshi.io/clientConfig.callAndStreamTimeout`\n- `ingress.otoroshi.io/clientConfig.callTimeout`\n- `ingress.otoroshi.io/clientConfig.globalTimeout`\n- `ingress.otoroshi.io/clientConfig.sampleInterval`\n- `ingress.otoroshi.io/enforceSecureCommunication`\n- `ingress.otoroshi.io/sendInfoToken`\n- `ingress.otoroshi.io/sendStateChallenge`\n- `ingress.otoroshi.io/secComHeaders.claimRequestName`\n- `ingress.otoroshi.io/secComHeaders.stateRequestName`\n- `ingress.otoroshi.io/secComHeaders.stateResponseName`\n- `ingress.otoroshi.io/secComTtl`\n- `ingress.otoroshi.io/secComVersion`\n- `ingress.otoroshi.io/secComInfoTokenVersion`\n- `ingress.otoroshi.io/secComExcludedPatterns`\n- `ingress.otoroshi.io/secComSettings.size`\n- `ingress.otoroshi.io/secComSettings.secret`\n- `ingress.otoroshi.io/secComSettings.base64`\n- `ingress.otoroshi.io/secComUseSameAlgo`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.size`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.secret`\n- `ingress.otoroshi.io/secComAlgoChallengeOtoToBack.base64`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.size`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.secret`\n- `ingress.otoroshi.io/secComAlgoChallengeBackToOto.base64`\n- `ingress.otoroshi.io/secComAlgoInfoToken.size`\n- `ingress.otoroshi.io/secComAlgoInfoToken.secret`\n- `ingress.otoroshi.io/secComAlgoInfoToken.base64`\n- `ingress.otoroshi.io/securityExcludedPatterns`\n\nfor more informations about it, just go to https://maif.github.io/otoroshi/swagger-ui/index.html\n\nwith the previous example, the ingress does not define any apikey, so the route is public. If you want to enable apikeys on it, you can deploy the following descriptor\n\n```yaml\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: http-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: otoroshi\n    ingress.otoroshi.io/group: http-app-group\n    ingress.otoroshi.io/forceHttps: 'true'\n    ingress.otoroshi.io/sendOtoroshiHeadersBack: 'true'\n    ingress.otoroshi.io/overrideHost: 'true'\n    ingress.otoroshi.io/allowHttp10: 'false'\n    ingress.otoroshi.io/publicPatterns: ''\nspec:\n  tls:\n  - hosts:\n    - httpapp.foo.bar\n    secretName: http-app-cert\n  rules:\n  - host: httpapp.foo.bar\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: http-app-service\n          servicePort: 8080\n```\n\nnow you can use an existing apikey in the `http-app-group` to access your app\n\n```sh\ncurl -X GET https://httpapp.foo.bar/get -u existing-apikey-1:secret-1\n```\n\n## Use Otoroshi CRDs for a better/full integration\n\nOtoroshi provides some Custom Resource Definitions for kubernetes in order to manage Otoroshi related entities in kubernetes\n\n- `service-groups`\n- `service-descriptors`\n- `apikeys`\n- `certificates`\n- `global-configs`\n- `jwt-verifiers`\n- `auth-modules`\n- `scripts`\n- `tcp-services`\n- `data-exporters`\n- `admins`\n- `teams`\n- `organizations`\n\nusing CRDs, you will be able to deploy and manager those entities from kubectl or the kubernetes api like\n\n```sh\nsudo kubectl get apikeys --all-namespaces\nsudo kubectl get service-descriptors --all-namespaces\ncurl -X GET \\\n  -H 'Authorization: Bearer eyJhbGciOiJSUzI....F463SrpOehQRaQ' \\\n  -H 'Accept: application/json' -k \\\n  https://127.0.0.1:6443/apis/proxy.otoroshi.io/v1alpha1/apikeys | jq\n```\n\nYou can see this as better `Ingress` resources. Like any `Ingress` resource can define which controller it uses (using the `kubernetes.io/ingress.class` annotation), you can chose another kind of resource instead of `Ingress`. With Otoroshi CRDs you can even define resources like `Certificate`, `Apikey`, `AuthModules`, `JwtVerifier`, etc. It will help you to use all the power of Otoroshi while using the deployment model of kubernetes.\n \n@@@ warning\nwhen using Otoroshi CRDs, Kubernetes becomes the single source of truth for the synced entities. It means that any value in the descriptors deployed will overrides the one in Otoroshi datastore each time it's synced. So be careful if you use the Otoroshi UI or the API, some changes in configuration may be overriden by CRDs sync job.\n@@@\n\n### Resources examples\n\ngroup.yaml\n:   @@snip [group.yaml](../snippets/crds/group.yaml) \n\napikey.yaml\n:   @@snip [apikey.yaml](../snippets/crds/apikey.yaml) \n\nservice-descriptor.yaml\n:   @@snip [service.yaml](../snippets/crds/service-descriptor.yaml) \n\ncertificate.yaml\n:   @@snip [cert.yaml](../snippets/crds/certificate.yaml) \n\njwt.yaml\n:   @@snip [jwt.yaml](../snippets/crds/jwt.yaml) \n\nauth.yaml\n:   @@snip [auth.yaml](../snippets/crds/auth.yaml) \n\norganization.yaml\n:   @@snip [orga.yaml](../snippets/crds/organization.yaml) \n\nteam.yaml\n:   @@snip [team.yaml](../snippets/crds/team.yaml) \n\n\n### Configuration\n\nTo configure it, just go to the danger zone, and in `Global scripts` add the job named `Kubernetes Otoroshi CRDs Controller`. Then add the following configuration for the job (with your own tweak of course)\n\n```json\n{\n  \"KubernetesConfig\": {\n    \"enabled\": true,\n    \"crds\": true,\n    \"endpoint\": \"https://127.0.0.1:6443\",\n    \"token\": \"eyJhbGciOiJSUzI....F463SrpOehQRaQ\",\n    \"namespaces\": [\n      \"*\"\n    ]\n  }\n}\n```\n\nthe configuration can have the following values \n\n```javascript\n{\n  \"KubernetesConfig\": {\n    \"endpoint\": \"https://127.0.0.1:6443\", // the endpoint to talk to the kubernetes api, optional\n    \"token\": \"xxxx\", // the bearer token to talk to the kubernetes api, optional\n    \"userPassword\": \"user:password\", // the user password tuple to talk to the kubernetes api, optional\n    \"caCert\": \"/etc/ca.cert\", // the ca cert file path to talk to the kubernetes api, optional\n    \"trust\": false, // trust any cert to talk to the kubernetes api, optional\n    \"namespaces\": [\"*\"], // the watched namespaces\n    \"labels\": [\"label\"], // the watched namespaces\n    \"ingressClasses\": [\"otoroshi\"], // the watched kubernetes.io/ingress.class annotations, can be *\n    \"defaultGroup\": \"default\", // the group to put services in otoroshi\n    \"ingresses\": false, // sync ingresses\n    \"crds\": true, // sync crds\n    \"kubeLeader\": false, // delegate leader election to kubernetes, to know where the sync job should run\n    \"restartDependantDeployments\": true, // when a secret/cert changes from otoroshi sync, restart dependant deployments\n    \"templates\": { // template for entities that will be merged with kubernetes entities. can be \"default\" to use otoroshi default templates\n      \"service-group\": {},\n      \"service-descriptor\": {},\n      \"apikeys\": {},\n      \"global-config\": {},\n      \"jwt-verifier\": {},\n      \"tcp-service\": {},\n      \"certificate\": {},\n      \"auth-module\": {},\n      \"data-exporter\": {},\n      \"script\": {},\n      \"organization\": {},\n      \"team\": {},\n      \"data-exporter\": {}\n    }\n  }\n}\n```\n\nIf `endpoint` is not defined, Otoroshi will try to get it from `$KUBERNETES_SERVICE_HOST` and `$KUBERNETES_SERVICE_PORT`.\nIf `token` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/token`.\nIf `caCert` is not defined, Otoroshi will try to get it from the file at `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`.\nIf `$KUBECONFIG` is defined, `endpoint`, `token` and `caCert` will be read from the current context of the file referenced by it.\n\nyou can find a more complete example of the configuration object [here](https://github.com/MAIF/otoroshi/blob/master/otoroshi/app/plugins/jobs/kubernetes/config.scala#L134-L163)\n\n### Note about `apikeys` and `certificates` resources\n\nApikeys and Certificates are a little bit different than the other resources. They have ability to be defined without their secret part, but with an export setting so otoroshi will generate the secret parts and export the apikey or the certificate to kubernetes secret. Then any app will be able to mount them as volumes (see the full example below)\n\nIn those resources you can define \n\n```yaml\nexportSecret: true \nsecretName: the-secret-name\n```\n\nand omit `clientSecret` for apikey or `publicKey`, `privateKey` for certificates. For certificate you will have to provide a `csr` for the certificate in order to generate it\n\n```yaml\ncsr:\n  issuer: CN=Otoroshi Root\n  hosts: \n  - httpapp.foo.bar\n  - httpapps.foo.bar\n  key:\n    algo: rsa\n    size: 2048\n  subject: UID=httpapp-front, O=OtoroshiApps\n  client: false\n  ca: false\n  duration: 31536000000\n  signatureAlg: SHA256WithRSAEncryption\n  digestAlg: SHA-256\n```\n\nwhen apikeys are exported as kubernetes secrets, they will have the type `otoroshi.io/apikey-secret` with values `clientId` and `clientSecret`\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: apikey-1\ntype: otoroshi.io/apikey-secret\ndata:\n  clientId: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  clientSecret: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n```\n\nwhen certificates are exported as kubernetes secrets, they will have the type `kubernetes.io/tls` with the standard values `tls.crt` (the full cert chain) and `tls.key` (the private key). For more convenience, they will also have a `cert.crt` value containing the actual certificate without the ca chain and `ca-chain.crt` containing the ca chain without the certificate.\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: certificate-1\ntype: kubernetes.io/tls\ndata:\n  tls.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  tls.key: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  cert.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA==\n  ca-chain.crt: TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdA== \n```\n\n## Full CRD example\n\nthen you can deploy the previous example with better configuration level, and using mtls, apikeys, etc\n\nLet say the app looks like :\n\n```js\nconst fs = require('fs'); \nconst https = require('https'); \n\n// here we read the apikey to access http-app-2 from files mounted from secrets\nconst clientId = fs.readFileSync('/var/run/secrets/kubernetes.io/apikeys/clientId').toString('utf8')\nconst clientSecret = fs.readFileSync('/var/run/secrets/kubernetes.io/apikeys/clientSecret').toString('utf8')\n\nconst backendKey = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/tls.key').toString('utf8')\nconst backendCert = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/cert.crt').toString('utf8')\nconst backendCa = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/backend/ca-chain.crt').toString('utf8')\n\nconst clientKey = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/tls.key').toString('utf8')\nconst clientCert = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/cert.crt').toString('utf8')\nconst clientCa = fs.readFileSync('/var/run/secrets/kubernetes.io/certs/client/ca-chain.crt').toString('utf8')\n\nfunction callApi2() {\n  return new Promise((success, failure) => {\n    const options = { \n      // using the implicit internal name (*.global.otoroshi.mesh) of the other service descriptor passing through otoroshi\n      hostname: 'http-app-service-descriptor-2.global.otoroshi.mesh',  \n      port: 433, \n      path: '/', \n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Otoroshi-Client-Id': clientId,\n        'Otoroshi-Client-Secret': clientSecret,\n      },\n      cert: clientCert,\n      key: clientKey,\n      ca: clientCa\n    }; \n    let data = '';\n    const req = https.request(options, (res) => { \n      res.on('data', (d) => { \n        data = data + d.toString('utf8');\n      }); \n      res.on('end', () => { \n        success({ body: JSON.parse(data), res });\n      }); \n      res.on('error', (e) => { \n        failure(e);\n      }); \n    }); \n    req.end();\n  })\n}\n\nconst options = { \n  key: backendKey, \n  cert: backendCert, \n  ca: backendCa, \n  // we want mtls behavior\n  requestCert: true, \n  rejectUnauthorized: true\n}; \nhttps.createServer(options, (req, res) => { \n  res.writeHead(200, {'Content-Type': 'application/json'});\n  callApi2().then(resp => {\n    res.write(JSON.stringify{ (\"message\": `Hello to ${req.socket.getPeerCertificate().subject.CN}`, api2: resp.body })); \n  });\n}).listen(433);\n```\n\nthen, the descriptors will be :\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-app-deployment\nspec:\n  selector:\n    matchLabels:\n      run: http-app-deployment\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        run: http-app-deployment\n    spec:\n      containers:\n      - image: foo/http-app\n        imagePullPolicy: IfNotPresent\n        name: otoroshi\n        ports:\n          - containerPort: 443\n            name: \"https\"\n        volumeMounts:\n        - name: apikey-volume\n          # here you will be able to read apikey from files \n          # - /var/run/secrets/kubernetes.io/apikeys/clientId\n          # - /var/run/secrets/kubernetes.io/apikeys/clientSecret\n          mountPath: \"/var/run/secrets/kubernetes.io/apikeys\"\n          readOnly: true\n        volumeMounts:\n        - name: backend-cert-volume\n          # here you will be able to read app cert from files \n          # - /var/run/secrets/kubernetes.io/certs/backend/tls.crt\n          # - /var/run/secrets/kubernetes.io/certs/backend/tls.key\n          mountPath: \"/var/run/secrets/kubernetes.io/certs/backend\"\n          readOnly: true\n        - name: client-cert-volume\n          # here you will be able to read app cert from files \n          # - /var/run/secrets/kubernetes.io/certs/client/tls.crt\n          # - /var/run/secrets/kubernetes.io/certs/client/tls.key\n          mountPath: \"/var/run/secrets/kubernetes.io/certs/client\"\n          readOnly: true\n      volumes:\n      - name: apikey-volume\n        secret:\n          # here we reference the secret name from apikey http-app-2-apikey-1\n          secretName: secret-2\n      - name: backend-cert-volume\n        secret:\n          # here we reference the secret name from cert http-app-certificate-backend\n          secretName: http-app-certificate-backend-secret\n      - name: client-cert-volume\n        secret:\n          # here we reference the secret name from cert http-app-certificate-client\n          secretName: http-app-certificate-client-secret\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-app-service\nspec:\n  ports:\n    - port: 8443\n      targetPort: https\n      name: https\n  selector:\n    run: http-app-deployment\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ServiceGroup\nmetadata:\n  name: http-app-group\n  annotations:\n    otoroshi.io/id: http-app-group\nspec:\n  description: a group to hold services about the http-app\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-apikey-1\n# this apikey can be used to access the app\nspec:\n  # a secret name secret-1 will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: secret-1\n  authorizedEntities: \n  - group_http-app-group\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-2-apikey-1\n# this apikey can be used to access another app in a different group\nspec:\n  # a secret name secret-1 will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: secret-2\n  authorizedEntities: \n  - group_http-app-2-group\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-frontend\nspec:\n  description: certificate for the http-app on otorshi frontend\n  autoRenew: true\n  csr:\n    issuer: CN=Otoroshi Root\n    hosts: \n    - httpapp.foo.bar\n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-front, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-backend\nspec:\n  description: certificate for the http-app deployed on pods\n  autoRenew: true\n  # a secret name http-app-certificate-backend-secret will be created by otoroshi and can be used by containers\n  exportSecret: true \n  secretName: http-app-certificate-backend-secret\n  csr:\n    issuer: CN=Otoroshi Root\n    hosts: \n    - http-app-service \n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-back, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: http-app-certificate-client\nspec:\n  description: certificate for the http-app\n  autoRenew: true\n  secretName: http-app-certificate-client-secret\n  csr:\n    issuer: CN=Otoroshi Root\n    key:\n      algo: rsa\n      size: 2048\n    subject: UID=httpapp-client, O=OtoroshiApps\n    client: false\n    ca: false\n    duration: 31536000000\n    signatureAlg: SHA256WithRSAEncryption\n    digestAlg: SHA-256\n---\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ServiceDescriptor\nmetadata:\n  name: http-app-service-descriptor\nspec:\n  description: the service descriptor for the http app\n  groups: \n  - http-app-group\n  forceHttps: true\n  hosts:\n  - httpapp.foo.bar # hostname exposed oustide of the kubernetes cluster\n  # - http-app-service-descriptor.global.otoroshi.mesh # implicit internal name inside the kubernetes cluster \n  matchingRoot: /\n  targets:\n  - url: https://http-app-service:8443\n    # alternatively, you can use serviceName and servicePort to use pods ip addresses\n    # serviceName: http-app-service\n    # servicePort: https\n    mtlsConfig:\n      # use mtls to contact the backend\n      mtls: true\n      certs: \n        # reference the DN for the client cert\n        - UID=httpapp-client, O=OtoroshiApps\n      trustedCerts: \n        # reference the DN for the CA cert \n        - CN=Otoroshi Root\n  sendOtoroshiHeadersBack: true\n  xForwardedHeaders: true\n  overrideHost: true\n  allowHttp10: false\n  publicPatterns:\n    - /health\n  additionalHeaders:\n    x-foo: bar\n# here you can specify everything supported by otoroshi like jwt-verifiers, auth config, etc ... for more informations about it, just go to https://maif.github.io/otoroshi/swagger-ui/index.html\n```\n\nnow with this descriptor deployed, you can access your app with a command like \n\n```sh\nCLIENT_ID=`kubectl get secret secret-1 -o jsonpath=\"{.data.clientId}\" | base64 --decode`\nCLIENT_SECRET=`kubectl get secret secret-1 -o jsonpath=\"{.data.clientSecret}\" | base64 --decode`\ncurl -X GET https://httpapp.foo.bar/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n## Expose Otoroshi to outside world\n\nIf you deploy Otoroshi on a kubernetes cluster, the Otoroshi service is deployed as a loadbalancer (service type: `LoadBalancer`). You'll need to declare in your DNS settings any name that can be routed by otoroshi going to the loadbalancer endpoint (CNAME or ip addresses) of your kubernetes distribution. If you use a managed kubernetes cluster from a cloud provider, it will work seamlessly as they will provide external loadbalancers out of the box. However, if you use a bare metal kubernetes cluster, id doesn't come with support for external loadbalancers (service of type `LoadBalancer`). So you will have to provide this feature in order to route external TCP traffic to Otoroshi containers running inside the kubernetes cluster. You can use projects like [MetalLB](https://metallb.universe.tf/) that provide software `LoadBalancer` services to bare metal clusters or you can use and customize examples in the installation section.\n\n@@@ warning\nWe don't recommand running Otoroshi behind an existing ingress controller (or something like that) as you will not be able to use features like TCP proxying, TLS, mTLS, etc. Also, this additional layer of reverse proxy will increase call latencies.\n@@@ \n\n## Access a service from inside the k8s cluster\n\n### Using host header overriding\n\nYou can access any service referenced in otoroshi, through otoroshi from inside the kubernetes cluster by using the otoroshi service name (if you use a template based on https://github.com/MAIF/otoroshi/tree/master/kubernetes/base deployed in the otoroshi namespace) and the host header with the service domain like :\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET -H 'Host: httpapp.foo.bar' https://otoroshi-service.otoroshi.svc.cluster.local:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using dedicated services\n\nit's also possible to define services that targets otoroshi deployment (or otoroshi workers deployment) and use then as valid hosts in otoroshi services \n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-awesome-service\nspec:\n  selector:\n    # run: otoroshi-deployment\n    # or in cluster mode\n    run: otoroshi-worker-deployment\n  ports:\n  - port: 8080\n    name: \"http\"\n    targetPort: \"http\"\n  - port: 8443\n    name: \"https\"\n    targetPort: \"https\"\n```\n\nand access it like\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET https://my-awesome-service.my-namspace.svc.cluster.local:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using coredns integration\n\nYou can also enable the coredns integration to simplify the flow. You can use the the following keys in the plugin config :\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"coreDnsIntegration\": true,                // enable coredns integration for intra cluster calls\n    \"kubeSystemNamespace\": \"kube-system\",      // the namespace where coredns is deployed\n    \"corednsConfigMap\": \"coredns\",             // the name of the coredns configmap\n    \"otoroshiServiceName\": \"otoroshi-service\", // the name of the otoroshi service, could be otoroshi-workers-service\n    \"otoroshiNamespace\": \"otoroshi\",           // the namespace where otoroshi is deployed\n    \"clusterDomain\": \"cluster.local\",          // the domain for cluster services\n    ...\n  }\n}\n```\n\notoroshi will patch coredns config at startup then you can call your services like\n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\ncurl -X GET https://my-awesome-service.my-awesome-service-namespace.otoroshi.mesh:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\nBy default, all services created from CRDs service descriptors are exposed as `${service-name}.${service-namespace}.otoroshi.mesh` or `${service-name}.${service-namespace}.svc.otoroshi.local`\n\n### Using coredns with manual patching\n\nyou can also patch the coredns config manually\n\n```sh\nkubectl edit configmaps coredns -n kube-system # or your own custom config map\n```\n\nand change the `Corefile` data to add the following snippet in at the end of the file\n\n```yaml\notoroshi.mesh:53 {\n    errors\n    health\n    ready\n    kubernetes cluster.local in-addr.arpa ip6.arpa {\n        pods insecure\n        upstream\n        fallthrough in-addr.arpa ip6.arpa\n    }\n    rewrite name regex (.*)\\.otoroshi\\.mesh otoroshi-worker-service.otoroshi.svc.cluster.local\n    forward . /etc/resolv.conf\n    cache 30\n    loop\n    reload\n    loadbalance\n}\n```\n\nyou can also define simpler rewrite if it suits you use case better\n\n```\nrewrite name my-service.otoroshi.mesh otoroshi-worker-service.otoroshi.svc.cluster.local\n```\n\ndo not hesitate to change `otoroshi-worker-service.otoroshi` according to your own setup. If otoroshi is not in cluster mode, change it to `otoroshi-service.otoroshi`. If otoroshi is not deployed in the `otoroshi` namespace, change it to `otoroshi-service.the-namespace`, etc.\n\nBy default, all services created from CRDs service descriptors are exposed as `${service-name}.${service-namespace}.otoroshi.mesh`\n\nthen you can call your service like \n\n```sh\nCLIENT_ID=\"xxx\"\nCLIENT_SECRET=\"xxx\"\n\ncurl -X GET https://my-awesome-service.my-awesome-service-namespace.otoroshi.mesh:8443/get -u \"$CLIENT_ID:$CLIENT_SECRET\"\n```\n\n### Using old kube-dns system\n\nif your stuck with an old version of kubernetes, it uses kube-dns that is not supported by otoroshi, so you will have to provide your own coredns deployment and declare it as a stubDomain in the old kube-dns system. \n\nHere is an example of coredns deployment with otoroshi domain config\n\ncoredns.yaml\n:   @@snip [coredns.yaml](../snippets/kubernetes/kustomize/base/coredns.yaml)\n\nthen you can enable the kube-dns integration in the otoroshi kubernetes job\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"kubeDnsOperatorIntegration\": true,                // enable kube-dns integration for intra cluster calls\n    \"kubeDnsOperatorCoreDnsNamespace\": \"otoroshi\",    // namespace where coredns is installed\n    \"kubeDnsOperatorCoreDnsName\": \"otoroshi-dns\",     // name of the coredns service\n    \"kubeDnsOperatorCoreDnsPort\": 5353,               // port of the coredns service\n    ...\n  }\n}\n```\n\n### Using Openshift DNS operator\n\nOpenshift DNS operator does not allow to customize DNS configuration a lot, so you will have to provide your own coredns deployment and declare it as a stub in the Openshift DNS operator. \n\nHere is an example of coredns deployment with otoroshi domain config\n\ncoredns.yaml\n:   @@snip [coredns.yaml](../snippets/kubernetes/kustomize/base/coredns.yaml)\n\nthen you can enable the Openshift DNS operator integration in the otoroshi kubernetes job\n\n```javascript\n{\n  \"KubernetesConfig\": {\n    ...\n    \"openshiftDnsOperatorIntegration\": true,                // enable openshift dns operator integration for intra cluster calls\n    \"openshiftDnsOperatorCoreDnsNamespace\": \"otoroshi\",    // namespace where coredns is installed\n    \"openshiftDnsOperatorCoreDnsName\": \"otoroshi-dns\",     // name of the coredns service\n    \"openshiftDnsOperatorCoreDnsPort\": 5353,               // port of the coredns service\n    ...\n  }\n}\n```\n\ndon't forget to update the otoroshi `ClusterRole`\n\n```yaml\n- apiGroups:\n    - operator.openshift.io\n  resources:\n    - dnses\n  verbs:\n    - get\n    - list\n    - watch\n    - update\n```\n\n## CRD validation in kubectl\n\nIn order to get CRD validation before manifest deployments right inside kubectl, you can deploy a validation webhook that will do the trick. Also check that you have `otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookCRDValidator` request sink enabled.\n\nvalidation-webhook.yaml\n:   @@snip [validation-webhook.yaml](../snippets/kubernetes/kustomize/base/validation-webhook.yaml)\n\n## Easier integration with otoroshi-sidecar\n\nOtoroshi can help you to easily use existing services without modifications while gettings all the perks of otoroshi like apikeys, mTLS, exchange protocol, etc. To do so, otoroshi will inject a sidecar container in the pod of your deployment that will handle call coming from otoroshi and going to otoroshi. To enable otoroshi-sidecar, you need to deploy the following admission webhook. Also check that you have `otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookSidecarInjector` request sink enabled.\n\nsidecar-webhook.yaml\n:   @@snip [sidecar-webhook.yaml](../snippets/kubernetes/kustomize/base/sidecar-webhook.yaml)\n\nthen it's quite easy to add the sidecar, just add the following label to your pod `otoroshi.io/sidecar: inject` and some annotations to tell otoroshi what certificates and apikeys to use.\n\n```yaml\nannotations:\n  otoroshi.io/sidecar-apikey: backend-apikey\n  otoroshi.io/sidecar-backend-cert: backend-cert\n  otoroshi.io/sidecar-client-cert: oto-client-cert\n  otoroshi.io/token-secret: secret\n  otoroshi.io/expected-dn: UID=oto-client-cert, O=OtoroshiApps\n```\n\nnow you can just call you otoroshi handled apis from inside your pod like `curl http://my-service.namespace.otoroshi.mesh/api` without passing any apikey or client certificate and the sidecar will handle everything for you. Same thing for call from otoroshi to your pod, everything will be done in mTLS fashion with apikeys and otoroshi exchange protocol\n\nhere is a full example\n\nsidecar.yaml\n:   @@snip [sidecar.yaml](../snippets/kubernetes/kustomize/base/sidecar.yaml)\n\n@@@ warning\nPlease avoid to use port `80` for your pod as it's the default port to access otoroshi from your pod and the call will be redirect to the sidecar via an iptables rule\n@@@\n\n## Daikoku integration\n\nIt is possible to easily integrate daikoku generated apikeys without any human interaction with the actual apikey secret. To do that, create a plan in Daikoku and setup the integration mode to `Automatic`\n\n@@@ div { .centered-img }\n<img src=\"../imgs/kubernetes-daikoku-integration-enabled.png\" />\n@@@\n\nthen when a user subscribe for an apikey, he will only see an integration token\n\n@@@ div { .centered-img }\n<img src=\"../imgs/kubernetes-daikoku-integration-token.png\" />\n@@@\n\nthen just create an ApiKey manifest with this token and your good to go \n\n```yaml\napiVersion: proxy.otoroshi.io/v1alpha1\nkind: ApiKey\nmetadata:\n  name: http-app-2-apikey-3\nspec:\n  exportSecret: true \n  secretName: secret-3\n  daikokuToken: RShQrvINByiuieiaCBwIZfGFgdPu7tIJEN5gdV8N8YeH4RI9ErPYJzkuFyAkZ2xy\n```\n\n"},{"name":"other.md","id":"/deploy/other.md","url":"/deploy/other.html","title":"Others","content":"# Others\n\nOtoroshi can run wherever you want, even on a raspberry pi (Cluster^^) ;)\n\nThis section is not finished yet. So, as Otoroshi is available as a @ref:[Docker image](../install/get-otoroshi.md#from-docker) that you can run on any Docker compatible cloud, just go ahead and use it on cloud provider until we have more detailed documentation.\n\n## Running Otoroshi on AWS Elastic Beanstalk\n\nSee the @ref:[dedicated page to run Otoroshi on AWS Elastic Beanstalk](./aws.md)\n\n## Running Otoroshi on Amazon Elastic Container Service\n\nDeploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) using [Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html)\n\n## Running Otoroshi on GCE\n\nDeploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) using [Google Compute Engine container integration](https://cloud.google.com/compute/docs/containers/deploying-containers)\n\n## Running Otoroshi on Azure\n\nDeploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) using [Azure Container Service](https://azure.microsoft.com/en-us/services/container-service/)\n\n## Running Otoroshi on Heroku\n\nDeploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) using [Docker integration](https://devcenter.heroku.com/articles/container-registry-and-runtime)\n\n## Running Otoroshi on CloudFoundry\n\nDeploy the @ref:[Docker image](../install/get-otoroshi.md#from-docker) using [Docker integration](https://docs.cloudfoundry.org/adminguide/docker.html)\n\n## Running Otoroshi on your own infrastructure\n\nAs Otoroshi is a [Play Framework](https://www.playframework.com) application, you can read the doc about putting a `Play` app in production.\n\nhttps://www.playframework.com/documentation/2.6.x/ProductionConfiguration\n\nDownload the latest @ref:[Otoroshi distribution](../install/get-otoroshi.md#from-zip), unzip it, customize it and run it.\n"},{"name":"scaling.md","id":"/deploy/scaling.md","url":"/deploy/scaling.html","title":"Scaling Otoroshi","content":"# Scaling Otoroshi\n\n## Using multiple instances with a front load balancer\n\nOtoroshi has been designed to work with multiple instances. If you already have an infrastructure using frontal load balancing, you just have to declare Otoroshi instances as the target of all domain names handled by Otoroshi\n\n## Using master / workers mode of Otoroshi\n\nYou can read everything about it in @ref:[the clustering section](../deploy/clustering.md) of the documentation.\n\n## Using IPVS\n\nYou can use [IPVS](https://en.wikipedia.org/wiki/IP_Virtual_Server) to load balance layer 4 traffic directly from the Linux Kernel to multiple instances of Otoroshi. You can find example of configuration [here](http://www.linuxvirtualserver.org/VS-DRouting.html) \n\n## Using DNS Round Robin\n\nYou can use [DNS round robin technique](https://en.wikipedia.org/wiki/Round-robin_DNS) to declare multiple A records under the domain names handled by Otoroshi.\n\n## Using software L4/L7 load balancers\n\nYou can use software L4 load balancers like NGINX or HAProxy to load balance layer 4 traffic directly from the Linux Kernel to multiple instances of Otoroshi.\n\nNGINX L7\n:   @@snip [nginx-http.conf](../snippets/nginx-http.conf) \n\nNGINX L4\n:   @@snip [nginx-tcp.conf](../snippets/nginx-tcp.conf) \n\nHA Proxy L7\n:   @@snip [haproxy-http.conf](../snippets/haproxy-http.conf) \n\nHA Proxy L4\n:   @@snip [haproxy-tcp.conf](../snippets/haproxy-tcp.conf) \n\n## Using a custom TCP load balancer\n\nYou can also use any other TCP load balancer, from a hardware box to a small js file like\n\ntcp-proxy.js\n:   @@snip [tcp-proxy.js](../snippets/tcp-proxy.js) \n\ntcp-proxy.rs\n:   @@snip [tcp-proxy.rs](../snippets/proxy.rs) \n\n"},{"name":"dev.md","id":"/dev.md","url":"/dev.html","title":"Developing Otoroshi","content":"# Developing Otoroshi\n\nIf you want to play with Otoroshis code, here are some tips\n\n## The tools\n\nYou will need\n\n* git\n* JDK 11\n* SBT 1.3.x\n* Node 13 + yarn 1.x\n\n## Clone the repository\n\n```sh\ngit clone https://github.com/MAIF/otoroshi.git\n```\n\nor fork otoroshi and clone your own repository.\n\n## Run otoroshi in dev mode\n\nto run otoroshi in dev mode, you'll need to run two separate process to serve the javascript UI and the server part.\n\n### Javascript side\n\njust go to `<repo>/otoroshi/javascript` and install the dependencies with\n\n```sh\nyarn install\n# or\nnpm install\n```\n\nthen run the dev server with\n\n```sh\nyarn start\n# or\nnpm run start\n```\n\n### Server side\n\nsetup SBT opts with\n\n```sh\nexport SBT_OPTS=\"-Xmx2G -Xss6M\"\n```\n\nthen just go to `<repo>/otoroshi` and run the sbt console with \n\n```sh\nsbt\n```\n\nthen in the sbt console run the following command\n\n```sh\n~run -Dapp.storage=file -Dapp.liveJs=true -Dhttps.port=9998 -D-Dapp.privateapps.port=9999 -Dapp.adminPassword=password -Dapp.domain=oto.tools -Dplay.server.https.engineProvider=ssl.DynamicSSLEngineProvider -Dapp.events.maxSize=0\n```\n\nyou can now access your otoroshi instance at `http://otoroshi.oto.tools:9999`\n\n## Test otoroshi\n\nto run otoroshi test just go to `<repo>/otoroshi` and run the main test suite with\n\n```sh\nsbt 'testOnly OtoroshiTests'\n```\n\n## Create a release\n\njust go to `<repo>/otoroshi/javascript` and then build the UI\n\n```sh\nyarn install\nyarn build\n```\n\nthen go to `<repo>/otoroshi` and build the otoroshi distribution\n\n```sh\nsbt ';clean;compile;dist;assembly'\n```\n\nthe otoroshi build is waiting for you in `<repo>/otoroshi/target/scala-2.12/otoroshi.jar` or `<repo>/otoroshi/target/universal/otoroshi-1.x.x.zip`\n\n## Build the documentation\n\nfrom the root of your repository run\n\n```sh\nsh ./scripts/doc.sh all\n```\n\n## Format the sources\n\nfrom the root of your repository run\n\n```sh\nsh ./scripts/fmt.sh\n```"},{"name":"apikeys.md","id":"/entities/apikeys.md","url":"/entities/apikeys.html","title":"Apikeys","content":"# Apikeys\n\nAn API key is linked to one or more service group and service descriptor to allow you to access any service descriptor linked or contained in one of the linked service group. You can, of course, create multiple API key for given service groups/service descriptors.\n\nYou can found a concrete example @ref:[here](../how-to-s/secure-with-apikey.md)\n\n* `ApiKey Id`: the id is a unique random key that will represent this API key\n* `ApiKey Secret`: the secret is a random key used to validate the API key\n* `ApiKey Name`: a name for the API key, used for debug purposes\n* `ApiKey description`: a useful description for this apikey\n* `Valid until`: auto disable apikey after this date\n* `Enabled`: if the API key is disabled, then any call using this API key will fail\n* `Read only`: if the API key is in read only mode, every request done with this api key will only work for GET, HEAD, OPTIONS verbs\n* `Allow pass by clientid only`: here you allow client to only pass client id in a specific header in order to grant access to the underlying api\n* `Constrained services only`: this apikey can only be used on services using apikey routing constraints\n* `Authorized on`: the groups/services linked to this api key\n\n### Metadata and tags\n* `Tags`: tags attached to the api key\n* `Metadata`:metadata attached to the api key\n\n### Automatic secret rotation\n \n* `Enabled`: enabled automatic apikey secret rotation\n* `Rotation every`: rotate secrets every\n* `Grace period`: period when both secrets can be used\n* `Next client secret`: display the next generated client secret\n\n### Restrictions\n\n* `Enabled`: enable restrictions\n* `Allow last`: Otoroshi will test forbidden and notFound paths before testing allowed paths\n* `Allowed`: allowed paths\n* `Forbidden`: forbidden paths\n* `Not Found`: not found paths\n\n### Call examples\n\n* `Curl Command`: simple request with the api key passed by header\n* `Basic Auth. Header`: authorization Header with the api key as base64 encoded format\n* `Curl Command with Basic Auth. Header`: simple request with api key passed in the Authorization header as base64 format\n\n### Quotas\n\n* `Throttling quota`: the authorized number of calls per second\n* `Daily quota`: the authorized number of calls per day\n* `Monthly quota`: the authorized number of calls per month\n\n@@@ warning\n\nDaily and monthly quotas are based on the following rules :\n\n* daily quota is computed between 00h00:00.000 and 23h59:59.999\n* monthly qutoas is computed between the first day of the month at 00h00:00.000 and the last day of the month at 23h59:59.999\n@@@\n\n### Quotas consumption\n\n* `Consumed daily calls`: the number of calls consumed today\n* `Remaining daily calls`: the remaining number of calls for today\n* `Consumed monthly calls`: the number of calls consumed this month\n* `Remaining monthly calls`: the remaining number of calls for this month\n\n"},{"name":"auth-modules.md","id":"/entities/auth-modules.md","url":"/entities/auth-modules.html","title":"Authentication modules","content":"# Authentication modules\n\nThe authentication modules are the resources to manage the the access to Otoroshi UI and to protect a service.\n\nAn authentication module can be as well use on guard to access to the Otoroshi UI as to protect an app.\n\nA `private app` is an Otoroshi service with an authentication module.\n\nThe list of supported authentication are : \n* `OAuth 2.0/2.1` : an authorization standard that allows a user to grant limited access to their resources on one site to another site, without having to expose their credentials\n* `OAuth 1.0a` : the original standard for access delegation\n* `In memory` : create users directly in Otoroshi with rights and metadata\n* `LDAP : Lightweight Directory Access Protocol` : connect users using a set of LDAP servers\n* `SAML V2 - Security Assertion Markup Language` : an open-standard, XML-based data format that allows businesses to communicate user authentication and authorization information to partner companies and enterprise applications their employees may use.\n\nAll authentication modules have a unique `id`, a `name` and a `description`.\n\nEach module has also the following fields : \n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n* `HttpOnly`: if enabled, the cookie cannot be accessed through client side script, prevent cross-site scripting (XSS) by not revealing the cookie to a third party\n* `Secure`: if enabled, avoid to include cookie in an HTTP Request without secure channel, typically HTTPs.\n* `Session max. age`: duration until the session expired\n\n## OAuth 2.0 / OIDC provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check these tutorials : @ref[Secure an app with keycloak](../how-to-s/secure-app-with-keycloak.md) or @ref[Secure an app with auth0](../how-to-s/secure-app-with-auth0.md)\n\n* `Use cookie`: If your OAuth2 provider does not support query param in redirect uri, you can use cookies instead\n* `Use json payloads`: the access token, sended to retrieve the user info, will be pass in body as JSON. If disabled, it will sended as Map.\n* `Enabled PKCE flow`: This way, a malicious attacker can only intercept the Authorization Code, and they cannot exchange it for a token without the Code Verifier.\n* `Disable wildcard on redirect URIs`: As of OAuth 2.1, query parameters on redirect URIs are no longer allowed\n* `Refresh tokens`: Automatically refresh access token using the refresh token if available\n* `Read profile from token`: if enabled, the user profile will be read from the access token, otherwise the user profile will be retrieved from the user information url\n* `Super admins only`: All logged in users will have super admins rights\n* `Client ID`: a public identifier of your app\n* `Client Secret`: a secret known only to the application and the authorization server\n* `Authorize URL`: used to interact with the resource owner and get the authorization to access the protected resource\n* `Token URL`: used by the application in order to get an access token or a refresh token\n* `Introspection URL`: used to validate access tokens\n* `Userinfo URL`: used to retrieve the profile of the user\n* `Login URL`:  used to redirect user to the login provider page\n* `Logout URL`:  redirect uri used by the identity provider to redirect user after logging out\n* `Callback URL`: redirect uri sended to the identity provider to redirect user after successfully connecting\n* `Access token field name`: field used to search access token in the response body of the token URL call\n* `Scope`: presented scopes to the user in the consent screen. Scopes are space-separated lists of identifiers used to specify what access privileges are being requested\n* `Claims`: asked name/values pairs that contains information about a user.\n* `Name field name`: Retrieve name from token field\n* `Email field name`: Retrieve email from token field\n* `Otoroshi metadata field name`: Retrieve metadata from token field\n* `Otoroshi rights field name`: Retrieve user rights from user profile\n* `Extra metadata`: merged with the user metadata\n* `Data override`: merged with extra metadata when a user connects to a `private app`\n* `Rights override`: useful when you want erase the rights of an user with only specific rights. This field is the last to be applied on the user rights.\n* `Api key metadata field name`: used to extract api key metadata from the OIDC access token \n* `Api key tags field name`: used to extract api key tags from the OIDC access token \n* `Proxy host`: host of proxy behind the identify provider\n* `Proxy port`: port of proxy behind the identify provider\n* `Proxy principal`: user of proxy \n* `Proxy password`: password of proxy\n* `OIDC config url`:  URI of the openid-configuration used to discovery documents. By convention, this URI ends with `.well-known/openid-configuration`\n* `Token verification`: What kind of algorithm you want to use to verify/sign your JWT token with\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Hmac secret`: The Hmac secret\n* `Base64 encoded secret`: Is the secret encoded with base64\n* `Custom TLS Settings`: TLS settings for JWKS fetching\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `Trust all`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with JWKS server\n* `Trusted certificates`: list of trusted certificates received from JWKS server\n\n## OAuth 1.0a provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check this tutorial : @ref[Secure an app with OAuth 1.0a](../how-to-s/secure-with-oauth1-client.md)\n\n* `Http Method`: method used to get request token and the access token \n* `Consumer key`: the identifier portion of the client credentials (equivalent to a username)\n* `Consumer secret`: the identifier portion of the client credentials (equivalent to a password)\n* `Request Token URL`: url to retrieve the request token\n* `Authorize URL`: used to redirect user to the login page\n* `Access token URL`: used to retrieve the access token from the server\n* `Profile URL`: used to get the user profile\n* `Callback URL`: used to redirect user when successfully connecting\n* `Rights override`: override the rights of the connected user. With JSON format, each authenticated user, using email, can be associated to a list of rights on tenants and Otoroshi teams.\n\n## LDAP Authentication provider\n\nIf you want to secure an app or your Otoroshi UI with this provider, you can check this tutorial : @ref[Secure an app with LDAP](../how-to-s/secure-app-with-ldap.md)\n\n* `Basic auth.`: if enabled, user and password will be extract from the `Authorization` header as a Basic authentication. It will skipped the login Otoroshi page \n* `Allow empty password`: LDAP servers configured by default with the possibility to connect without password can be secured by this module to ensure that user provides a password\n* `Super admins only`: All logged in users will have super admins rights\n* `Extract profile`: extract LDAP profile in the Otoroshi user\n* `LDAP Server URL`: list of LDAP servers to join. Otoroshi use this list in sequence and swap to the next server, each time a server breaks in timeout\n* `Search Base`: used to global filter\n* `Users search base`: concat with search base to search users in LDAP\n* `Mapping group filter`: map LDAP groups with Otoroshi rights\n* `Search Filter`: used to filter users. *\\${username}* is replace by the email of the user and compare to the given field\n* `Admin username (bind DN)`: holds the name of the environment property for specifying the identity of the principal for authenticating the caller to the service\n* `Admin password`: holds the name of the environment property for specifying the credentials of the principal for authenticating the caller to the service\n* `Extract profile filters attributes in`: keep only attributes which are matching the regex\n* `Extract profile filters attributes not in`: keep only attributes which are not matching the regex\n* `Name field name`: Retrieve name from LDAP field\n* `Email field name`: Retrieve email from LDAP field\n* `Otoroshi metadata field name`: Retrieve metadata from LDAP field\n* `Extra metadata`: merged with the user metadata\n* `Data override`: merged with extra metadata when a user connects to a `private app`\n* `Additional rights group`: list of virtual groups. A virtual group is composed of a list of users and a list of rights for each teams/organizations.\n* `Rights override`: useful when you want erase the rights of an user with only specific rights. This field is the last to be applied on the user rights.\n\n## In memory provider\n\n* `Basic auth.`: if enabled, user and password will be extract from the `Authorization` header as a Basic authentication. It will skipped the login Otoroshi page \n* `Login with WebAuthn` : enabled logging by WebAuthn\n* `Users`: list of users with *name*, *email* and *metadata*. The default password is *password*. The edit button is useful when you want to change the password of the user. The reset button reinitialize the password. \n* `Users raw`: show the registered users with their profile and their rights. You can edit directly each field, especially the rights of the user.\n\n## SAML v2 provider\n\n* `Single sign on URL`: the Identity Provider Single Sign-On URL\n* `The protocol binding for the login request`: the protocol binding for the login request\n* `Single Logout URL`: a SAML flow that allows the end-user to logout from a single session and be automatically logged out of all related sessions that were established during SSO\n* `The protocol binding for the logout request`: the protocol binding for the logout request\n* `Sign documents`: Should SAML Request be signed by Otoroshi ?\n* `Validate Assertions Signature`: Enable/disable signature validation of SAML assertions\n* `Validate assertions with Otoroshi certificate`: validate assertions with Otoroshi certificate. If disabled, the `Encryption Certificate` and `Encryption Private Key` fields can be used to pass a certificate and a private key to validate assertions.\n* `Encryption Certificate`: certificate used to verify assertions\n* `Encryption Private Key`: privaye key used to verify assertions\n* `Signing Certificate`: certicate used to sign documents\n* `Signing Private Key`: private key to sign documents\n* `Signature al`: the signature algorithm to use to sign documents\n* `Canonicalization Method`: canonicalization method for XML signatures \n* `Encryption KeyPair`: the keypair used to sign/verify assertions\n* `Name ID Format`: SP and IdP usually communicate each other about a subject. That subject should be identified through a NAME-IDentifier, which should be in some format so that It is easy for the other party to identify it based on the Format\n* `Use NameID format as email`: use NameID format as email. If disabled, the email will be search from the attributes\n* `URL issuer`: provide the URL to the IdP's who will issue the security token\n* `Validate Signature`: enable/disable signature validation of SAML responses\n* `Validate Assertions Signature`: should SAML Assertions to be decrypted ?\n* `Validating Certificates`: the certificate in PEM format that must be used to check for signatures.\n\n## Related pages\n* @ref[Secure an app with auth0](../how-to-s/secure-app-with-auth0.md)\n* @ref[Secure an app with keycloak](../how-to-s/secure-app-with-keycloak.md)\n* @ref[Secure an app with LDAP](../how-to-s/secure-app-with-ldap.md)\n* @ref[Secure an app with OAuth 1.0a](../how-to-s/secure-with-oauth1-client.md)"},{"name":"certificates.md","id":"/entities/certificates.md","url":"/entities/certificates.html","title":"Certificates","content":"# Certificates\n\n@@@ warning\nTODO\n@@@"},{"name":"data-exporters.md","id":"/entities/data-exporters.md","url":"/entities/data-exporters.html","title":"Data exporters","content":"# Data exporters\n\nThe data exporters are the way to export alerts and events from Otoroshi to an external storage.\n\nTo try them, you can folllow @ref[this tutorial](../how-to-s/export-alerts-using-mailgun.md).\n\n## Common fields\n\n* `Type`: the type of event exporter\n* `Enabled`: enabled or not the exporter\n* `Name`: given name to the exporter\n* `Description`: the data exporter description\n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n\nAll exporters are split in three parts. The first and second parts are common and the last are specific by exporter.\n\n* `Filtering and projection` : section to filter the list of sent events and alerts. The projection field allows you to export only certain event fields and reduce the size of exported data. It's composed of `Filtering` and `Projection` fields.\n* `Queue details`: set of fields to adjust the workers of the exporter. \n  * `Buffer size`: if elements are pushed onto the queue faster than the source is consumed the overflow will be handled with a strategy specified by the user. Keep in memory the number of events.\n  * `JSON conversion workers`: number of workers used to transform events to JSON format in paralell\n  * `Send workers`: number of workers used to send transformed events\n  * `Group size`: chunk up this stream into groups of elements received within a time window (the time window is the next field)\n  * `Group duration`: waiting time before sending the group of events. If the group size is reached before the group duration, the events will be instantly sent\n  \nFor the last part, the `Exporter configuration` will be detail individually.\n\n## Elastic\n\n* `Cluster URI`: Elastic cluster URI\n* `Index`: Elastic index \n* `Type`: Event type (not needed for elasticsearch above 6.x)\n* `User`: Elastic User (optional)\n* `Password`: Elastic password (optional)\n* `Version`: Elastic version (optional, if none provided it will be fetched from cluster)\n* `Apply template`: Automatically apply index template\n* `Check Connection`: Button to test the configuration. It will displayed a modal with checked point, and if the case of it's successfull, it will displayed the found version of the Elasticsearch and the index used\n* `Manually apply index template`: try to put the elasticsearch template by calling the api of elasticsearch\n* `Show index template`: try to retrieve the current index template presents in elasticsearch\n* `Client side temporal indexes handling`: When enabled, Otoroshi will manage the creation of indexes. When it's disabled, Otoroshi will push in the same index\n* `One index per`: When the previous field is enabled, you can choose the interval of time between the creation of a new index in elasticsearch \n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n\n## Webhook \n\n* `Alerts hook URL`: url used to post events\n* `Hook Headers`: headers add to the post request\n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n\n\n## Pulsar \n\n* `Pulsar URI`: URI of the pulsar server\n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n* `Pulsar tenant`: tenant on the pulsar server\n* `Pulsar namespace`:  namespace on the pulsar server\n* `Pulsar topic`: topic on the pulsar server\n\n## Kafka \n\n* `Kafka Servers`: the list of servers to contact to connect the Kafka client with the Kafka cluster\n* `Kafka keypass`: the keystore password if you use a keystore/truststore to connect to Kafka cluster\n* `Kafka keystore path`: the keystore path on the server if you use a keystore/truststore to connect to Kafka cluster\n* `Kafka truststore path`: the truststore path on the server if you use a keystore/truststore to connect to Kafka cluster\n* `Custom TLS Settings`: enable the TLS configuration for the communication with Elasticsearch\n  * `TLS loose`: if enabled, will block all untrustful ssl configs\n  * `TrustAll`: allows any server certificates even the self-signed ones\n  * `Client certificates`: list of client certificates used to communicate with elasticsearch\n  * `Trusted certificates`: list of trusted certificates received from elasticsearch\n* `Kafka topic`: the topic on which Otoroshi alerts will be sent\n\n## Mailer \n\nOtoroshi supports 5 exporters of email type.\n\n### Console\n\nNothing to add. The events will be write on the standard output.\n\n### Generic\n\n* `Mailer url`: URL used to push events\n* `Headers`: headers add to the push requests\n* `Email addresses`: recipients of the emails\n\n### Mailgun\n\n* `EU`: is EU server ? if enabled, *https://api.eu.mailgun.net/* will be used, otherwise, the US URL will be used : *https://api.mailgun.net/*\n* `Mailgun api key`: API key of the mailgun account\n* `Mailgun domain`: domain name of the mailgun account\n* `Email addresses`: recipients of the emails\n\n### Mailjet\n\n* `Public api key`: public key of the mailjet account\n* `Private api key`: private key of the mailjet account\n* `Email addresses`: recipients of the emails\n\n### Sendgrid\n\n* `Sendgrid api key`: api key of the sendgrid account\n* `Email addresses`: recipients of the emails\n\n## File \n\n* `File path`: path where the logs will be write \n* `Max file size`: when size is reached, Otoroshi will create a new file postfixed by the current timestamp\n\n## Console \n\nNothing to add. The events will be write on the standard output.\n\n## Custom \n\nThis type of exporter let you the possibility to write your own exporter with your own rules. To create an exporter, we need to navigate to the plugins page, and to create a new item of type exporter.\n\nWhen it's done, the exporter will be visible in this list.\n\n* `Exporter config.`: the configuration of the custom exporter.\n\n## Metrics \n\nThis plugin is useful to rewrite the metric labels exposed on the `/metrics` endpoint.\n\n* `Labels`: list of metric labels. Each pair contains an existing field name and the new name."},{"name":"global-config.md","id":"/entities/global-config.md","url":"/entities/global-config.html","title":"Global config","content":"# Global config\n\nThe global config, named `Danger zone` in Otoroshi, is the place to configure Otoroshi globally. \n\n> Warning: In this page, the configuration is really sensitive and affect the global behaviour of Otoroshi.\n\n\n### Misc. Settings\n\n\n* `Maintenance mode` : It pass every single service in maintenance mode. If an user calls a service, the maintenance page will be displayed\n* `No OAuth login for BackOffice` : Forces admins to login only with user/password or user/password/u2F device\n* `API Read Only`:Freeze the Otoroshi datastore in read only mode. Only people with access to the actual underlying datastore will be able to disable this.\n* `Auto link default` : When no group is specified on a service, it will be assigned to default one\n* `Use circuit breakers` : Use circuit breaker on all services\n* `Use new http client as the default Http client` : All http calls will use the new http client client by default\n* `Enable live metrics` : Enable live metrics in the Otoroshi cluster. Performs a lot of writes in the datastore\n* `Digitus medius` : Use middle finger emoji () as a response character for endless HTTP responses.\n* `Limit conc. req.` : Limit the number of concurrent request processed by Otoroshi to a certain amount. Highly recommended for resilience\n* `Use X-Forwarded-* headers for routing` : When evaluating routing of a request X-Forwarded-* headers will be used if presents\n* `Max conc. req.` : Maximum number of concurrent request processed by otoroshi.\n* `Max HTTP/1.0 resp. size` : Maximum size of an HTTP/1.0 response in bytes. After this limit, response will be cut and sent as is. The best value here should satisfy (maxConcurrentRequests * maxHttp10ResponseSize) < process.memory for worst case scenario.\n* `Max local events` : Maximum number of events stored.\n* `Lines` : *deprecated* \n\n### IP address filtering settings\n\n* `IP allowed list`: Only IP addresses that will be able to access Otoroshi exposed services\n* `IP blocklist`: IP addresses that will be refused to access Otoroshi exposed services\n* `Endless HTTP Responses`: IP addresses for which each request will return around 128 Gb of 0s\n\n\n### Quotas settings\n\n* `Global throttling`: The max. number of requests allowed per seconds globally on Otoroshi\n* `Throttling per IP`:The max. number of requests allowed per seconds per IP address globally on Otoroshi\n\n### Analytics: Elastic dashboard datasource (read)\n\n* `Cluster URI`: Elastic cluster URI\n* `Index`: Elastic index \n* `Type`: Event type (not needed for elasticsearch above 6.x)\n* `User`: Elastic User (optional)\n* `Password`: Elastic password (optional)\n* `Version`: Elastic version (optional, if none provided it will be fetched from cluster)\n* `Apply template`: Automatically apply index template\n* `Check Connection`: Button to test the configuration. It will displayed a modal with checked point, and if the case of it's successfull, it will displayed the found version of the Elasticsearch and the index used\n* `Manually apply index template`: try to put the elasticsearch template by calling the api of elasticsearch\n* `Show index template`: try to retrieve the current index template presents in elasticsearch\n* `Client side temporal indexes handling`: When enabled, Otoroshi will manage the creation of indexes. When it's disabled, Otoroshi will push in the same index\n* `One index per`: When the previous field is enabled, you can choose the interval of time between the creation of a new index in elasticsearch \n* `Custom TLS Settings`: Enable the TLS configuration for the communication with Elasticsearch\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `TrustAll`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with elasticsearch\n* `Trusted certificates`: list of trusted certificates received from elasticsearch\n### Statsd settings\n\n* `Datadog agent`:The StatsD agent is a Datadog agent\n* `StatsD agent host`:The host on which StatsD agent is listening\n* `StatsD agent port`:The port on which StatsD agent is listening (default is 8125)\n### Backoffice auth. settings\n\n* `Backoffice auth. config`: the authentication module used in front of Otoroshi. It will be used to connect to Otoroshi on the login page\n\n### Let's encrypt settings\n\n* `Enabled`: when enabled, Otoroshi will have the possiblity to sign certificate from let's encrypt notably in the SSL/TSL Certificates page \n* `Server URL`: ACME endpoint of let's encrypt \n* `Email addresses`: (optional) list of addresses used to order the certificates \n* `Contact URLs`: (optional) list of addresses used to order the certificates \n* `Public Key`: used to ask a certificate to let's encrypt, generated by Otoroshi \n* `Private Key`: used to ask a certificate to let's encrypt, generated by Otoroshi \n### CleverCloud settings\n\nOnce configured, you can register one clever cloud app of your organization directly as an Otoroshi service.\n\n* `CleverCloud consumer key`: consumer key of your clever cloud OAuth 1.0 app\n* `CleverCloud consumer secret`: consumer secret of your clever cloud OAuth 1.0 app\n* `OAuth Token`: oauth token of your clever cloud OAuth 1.0 app\n* `OAuth Secret`: oauth token secret of your clever cloud OAuth 1.0 app \n* `CleverCloud orga. Id`:id of your clever cloud organization\n\n###  Global scripts\n\nGlobal scripts will be deprecated soon, please use global plugins instead (see the next section)!\n\n###  Global plugins\n\n* `Enabled`: enabled all global plugins\n* `Plugins`: list of added plugins to your instance\n* `Plugin configuration`: each added plugin have a configuration that you can override from this field\n\n###  Proxies\n\nIn this section, you can add a list of proxies for :\n* Proxy for alert emails (mailgun)\n* Proxy for alert webhooks\n* Proxy for Clever-Cloud API access\n* Proxy for services access\n* Proxy for auth. access (OAuth, OIDC)\n* Proxy for client validators\n* Proxy for JWKS access\n* Proxy for elastic access\n\nEach proxy has the following fields \n\n* `Proxy host`:host of proxy\n* `Proxy port`:port of proxy\n* `Proxy principal`:user of proxy\n* `Proxy password`:password of proxy\n* `Non proxy host`:IP address that can access the service\n\n###  Quotas alerting settings\n\n* `Enable quotas exceeding alerts`: When apikey quotas is almost exceeded, an alert will be sent \n* `Daily quotas threshold`: The percentage of daily calls before sending alerts\n* `Monthly quotas threshold`: The percentage of monthly calls before sending alerts\n\n###  User-Agent extraction settings\n\n* `User-Agent extraction`: Allow user-agent details extraction. Can have impact on consumed memory.\n\n###  Geolocation extraction settings\n\nExtract an geolocation for each call to Otoroshi.\n\n###  Tls Settings\n\n* `Use random cert.`: Use the first available cert none matches the current domain\n* `Default domain`: When the SNI domain cannot be found, this one will be used to find the matching certificate\n* `Trust JDK CAs (server)`:Trust JDK CAs. The CAs from the JDK CA bundle will be proposed in the certificate request when performing TLS handshake\n* `Trust JDK CAs (trust)`: Trust JDK CAs. The CAs from the JDK CA bundle will be used as trusted CAs when calling HTTPS resources\n* `Trusted CAs (server)`:Select the trusted CAs you want for TLS terminaison. Those CAs only will be proposed in the certificate request when performing TLS handshake\n\n\n###  Auto Generate Certificates\n\n* `Enabled`:Generate certificates on the fly when they not exist\n* `Reply Nicely`:When not allowed domain name, accept connection and display a nice error message\n* `CA`:certificate CA used to generate missing certificate\n* `Allowed domains`:Allowed domains\n* `Not allowed domains`:Allowed domains\n###  Global metadata\n\n* `Tags`: tags attached to the global config\n* `Metadata`:metadata attached to the global config\n\n### Actions at the bottom of the page\n\n* `Recover from a full export file`:Load global configuration from a previous export\n* `Full export`: Export with all created entities\n* `Full export (ndjson)`: Export your full state of database to ndjson format\n* `JSON`: Get the global config at JSON format\n* `YAML`:Get the global config at YAML format\n* `Enable Panic Mode`: Log out all users from UI and prevent any changes to the database by setting the admin Otoroshi api to read-only. The only way to exit of this mode is to disable this mode directly in the database."},{"name":"index.md","id":"/entities/index.md","url":"/entities/index.html","title":"","content":"\n# Main entities\n\nin this section, we will pass through all the main Otoroshi entities\n\n* @ref:[Organizations](./organizations.md)\n* @ref:[Teams](./teams.md)\n* @ref:[Global Config](./global-config.md)\n* @ref:[Apikeys](./apikeys.md)\n* @ref:[Service groups](./service-groups.md)\n* @ref:[Service descriptors](./service-descriptors.md)\n* @ref:[Auth. modules](./auth-modules.md)\n* @ref:[Certificates](./certificates.md)\n* @ref:[JWT verifiers](./jwt-verifiers.md)\n* @ref:[Data exporters](./data-exporters.md)\n* @ref:[Scripts](./scripts.md)\n* @ref:[TCP services](./tcp-services.md)\n\n@@@ index\n\n* [Organizations](./organizations.md)\n* [Teams](./teams.md)\n* [Global Config](./global-config.md)\n* [Apikeys](./apikeys.md)\n* [Service groups](./service-groups.md)\n* [Service descriptors](./service-descriptors.md)\n* [Auth. modules](./auth-modules.md)\n* [Certificates](./certificates.md)\n* [JWT verifiers](./jwt-verifiers.md)\n* [Data exporters](./data-exporters.md)\n* [Scripts](./scripts.md)\n* [TCP services](./tcp-services.md)\n\n@@@\n"},{"name":"jwt-verifiers.md","id":"/entities/jwt-verifiers.md","url":"/entities/jwt-verifiers.html","title":"JWT verifiers","content":"# JWT verifiers\n\nSometimes, it can be pretty useful to verify Jwt tokens coming from other provider on some services. Otoroshi provides a tool to do that per service.\n\n* `Name`: name of the JWT verifier\n* `Description`: a simple description\n* `Strict`: if not strict, request without JWT token will be allowed to pass. This option is helpful when you want to force the presence of tokens in each request on a specific service \n* `Tags`: list of tags associated to the module\n* `Metadata`: list of metadata associated to the module\n\nEach JWT verifier is configurable in three steps : the `location` where find the token in incoming requests, the `validation` step to check the signature and the presence of claims in tokens, and the last step, named `Strategy`.\n\n## Token location\n\nAn incoming token can be found in three places.\n\n#### In query string\n\n* `Source`: JWT token location in query string\n* `Query param name`: the name of the query param where JWT is located\n\n#### In a header\n\n* `Source`: JWT token location in a header\n* `Header name`: the name of the header where JWT is located\n* `Remove value`: when the token is read, this value will be remove of header value (example: if the header value is *Bearer xxxx*, the *remove value* could be Bearer&nbsp; don't forget the space at the end of the string)\n\n#### In a cookie\n\n* `Source`: JWT token location in a cookie\n* `Cookie name`: the name of the cookie where JWT is located\n\n## Token validation\n\nThis section is used to verify the extracted token from specified location.\n\n* `Algo.`: What kind of algorithm you want to use to verify/sign your JWT token with\n\nAccording to the selected algorithm, the validation form will change.\n\n#### Hmac + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Hmac secret`: used to verify the token\n* `Base64 encoded secret`: if enabled, the extracted token will be base64 decoded before it is verifier\n\n#### RSASSA-PKCS1 + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Public key`: the RSA public key\n* `Private key`: the RSA private key that can be empty if not used for JWT token signing\n\n#### ECDSA + SHA\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `Public key`: the ECDSA public key\n* `Private key`: the ECDSA private key that can be empty if not used for JWT token signing\n\n#### RSASSA-PKCS1 + SHA from KeyPair\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `KeyPair`: used to sign/verify token. The displayed list represents the key pair registered in the Certificates page\n  \n#### ECDSA + SHA from KeyPair\n* `SHA Size`: Word size for the SHA-2 hash function used\n* `KeyPair`: used to sign/verify token. The displayed list represents the key pair registered in the Certificates page\n\n#### Otoroshi KeyPair from token kid (only for verification)\n* `Use only exposed keypairs`: if enabled, Otoroshi will only use the key pairs that are exposed on the well-known. If disabled, it will search on any registered key pairs.\n\n#### JWK Set (only for verification)\n\n* `URL`: the JWK set URL where the public keys are exposed\n* `HTTP call timeout`: timeout for fetching the keyset\n* `TTL`: cache TTL for the keyset\n* `HTTP Headers`: the HTTP headers passed\n* `Key type`: type of the key searched in the jwks\n\n*TLS settings for JWKS fetching*\n\n* `Custom TLS Settings`: TLS settings for JWKS fetching\n* `TLS loose`: if enabled, will block all untrustful ssl configs\n* `Trust all`: allows any server certificates even the self-signed ones\n* `Client certificates`: list of client certificates used to communicate with JWKS server\n* `Trusted certificates`: list of trusted certificates received from JWKS server\n\n*Proxy*\n\n* `Proxy host`: host of proxy behind the identify provider\n* `Proxy port`: port of proxy behind the identify provider\n* `Proxy principal`: user of proxy \n* `Proxy password`: password of proxy\n\n## Strategy\n\nThe first step is to select the verifier strategy. Otoroshi supports 4 types of JWT verifiers : \n* `Default JWT token` will add a token if no present. \n* `Verify JWT token` will only verifiy token signing and fields values if provided. \n* `Verify and re-sign JWT token` will verify the token and will re-sign the JWT token with the provided algo. settings. \n* `Verify, re-sign and transform JWT token` will verify the token, re-sign and will be able to transform the token.\n\nAll verifiers has the following properties: \n\n* `Verify token fields`: when the JWT token is checked, each field specified here will be verified with the provided value\n* `Verify token array value`: when the JWT token is checked, each field specified here will be verified if the provided value is contained in the array\n\n\n#### Default JWT token\n\n* `Strict`: if token is already present, the call will fail\n* `Default value`: list of claims of the generated token. These fields support raw values or language expressions. See the documentation on the expression language \n@@@ warning\nTODO - set the link to the expression language documentation)\n@@@\n\n#### Verify JWT token\n\nNo specific values needed. This kind of verifier needs only the two fields `Verify token fields` and `Verify token array value`.\n\n#### Verify and re-sign JWT token\n\nWhen `Verify and re-sign JWT token` is chosen, the `Re-sign settings` appear. All fields of `Re-sign settings` are the same of the `Token validation` section. The only difference is that the values are used to sign the new token and not to validate the token.\n\n\n#### Verify, re-sign and transform JWT token\n\nWhen `Verify, re-sign and transform JWT token` is chosen, the `Re-sign settings` and `Transformation settings` appear.\n\nThe `Re-sign settings` are used to sign the new token and has the same fields than the `Token validation` section.\n\nFor the `Transformation settings` section, the fields are:\n* `Token location`: the location where to find/set the JWT token\n* `Header name`: the name of the header where JWT is located\n* `Prepend value`: remove a value inside the header value\n* `Rename token fields`: when the JWT token is transformed, it is possible to change a field name, just specify origin field name and target field name\n* `Set token fields`: when the JWT token is transformed, it is possible to add new field with static values, just specify field name and value\n* `Remove token fields`: when the JWT token is transformed, it is possible to remove fields"},{"name":"organizations.md","id":"/entities/organizations.md","url":"/entities/organizations.html","title":"Organizations","content":"# Organizations\n\nThe resources of Otoroshi are grouped by `Organization`. This the most high level for grouping resources.\n\nAn organization have a unique `id`, a `name` and a `description`. As all Otoroshi resources, an Organization have a list of tags and metadatas associated.\n\nFor example, you can use the organizations as a mean of :\n* to seperate resources by `entity` of you enterprise\n* to split internal and external usage of the resources (it's useful when you have a list of service deployed in your compagny and another deployed by yours partners)\n\n## Access to the list of organizations\n\nTo visualize and edit the list of organizations, you can navigate to your instance on the `/bo/dashboard/organizations` route or click on the cog icon and select the organizations button.\n\nOnce on the page, you can create a new item, edit an existing organization or delete an existing one.\n\n> When an organization is deleted, the resources associated are not deleted. On the other hand, the organization and the team of associated resources are let empty."},{"name":"scripts.md","id":"/entities/scripts.md","url":"/entities/scripts.html","title":"Scripts","content":"# Scripts\n\n@@@ warning\nTODO\n@@@"},{"name":"service-descriptors.md","id":"/entities/service-descriptors.md","url":"/entities/service-descriptors.html","title":"Service descriptors","content":"# Service descriptors\n\n@@@ warning\nTODO\n@@@"},{"name":"service-groups.md","id":"/entities/service-groups.md","url":"/entities/service-groups.html","title":"Service groups","content":"# Service groups\n\nA service group is composed of an unique `id`, a `Group name`, a `Group description`, an `Organization` and a `Team`. As all Otoroshi resources, a service group have a list of tags and metadatas associated.\n\nThe first instinctive usage of service group is to group a list of services. \n\nWhen it's done, you can authorize an api key on a specific group. Instead of authorize an api key for each service, you can regroup a list of services together, and give authorization on the group (read the page on the api keys and the usage of the `Authorized on.` field).\n\n## Access to the list of service groups\n\nTo visualize and edit the list of groups, you can navigate to your instance on the `/bo/dashboard/groups` route or click on the cog icon and select the Service groups button.\n\nOnce on the page, you can create a new item, edit an existing service group or delete an existing one.\n\n> When a service group is deleted, the resources associated are not deleted. On the other hand, the service group of associated resources is let empty.\n\n"},{"name":"tcp-services.md","id":"/entities/tcp-services.md","url":"/entities/tcp-services.html","title":"TCP services","content":"# TCP services\n\n@@@ warning\nTODO\n@@@"},{"name":"teams.md","id":"/entities/teams.md","url":"/entities/teams.html","title":"Teams","content":"# Teams\n\nIn Otoroshi, all resources are attached to an `Organization` and a `Team`. \n\nA team is composed of an unique `id`, a `name`, a `description` and an `Organization`. As all Otoroshi resources, a Team have a list of tags and metadatas associated.\n\nA team have an unique organization and can be use on multiples resources (services, api keys, etc ...).\n\nA connected user on Otoroshi UI has a list of teams and organizations associated. It can be helpful when you want restrict the rights of a connected user.\n\n## Access to the list of teams\n\nTo visualize and edit the list of teams, you can navigate to your instance on the `/bo/dashboard/teams` route or click on the cog icon and select the teams button.\n\nOnce on the page, you can create a new item, edit an existing team or delete an existing one.\n\n> When a team is deleted, the resources associated are not deleted. On the other hand, the team of associated resources is let empty.\n\n"},{"name":"features.md","id":"/features.md","url":"/features.html","title":"Features","content":"# Features\n\n@@@ warning\nTODO\n@@@"},{"name":"getting-started.md","id":"/getting-started.md","url":"/getting-started.html","title":"Getting Started","content":"# Getting Started\n\n@@@ warning\nTODO\n@@@"},{"name":"end-to-end-mtls.md","id":"/how-to-s/end-to-end-mtls.md","url":"/how-to-s/end-to-end-mtls.html","title":"End-to-end mTLS","content":"# End-to-end mTLS\n\n@@@ warning\nTODO\n@@@"},{"name":"export-alerts-using-mailgun.md","id":"/how-to-s/export-alerts-using-mailgun.md","url":"/how-to-s/export-alerts-using-mailgun.html","title":"Send alerts using mailgun","content":"# Send alerts using mailgun\n\nAll Otoroshi alerts can be send on different channels.\nOne of the ways is to send a group of specific alerts via emails.\n\nTo enable this behaviour, let's start by create an exporter of events.\n\nIn this tutorial, we will admit that you already have a mailgun account with an API key and a domain.\n\n## Create an Mailgun exporter\n\nLet's create an exporter. The exporter will export by default all events generate by Otoroshi.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n2. Click on the cog icon on the top right\n3. Then `Exporters` button\n4. And add a new configuration when clicking on the `Add item` button\n5. Select the `mailer` in the `type` selector field\n6. Jump to `Exporter config` and select the `Mailgun` option\n7. Set the following values\n\n| Field         | Value                   |\n| ------------- | ----------------------- |\n| `EU` | `false` or `true` depending on your mailgun configuratin |\n| `Mailgun api key` | your-mailgun-api-key |\n| `Mailgun domain` | your-mailgun-domain |\n| `Email addresses` | list of the recipient adresses |\n\nWith this configuration, all Otoroshi events will be send to your listed addresses (we don't recommended to do that).\n\nTo filter events on `Alerts` type, we need to add the following configuration inside the `Filtering and projection` section.\n\n```json\n{\n    \"include\": [\n        { \"@type\": \"AlertEvent\" }\n    ],\n    \"exclude\": []\n}\n``` \n\nSave at the bottom page and enable the exporter (on the top of the page or in list of exporters).\n\nThe second field can be useful in the case you want filter the fields contains in each alert sended.\n\nThe `Projection` field is a json when you can list the fields to keep for each alerts.\n\n```json\n{\n \"@type\": true,\n \"@timestamp\": true,\n \"@id\": true\n}\n```\nWith this example, only `@type`, `@timestamp` and `@id` will be send to your recipient adresses."},{"name":"export-events-to-elastic.md","id":"/how-to-s/export-events-to-elastic.md","url":"/how-to-s/export-events-to-elastic.html","title":"Export events to Elasticsearch","content":"# Export events to Elasticsearch\n\n### Cover by this tutorial\n- [Before you start](#before-you-start)\n- [Deploy a Elasticsearch and kibana stack on Docker](#deploy-a-elasticsearch-and-kibana-stack-on-docker)\n- [Create an Elasticsearch exporter](#create-an-elasticsearch-exporter)\n- [Testing your configuration](#testing-your-configuration)\n- [Advanced usage](#advanced-usage)\n- [Debug your configuration](#debug-your-configuration)\n- \n\n@@@ warning\nTODO - schema\n@@@\n\n### Before you start\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n\n### Deploy a Elasticsearch and kibana stack on Docker\n\nLet's start by create an Elasticsearch and Kibana stack on our machine (if it's already done for you, you can skip this section).\n\nTo start an Elasticsearch container for development or testing, run:\n\n```sh\ndocker network create elastic\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.1\ndocker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.15.1\n```\n\n```sh\ndocker pull docker.elastic.co/kibana/kibana:7.15.1\ndocker run --name kib01-test --net elastic -p 5601:5601 -e \"ELASTICSEARCH_HOSTS=http://es01-test:9200\" docker.elastic.co/kibana/kibana:7.15.1\n```\n\nTo access Kibana, go to *http://localhost:5601*.\n\n### Create an Elasticsearch exporter\n\nLet's create an exporter. The exporter will export by default all events generate by Otoroshi.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n2. Click on the cog icon on the top right\n3. Then `Exporters` button\n4. And add a new configuration when clicking on the `Add item` button\n5. Select the `elastic` in the `type` selector field\n6. Jump to `Exporter config`\n7. Set the following values\n\n| Field         | Value                   |\n| ------------- | ----------------------- |\n| `Cluster URI` | `http://localhost:9200` |\n\nThen test your configuration with `Check connection` button. This should output a modal with Elasticsearch version and the number of loaded docs.\n\nSave at the bottom page and enable the exporter (on the top of the page or in list).\n\n### Testing your configuration\n\nOne simple way to test is to setup the reading of the elasticsearch by Otoroshi.\n\nNavigate to the danger zone (click on the cog on the right top and scroll to `danger zone`).\n\nJump to the `Analytics: Elastic dashboard datasource (read)` section.\n\nSet the following values : \n\n| Field         | Value                   |\n| ------------- | ----------------------- |\n| `Cluster URI` | `http://localhost:9200` |\n\nThen click on the `Check connection`. This should ouput the same result as the previous part. Save the global configuration and navigate to *http://otoroshi.oto.tools:9999/bo/dashboard/stats*.\n\nThis should output a list of graphs.\n\n### Advanced usage\n\nBy default, an exporter handle all events from Otoroshi. In some case, you need to filter the events to send to elasticsearch.\n\nTo filter the events, jump to the `Filtering and projection` field in exporter view. Otoroshi supports to include a kind of events or to exclude a list of events. \n\nAn example which include only events with a field `@type` of value `AlertEvent` :\n```json\n{\n    \"include\": [\n        { \"@type\": \"AlertEvent\" }\n    ],\n    \"exclude\": []\n}\n```\nAn example which exclude only events with a field `@type` of value `GatewayEvent` :\n```json\n{\n    \"exclude\": [\n        { \"@type\": \"GatewayEvent\" }\n    ],\n    \"include\": []\n}\n```\n\nThe next field is the `Projection`. This field is a json when you can list the fields to keep for each events.\n\n```json\n{\n \"@type\": true,\n \"@timestamp\": true,\n \"@id\": true\n}\n```\nWith this example, only `@type`, `@timestamp` and `@id` will be send to ES.\n\n### Debug your configuration\n\n#### Missing user rights on Elasticsearch\n\nWhen creating an exporter, Otoroshi try to join the index route of the elasticsearch instance. If you have a specific management access rights on Elasticsearch, you have two possiblities :\n\n- set a full access to the user used in Otoroshi for write in Elasticsearch\n- set the version of Elasticsearch inside the `Version` field of your exporter.\n\n#### None events appear in your Elasticsearch\n\nWhen creating an exporter, Otoroshi try to push the index template on Elasticsearch. If the post failed, Otoroshi will fail for each push of events and your database will keep empty. \n\nTo fix this problem, you can try to send the index template with the `Manually apply index template` button in your exporter."},{"name":"import-export-otoroshi-datastore.md","id":"/how-to-s/import-export-otoroshi-datastore.md","url":"/how-to-s/import-export-otoroshi-datastore.html","title":"Import and export Otoroshi datastore","content":"# Import and export Otoroshi datastore\n\n### Cover by this tutorial\n- [Start Otoroshi with an initial datastore](#start-otoroshi-with-an-initial-state)\n- [Export the current datastore via the danger zone](#export-the-current-datastore-via-the-danger-zone)\n- [Import a datastore from file via the danger zone](#import-a-datastore-from-file-via-the-danger-zone)\n- [Export the current datastore with Admin API](#export-the-current-datastore-via-the-danger-zone)\n- [Import the current datastore with Admin API](#import-a-datastore-from-file-via-the-danger-zone)\n\n### Start Otoroshi with an initial datastore\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n```sh\nsudo nano /etc/hosts\n\n# Add this line at the bottom of your file\n127.0.0.1\totoroshi.oto.tools privateapps.oto.tools otoroshi-api.oto.tools otoroshi-admin-internal-api.oto.tools localhost\n```\n\nNow you are almost ready to run Otoroshi for the first time, we want run it with an initial data.\n\nTo do that, you need to add the app.importFrom setting to the Otoroshi configuration (of $APP_IMPORT_FROM env).\n\nIt can be a file path or a URL.\n\nThe content of the initial datastore.\n\n```json\n{\n  \"label\": \"Otoroshi initial datastore\",\n  \"admins\": [],\n  \"simpleAdmins\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"username\": \"admin@otoroshi.io\",\n      \"password\": \"$2a$10$iQRkqjKTW.5XH8ugQrnMDeUstx4KqmIeQ58dHHdW2Dv1FkyyAs4C.\",\n      \"label\": \"Otoroshi Admin\",\n      \"createdAt\": 1634651307724,\n      \"type\": \"SIMPLE\",\n      \"metadata\": {},\n      \"tags\": [],\n      \"rights\": [\n        {\n          \"tenant\": \"*:rw\",\n          \"teams\": [\n            \"*:rw\"\n          ]\n        }\n      ]\n    }\n  ],\n  \"serviceGroups\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"admin-api-group\",\n      \"name\": \"Otoroshi Admin Api group\",\n      \"description\": \"No description\",\n      \"tags\": [],\n      \"metadata\": {}\n    },\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"default\",\n      \"name\": \"default-group\",\n      \"description\": \"The default service group\",\n      \"tags\": [],\n      \"metadata\": {}\n    }\n  ],\n  \"apiKeys\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"clientId\": \"admin-api-apikey-id\",\n      \"clientSecret\": \"admin-api-apikey-secret\",\n      \"clientName\": \"Otoroshi Backoffice ApiKey\",\n      \"description\": \"The apikey use by the Otoroshi UI\",\n      \"authorizedGroup\": \"admin-api-group\",\n      \"authorizedEntities\": [\n        \"group_admin-api-group\"\n      ],\n      \"enabled\": true,\n      \"readOnly\": false,\n      \"allowClientIdOnly\": false,\n      \"throttlingQuota\": 10000,\n      \"dailyQuota\": 10000000,\n      \"monthlyQuota\": 10000000,\n      \"constrainedServicesOnly\": false,\n      \"restrictions\": {\n        \"enabled\": false,\n        \"allowLast\": true,\n        \"allowed\": [],\n        \"forbidden\": [],\n        \"notFound\": []\n      },\n      \"rotation\": {\n        \"enabled\": false,\n        \"rotationEvery\": 744,\n        \"gracePeriod\": 168,\n        \"nextSecret\": null\n      },\n      \"validUntil\": null,\n      \"tags\": [],\n      \"metadata\": {}\n    }\n  ],\n  \"serviceDescriptors\": [\n    {\n      \"_loc\": {\n        \"tenant\": \"default\",\n        \"teams\": [\n          \"default\"\n        ]\n      },\n      \"id\": \"admin-api-service\",\n      \"groupId\": \"admin-api-group\",\n      \"groups\": [\n        \"admin-api-group\"\n      ],\n      \"name\": \"otoroshi-admin-api\",\n      \"description\": \"\",\n      \"env\": \"prod\",\n      \"domain\": \"oto.tools\",\n      \"subdomain\": \"otoroshi-api\",\n      \"targetsLoadBalancing\": {\n        \"type\": \"RoundRobin\"\n      },\n      \"targets\": [\n        {\n          \"host\": \"127.0.0.1:9999\",\n          \"scheme\": \"http\",\n          \"weight\": 1,\n          \"mtlsConfig\": {\n            \"certs\": [],\n            \"trustedCerts\": [],\n            \"mtls\": false,\n            \"loose\": false,\n            \"trustAll\": false\n          },\n          \"tags\": [],\n          \"metadata\": {},\n          \"protocol\": \"HTTP/1.1\",\n          \"predicate\": {\n            \"type\": \"AlwaysMatch\"\n          },\n          \"ipAddress\": null\n        }\n      ],\n      \"root\": \"/\",\n      \"matchingRoot\": null,\n      \"stripPath\": true,\n      \"localHost\": \"127.0.0.1:9999\",\n      \"localScheme\": \"http\",\n      \"redirectToLocal\": false,\n      \"enabled\": true,\n      \"userFacing\": false,\n      \"privateApp\": false,\n      \"forceHttps\": false,\n      \"logAnalyticsOnServer\": false,\n      \"useAkkaHttpClient\": true,\n      \"useNewWSClient\": false,\n      \"tcpUdpTunneling\": false,\n      \"detectApiKeySooner\": false,\n      \"maintenanceMode\": false,\n      \"buildMode\": false,\n      \"strictlyPrivate\": false,\n      \"enforceSecureCommunication\": true,\n      \"sendInfoToken\": true,\n      \"sendStateChallenge\": true,\n      \"sendOtoroshiHeadersBack\": true,\n      \"readOnly\": false,\n      \"xForwardedHeaders\": false,\n      \"overrideHost\": true,\n      \"allowHttp10\": true,\n      \"letsEncrypt\": false,\n      \"secComHeaders\": {\n        \"claimRequestName\": null,\n        \"stateRequestName\": null,\n        \"stateResponseName\": null\n      },\n      \"secComTtl\": 30000,\n      \"secComVersion\": 1,\n      \"secComInfoTokenVersion\": \"Legacy\",\n      \"secComExcludedPatterns\": [],\n      \"securityExcludedPatterns\": [],\n      \"publicPatterns\": [\n        \"/health\",\n        \"/metrics\"\n      ],\n      \"privatePatterns\": [],\n      \"additionalHeaders\": {\n        \"Host\": \"otoroshi-admin-internal-api.oto.tools\"\n      },\n      \"additionalHeadersOut\": {},\n      \"missingOnlyHeadersIn\": {},\n      \"missingOnlyHeadersOut\": {},\n      \"removeHeadersIn\": [],\n      \"removeHeadersOut\": [],\n      \"headersVerification\": {},\n      \"matchingHeaders\": {},\n      \"ipFiltering\": {\n        \"whitelist\": [],\n        \"blacklist\": []\n      },\n      \"api\": {\n        \"exposeApi\": false\n      },\n      \"healthCheck\": {\n        \"enabled\": false,\n        \"url\": \"/\"\n      },\n      \"clientConfig\": {\n        \"useCircuitBreaker\": true,\n        \"retries\": 1,\n        \"maxErrors\": 20,\n        \"retryInitialDelay\": 50,\n        \"backoffFactor\": 2,\n        \"callTimeout\": 30000,\n        \"callAndStreamTimeout\": 120000,\n        \"connectionTimeout\": 10000,\n        \"idleTimeout\": 60000,\n        \"globalTimeout\": 30000,\n        \"sampleInterval\": 2000,\n        \"proxy\": {},\n        \"customTimeouts\": [],\n        \"cacheConnectionSettings\": {\n          \"enabled\": false,\n          \"queueSize\": 2048\n        }\n      },\n      \"canary\": {\n        \"enabled\": false,\n        \"traffic\": 0.2,\n        \"targets\": [],\n        \"root\": \"/\"\n      },\n      \"gzip\": {\n        \"enabled\": false,\n        \"excludedPatterns\": [],\n        \"whiteList\": [\n          \"text/*\",\n          \"application/javascript\",\n          \"application/json\"\n        ],\n        \"blackList\": [],\n        \"bufferSize\": 8192,\n        \"chunkedThreshold\": 102400,\n        \"compressionLevel\": 5\n      },\n      \"metadata\": {},\n      \"tags\": [],\n      \"chaosConfig\": {\n        \"enabled\": false,\n        \"largeRequestFaultConfig\": null,\n        \"largeResponseFaultConfig\": null,\n        \"latencyInjectionFaultConfig\": null,\n        \"badResponsesFaultConfig\": null\n      },\n      \"jwtVerifier\": {\n        \"type\": \"ref\",\n        \"ids\": [],\n        \"id\": null,\n        \"enabled\": false,\n        \"excludedPatterns\": []\n      },\n      \"secComSettings\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"${config.app.claim.sharedKey}\",\n        \"base64\": false\n      },\n      \"secComUseSameAlgo\": true,\n      \"secComAlgoChallengeOtoToBack\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"secComAlgoChallengeBackToOto\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"secComAlgoInfoToken\": {\n        \"type\": \"HSAlgoSettings\",\n        \"size\": 512,\n        \"secret\": \"secret\",\n        \"base64\": false\n      },\n      \"cors\": {\n        \"enabled\": false,\n        \"allowOrigin\": \"*\",\n        \"exposeHeaders\": [],\n        \"allowHeaders\": [],\n        \"allowMethods\": [],\n        \"excludedPatterns\": [],\n        \"maxAge\": null,\n        \"allowCredentials\": true\n      },\n      \"redirection\": {\n        \"enabled\": false,\n        \"code\": 303,\n        \"to\": \"https://www.otoroshi.io\"\n      },\n      \"authConfigRef\": null,\n      \"clientValidatorRef\": null,\n      \"transformerRef\": null,\n      \"transformerRefs\": [],\n      \"transformerConfig\": {},\n      \"apiKeyConstraints\": {\n        \"basicAuth\": {\n          \"enabled\": true,\n          \"headerName\": null,\n          \"queryName\": null\n        },\n        \"customHeadersAuth\": {\n          \"enabled\": true,\n          \"clientIdHeaderName\": null,\n          \"clientSecretHeaderName\": null\n        },\n        \"clientIdAuth\": {\n          \"enabled\": true,\n          \"headerName\": null,\n          \"queryName\": null\n        },\n        \"jwtAuth\": {\n          \"enabled\": true,\n          \"secretSigned\": true,\n          \"keyPairSigned\": true,\n          \"includeRequestAttributes\": false,\n          \"maxJwtLifespanSecs\": null,\n          \"headerName\": null,\n          \"queryName\": null,\n          \"cookieName\": null\n        },\n        \"routing\": {\n          \"noneTagIn\": [],\n          \"oneTagIn\": [],\n          \"allTagsIn\": [],\n          \"noneMetaIn\": {},\n          \"oneMetaIn\": {},\n          \"allMetaIn\": {},\n          \"noneMetaKeysIn\": [],\n          \"oneMetaKeyIn\": [],\n          \"allMetaKeysIn\": []\n        }\n      },\n      \"restrictions\": {\n        \"enabled\": false,\n        \"allowLast\": true,\n        \"allowed\": [],\n        \"forbidden\": [],\n        \"notFound\": []\n      },\n      \"accessValidator\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excludedPatterns\": []\n      },\n      \"preRouting\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excludedPatterns\": []\n      },\n      \"plugins\": {\n        \"enabled\": false,\n        \"refs\": [],\n        \"config\": {},\n        \"excluded\": []\n      },\n      \"hosts\": [\n        \"otoroshi-api.oto.tools\"\n      ],\n      \"paths\": [],\n      \"handleLegacyDomain\": true,\n      \"issueCert\": false,\n      \"issueCertCA\": null\n    }\n  ],\n  \"errorTemplates\": [],\n  \"jwtVerifiers\": [],\n  \"authConfigs\": [],\n  \"certificates\": [],\n  \"clientValidators\": [],\n  \"scripts\": [],\n  \"tcpServices\": [],\n  \"dataExporters\": [],\n  \"tenants\": [\n    {\n      \"id\": \"default\",\n      \"name\": \"Default organization\",\n      \"description\": \"The default organization\",\n      \"metadata\": {},\n      \"tags\": []\n    }\n  ],\n  \"teams\": [\n    {\n      \"id\": \"default\",\n      \"tenant\": \"default\",\n      \"name\": \"Default Team\",\n      \"description\": \"The default Team of the default organization\",\n      \"metadata\": {},\n      \"tags\": []\n    }\n  ]\n}\n```\n\nRun an Otoroshi with the previous file as parameter.\n\n```sh\njava \\\n-Dapp.adminPassword=password \\\n-Dhttp.port=9999 \\\n-Dhttps.port=9998 \\\n-Dapp.importFrom=./initial-state.json \\\n-jar otoroshi.jar \n```\n\nThis should display\n\n```sh\n...\n[info] otoroshi-env - Importing from: ./initial-state.json\n[info] otoroshi-env - Successful import !\n...\n[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9999\n[info] p.c.s.AkkaHttpServer - Listening for HTTPS on /0:0:0:0:0:0:0:0:9998\n...\n```\n\n> Warning : when you using Otoroshi with a datastore different from file or in-memory, Otoroshi doesn't will reload the initialization script. If you expected it, you need to clean manually your store.\n\n### Export the current datastore via the danger zone\n\nWhen Otoroshi is running, you can backup the global configuration store from the UI. Navigate to your instance (in our case *http://otoroshi.oto.tools:9999/bo/dashboard/dangerzone*) and scroll to the bottom page. \n\nClick on `Full export` button to download the full global configuration.\n\n### Import a datastore from file via the danger zone\n\nWhen Otoroshi is running, you can recover a global configuration from the UI. Navigate to your instance (in our case *http://otoroshi.oto.tools:9999/bo/dashboard/dangerzone*) and scroll to the bottom page. \n\nClick on `Recover from a full export file` button to apply all configurations from a file.\n\n### Export the current datastore with the Admin API\n\nOtoroshi exposes his own Admin API to manage Otoroshi resources. To call this api, you need to an api key with the rights on `Otoroshi Admin Api group`. This group includes the `Otoroshi-admin-api` service that you can found on the services page. \n\nBy default, and with our initial configuration, Otoroshi has already created an api key named `Otoroshi Backoffice ApiKey`. You can verify the rights of an api key on its page by checking the `Authorized On` field (you should find the `Otoroshi Admin Api group` inside).\n\nThe default api key id and secret are `admin-api-apikey-id` and `admin-api-apikey-secret`.\n\nRun the next command with these values.\n\n```sh\ncurl \\\n-H 'Content-Type: application/json' \\\nhttp://otoroshi-api.oto.tools:9999/api/otoroshi.json \\\n-u admin-api-apikey-id:admin-api-apikey-secret \n```\n\nWhen calling the `/api/otoroshi.json`, the return should be the current datastore including the service descriptors, the api keys, all others resources like certificates and authentification modules, and the the global config (represented by the form of the danger zone).\n\n### Import the current datastore with the Admin API\n\nAs the same way of previous section, you can erase the current datastore with a POST request. The route is the same : `/api/otoroshi.json`.\n\n```sh\ncurl \\\n-X POST \\\n-H 'Content-Type: application/json' \\\n-d '{\n  \"label\" : \"Otoroshi export\",\n  \"dateRaw\" : 1634714811217,\n  \"date\" : \"2021-10-20 09:26:51\",\n  \"stats\" : {\n    \"calls\" : 4,\n    \"dataIn\" : 0,\n    \"dataOut\" : 97991\n  },\n  \"config\" : {\n    \"tags\" : [ ],\n    \"letsEncryptSettings\" : {\n      \"enabled\" : false,\n      \"server\" : \"acme://letsencrypt.org/staging\",\n      \"emails\" : [ ],\n      \"contacts\" : [ ],\n      \"publicKey\" : \"\",\n      \"privateKey\" : \"\"\n    },\n    \"lines\" : [ \"prod\" ],\n    \"maintenanceMode\" : false,\n    \"enableEmbeddedMetrics\" : true,\n    \"streamEntityOnly\" : true,\n    \"autoLinkToDefaultGroup\" : true,\n    \"limitConcurrentRequests\" : false,\n    \"maxConcurrentRequests\" : 1000,\n    \"maxHttp10ResponseSize\" : 4194304,\n    \"useCircuitBreakers\" : true,\n    \"apiReadOnly\" : false,\n    \"u2fLoginOnly\" : false,\n    \"trustXForwarded\" : true,\n    \"ipFiltering\" : {\n      \"whitelist\" : [ ],\n      \"blacklist\" : [ ]\n    },\n    \"throttlingQuota\" : 10000000,\n    \"perIpThrottlingQuota\" : 10000000,\n    \"analyticsWebhooks\" : [ ],\n    \"alertsWebhooks\" : [ ],\n    \"elasticWritesConfigs\" : [ ],\n    \"elasticReadsConfig\" : null,\n    \"alertsEmails\" : [ ],\n    \"logAnalyticsOnServer\" : false,\n    \"useAkkaHttpClient\" : false,\n    \"endlessIpAddresses\" : [ ],\n    \"statsdConfig\" : null,\n    \"kafkaConfig\" : {\n      \"servers\" : [ ],\n      \"keyPass\" : null,\n      \"keystore\" : null,\n      \"truststore\" : null,\n      \"topic\" : \"otoroshi-events\",\n      \"mtlsConfig\" : {\n        \"certs\" : [ ],\n        \"trustedCerts\" : [ ],\n        \"mtls\" : false,\n        \"loose\" : false,\n        \"trustAll\" : false\n      }\n    },\n    \"backOfficeAuthRef\" : null,\n    \"mailerSettings\" : {\n      \"type\" : \"none\"\n    },\n    \"cleverSettings\" : null,\n    \"maxWebhookSize\" : 100,\n    \"middleFingers\" : false,\n    \"maxLogsSize\" : 10000,\n    \"otoroshiId\" : \"83539cbca-76ee-4abc-ad31-a4794e873848\",\n    \"snowMonkeyConfig\" : {\n      \"enabled\" : false,\n      \"outageStrategy\" : \"OneServicePerGroup\",\n      \"includeUserFacingDescriptors\" : false,\n      \"dryRun\" : false,\n      \"timesPerDay\" : 1,\n      \"startTime\" : \"09:00:00.000\",\n      \"stopTime\" : \"23:59:59.000\",\n      \"outageDurationFrom\" : 600000,\n      \"outageDurationTo\" : 3600000,\n      \"targetGroups\" : [ ],\n      \"chaosConfig\" : {\n        \"enabled\" : true,\n        \"largeRequestFaultConfig\" : null,\n        \"largeResponseFaultConfig\" : null,\n        \"latencyInjectionFaultConfig\" : {\n          \"ratio\" : 0.2,\n          \"from\" : 500,\n          \"to\" : 5000\n        },\n        \"badResponsesFaultConfig\" : {\n          \"ratio\" : 0.2,\n          \"responses\" : [ {\n            \"status\" : 502,\n            \"body\" : \"{\\\"error\\\":\\\"Nihonzaru everywhere ...\\\"}\",\n            \"headers\" : {\n              \"Content-Type\" : \"application/json\"\n            }\n          } ]\n        }\n      }\n    },\n    \"scripts\" : {\n      \"enabled\" : false,\n      \"transformersRefs\" : [ ],\n      \"transformersConfig\" : { },\n      \"validatorRefs\" : [ ],\n      \"validatorConfig\" : { },\n      \"preRouteRefs\" : [ ],\n      \"preRouteConfig\" : { },\n      \"sinkRefs\" : [ ],\n      \"sinkConfig\" : { },\n      \"jobRefs\" : [ ],\n      \"jobConfig\" : { }\n    },\n    \"geolocationSettings\" : {\n      \"type\" : \"none\"\n    },\n    \"userAgentSettings\" : {\n      \"enabled\" : false\n    },\n    \"autoCert\" : {\n      \"enabled\" : false,\n      \"replyNicely\" : false,\n      \"caRef\" : null,\n      \"allowed\" : [ ],\n      \"notAllowed\" : [ ]\n    },\n    \"tlsSettings\" : {\n      \"defaultDomain\" : null,\n      \"randomIfNotFound\" : false,\n      \"includeJdkCaServer\" : true,\n      \"includeJdkCaClient\" : true,\n      \"trustedCAsServer\" : [ ]\n    },\n    \"plugins\" : {\n      \"enabled\" : false,\n      \"refs\" : [ ],\n      \"config\" : { },\n      \"excluded\" : [ ]\n    },\n    \"metadata\" : { }\n  },\n  \"admins\" : [ ],\n  \"simpleAdmins\" : [ {\n    \"_loc\" : {\n      \"tenant\" : \"default\",\n      \"teams\" : [ \"default\" ]\n    },\n    \"username\" : \"admin@otoroshi.io\",\n    \"password\" : \"$2a$10$iQRkqjKTW.5XH8ugQrnMDeUstx4KqmIeQ58dHHdW2Dv1FkyyAs4C.\",\n    \"label\" : \"Otoroshi Admin\",\n    \"createdAt\" : 1634651307724,\n    \"type\" : \"SIMPLE\",\n    \"metadata\" : { },\n    \"tags\" : [ ],\n    \"rights\" : [ {\n      \"tenant\" : \"*:rw\",\n      \"teams\" : [ \"*:rw\" ]\n    } ]\n  } ],\n  \"serviceGroups\" : [ {\n    \"_loc\" : {\n      \"tenant\" : \"default\",\n      \"teams\" : [ \"default\" ]\n    },\n    \"id\" : \"admin-api-group\",\n    \"name\" : \"Otoroshi Admin Api group\",\n    \"description\" : \"No description\",\n    \"tags\" : [ ],\n    \"metadata\" : { }\n  }, {\n    \"_loc\" : {\n      \"tenant\" : \"default\",\n      \"teams\" : [ \"default\" ]\n    },\n    \"id\" : \"default\",\n    \"name\" : \"default-group\",\n    \"description\" : \"The default service group\",\n    \"tags\" : [ ],\n    \"metadata\" : { }\n  } ],\n  \"apiKeys\" : [ {\n    \"_loc\" : {\n      \"tenant\" : \"default\",\n      \"teams\" : [ \"default\" ]\n    },\n    \"clientId\" : \"admin-api-apikey-id\",\n    \"clientSecret\" : \"admin-api-apikey-secret\",\n    \"clientName\" : \"Otoroshi Backoffice ApiKey\",\n    \"description\" : \"The apikey use by the Otoroshi UI\",\n    \"authorizedGroup\" : \"admin-api-group\",\n    \"authorizedEntities\" : [ \"group_admin-api-group\" ],\n    \"enabled\" : true,\n    \"readOnly\" : false,\n    \"allowClientIdOnly\" : false,\n    \"throttlingQuota\" : 10000,\n    \"dailyQuota\" : 10000000,\n    \"monthlyQuota\" : 10000000,\n    \"constrainedServicesOnly\" : false,\n    \"restrictions\" : {\n      \"enabled\" : false,\n      \"allowLast\" : true,\n      \"allowed\" : [ ],\n      \"forbidden\" : [ ],\n      \"notFound\" : [ ]\n    },\n    \"rotation\" : {\n      \"enabled\" : false,\n      \"rotationEvery\" : 744,\n      \"gracePeriod\" : 168,\n      \"nextSecret\" : null\n    },\n    \"validUntil\" : null,\n    \"tags\" : [ ],\n    \"metadata\" : { }\n  } ],\n  \"serviceDescriptors\" : [ {\n    \"_loc\" : {\n      \"tenant\" : \"default\",\n      \"teams\" : [ \"default\" ]\n    },\n    \"id\" : \"admin-api-service\",\n    \"groupId\" : \"admin-api-group\",\n    \"groups\" : [ \"admin-api-group\" ],\n    \"name\" : \"otoroshi-admin-api\",\n    \"description\" : \"\",\n    \"env\" : \"prod\",\n    \"domain\" : \"oto.tools\",\n    \"subdomain\" : \"otoroshi-api\",\n    \"targetsLoadBalancing\" : {\n      \"type\" : \"RoundRobin\"\n    },\n    \"targets\" : [ {\n      \"host\" : \"127.0.0.1:9999\",\n      \"scheme\" : \"http\",\n      \"weight\" : 1,\n      \"mtlsConfig\" : {\n        \"certs\" : [ ],\n        \"trustedCerts\" : [ ],\n        \"mtls\" : false,\n        \"loose\" : false,\n        \"trustAll\" : false\n      },\n      \"tags\" : [ ],\n      \"metadata\" : { },\n      \"protocol\" : \"HTTP/1.1\",\n      \"predicate\" : {\n        \"type\" : \"AlwaysMatch\"\n      },\n      \"ipAddress\" : null\n    } ],\n    \"root\" : \"/\",\n    \"matchingRoot\" : null,\n    \"stripPath\" : true,\n    \"localHost\" : \"127.0.0.1:9999\",\n    \"localScheme\" : \"http\",\n    \"redirectToLocal\" : false,\n    \"enabled\" : true,\n    \"userFacing\" : false,\n    \"privateApp\" : false,\n    \"forceHttps\" : false,\n    \"logAnalyticsOnServer\" : false,\n    \"useAkkaHttpClient\" : true,\n    \"useNewWSClient\" : false,\n    \"tcpUdpTunneling\" : false,\n    \"detectApiKeySooner\" : false,\n    \"maintenanceMode\" : false,\n    \"buildMode\" : false,\n    \"strictlyPrivate\" : false,\n    \"enforceSecureCommunication\" : true,\n    \"sendInfoToken\" : true,\n    \"sendStateChallenge\" : true,\n    \"sendOtoroshiHeadersBack\" : true,\n    \"readOnly\" : false,\n    \"xForwardedHeaders\" : false,\n    \"overrideHost\" : true,\n    \"allowHttp10\" : true,\n    \"letsEncrypt\" : false,\n    \"secComHeaders\" : {\n      \"claimRequestName\" : null,\n      \"stateRequestName\" : null,\n      \"stateResponseName\" : null\n    },\n    \"secComTtl\" : 30000,\n    \"secComVersion\" : 1,\n    \"secComInfoTokenVersion\" : \"Legacy\",\n    \"secComExcludedPatterns\" : [ ],\n    \"securityExcludedPatterns\" : [ ],\n    \"publicPatterns\" : [ \"/health\", \"/metrics\" ],\n    \"privatePatterns\" : [ ],\n    \"additionalHeaders\" : {\n      \"Host\" : \"otoroshi-admin-internal-api.oto.tools\"\n    },\n    \"additionalHeadersOut\" : { },\n    \"missingOnlyHeadersIn\" : { },\n    \"missingOnlyHeadersOut\" : { },\n    \"removeHeadersIn\" : [ ],\n    \"removeHeadersOut\" : [ ],\n    \"headersVerification\" : { },\n    \"matchingHeaders\" : { },\n    \"ipFiltering\" : {\n      \"whitelist\" : [ ],\n      \"blacklist\" : [ ]\n    },\n    \"api\" : {\n      \"exposeApi\" : false\n    },\n    \"healthCheck\" : {\n      \"enabled\" : false,\n      \"url\" : \"/\"\n    },\n    \"clientConfig\" : {\n      \"useCircuitBreaker\" : true,\n      \"retries\" : 1,\n      \"maxErrors\" : 20,\n      \"retryInitialDelay\" : 50,\n      \"backoffFactor\" : 2,\n      \"callTimeout\" : 30000,\n      \"callAndStreamTimeout\" : 120000,\n      \"connectionTimeout\" : 10000,\n      \"idleTimeout\" : 60000,\n      \"globalTimeout\" : 30000,\n      \"sampleInterval\" : 2000,\n      \"proxy\" : { },\n      \"customTimeouts\" : [ ],\n      \"cacheConnectionSettings\" : {\n        \"enabled\" : false,\n        \"queueSize\" : 2048\n      }\n    },\n    \"canary\" : {\n      \"enabled\" : false,\n      \"traffic\" : 0.2,\n      \"targets\" : [ ],\n      \"root\" : \"/\"\n    },\n    \"gzip\" : {\n      \"enabled\" : false,\n      \"excludedPatterns\" : [ ],\n      \"whiteList\" : [ \"text/*\", \"application/javascript\", \"application/json\" ],\n      \"blackList\" : [ ],\n      \"bufferSize\" : 8192,\n      \"chunkedThreshold\" : 102400,\n      \"compressionLevel\" : 5\n    },\n    \"metadata\" : { },\n    \"tags\" : [ ],\n    \"chaosConfig\" : {\n      \"enabled\" : false,\n      \"largeRequestFaultConfig\" : null,\n      \"largeResponseFaultConfig\" : null,\n      \"latencyInjectionFaultConfig\" : null,\n      \"badResponsesFaultConfig\" : null\n    },\n    \"jwtVerifier\" : {\n      \"type\" : \"ref\",\n      \"ids\" : [ ],\n      \"id\" : null,\n      \"enabled\" : false,\n      \"excludedPatterns\" : [ ]\n    },\n    \"secComSettings\" : {\n      \"type\" : \"HSAlgoSettings\",\n      \"size\" : 512,\n      \"secret\" : \"${config.app.claim.sharedKey}\",\n      \"base64\" : false\n    },\n    \"secComUseSameAlgo\" : true,\n    \"secComAlgoChallengeOtoToBack\" : {\n      \"type\" : \"HSAlgoSettings\",\n      \"size\" : 512,\n      \"secret\" : \"secret\",\n      \"base64\" : false\n    },\n    \"secComAlgoChallengeBackToOto\" : {\n      \"type\" : \"HSAlgoSettings\",\n      \"size\" : 512,\n      \"secret\" : \"secret\",\n      \"base64\" : false\n    },\n    \"secComAlgoInfoToken\" : {\n      \"type\" : \"HSAlgoSettings\",\n      \"size\" : 512,\n      \"secret\" : \"secret\",\n      \"base64\" : false\n    },\n    \"cors\" : {\n      \"enabled\" : false,\n      \"allowOrigin\" : \"*\",\n      \"exposeHeaders\" : [ ],\n      \"allowHeaders\" : [ ],\n      \"allowMethods\" : [ ],\n      \"excludedPatterns\" : [ ],\n      \"maxAge\" : null,\n      \"allowCredentials\" : true\n    },\n    \"redirection\" : {\n      \"enabled\" : false,\n      \"code\" : 303,\n      \"to\" : \"https://www.otoroshi.io\"\n    },\n    \"authConfigRef\" : null,\n    \"clientValidatorRef\" : null,\n    \"transformerRef\" : null,\n    \"transformerRefs\" : [ ],\n    \"transformerConfig\" : { },\n    \"apiKeyConstraints\" : {\n      \"basicAuth\" : {\n        \"enabled\" : true,\n        \"headerName\" : null,\n        \"queryName\" : null\n      },\n      \"customHeadersAuth\" : {\n        \"enabled\" : true,\n        \"clientIdHeaderName\" : null,\n        \"clientSecretHeaderName\" : null\n      },\n      \"clientIdAuth\" : {\n        \"enabled\" : true,\n        \"headerName\" : null,\n        \"queryName\" : null\n      },\n      \"jwtAuth\" : {\n        \"enabled\" : true,\n        \"secretSigned\" : true,\n        \"keyPairSigned\" : true,\n        \"includeRequestAttributes\" : false,\n        \"maxJwtLifespanSecs\" : null,\n        \"headerName\" : null,\n        \"queryName\" : null,\n        \"cookieName\" : null\n      },\n      \"routing\" : {\n        \"noneTagIn\" : [ ],\n        \"oneTagIn\" : [ ],\n        \"allTagsIn\" : [ ],\n        \"noneMetaIn\" : { },\n        \"oneMetaIn\" : { },\n        \"allMetaIn\" : { },\n        \"noneMetaKeysIn\" : [ ],\n        \"oneMetaKeyIn\" : [ ],\n        \"allMetaKeysIn\" : [ ]\n      }\n    },\n    \"restrictions\" : {\n      \"enabled\" : false,\n      \"allowLast\" : true,\n      \"allowed\" : [ ],\n      \"forbidden\" : [ ],\n      \"notFound\" : [ ]\n    },\n    \"accessValidator\" : {\n      \"enabled\" : false,\n      \"refs\" : [ ],\n      \"config\" : { },\n      \"excludedPatterns\" : [ ]\n    },\n    \"preRouting\" : {\n      \"enabled\" : false,\n      \"refs\" : [ ],\n      \"config\" : { },\n      \"excludedPatterns\" : [ ]\n    },\n    \"plugins\" : {\n      \"enabled\" : false,\n      \"refs\" : [ ],\n      \"config\" : { },\n      \"excluded\" : [ ]\n    },\n    \"hosts\" : [ \"otoroshi-api.oto.tools\" ],\n    \"paths\" : [ ],\n    \"handleLegacyDomain\" : true,\n    \"issueCert\" : false,\n    \"issueCertCA\" : null\n  } ],\n  \"errorTemplates\" : [ ],\n  \"jwtVerifiers\" : [ ],\n  \"authConfigs\" : [ ],\n  \"certificates\" : [],\n  \"clientValidators\" : [ ],\n  \"scripts\" : [ ],\n  \"tcpServices\" : [ ],\n  \"dataExporters\" : [ ],\n  \"tenants\" : [ {\n    \"id\" : \"default\",\n    \"name\" : \"Default organization\",\n    \"description\" : \"The default organization\",\n    \"metadata\" : { },\n    \"tags\" : [ ]\n  } ],\n  \"teams\" : [ {\n    \"id\" : \"default\",\n    \"tenant\" : \"default\",\n    \"name\" : \"Default Team\",\n    \"description\" : \"The default Team of the default organization\",\n    \"metadata\" : { },\n    \"tags\" : [ ]\n  } ]\n}' \\\nhttp://otoroshi-api.oto.tools:9999/api/otoroshi.json \\\n-u admin-api-apikey-id:admin-api-apikey-secret \n```\n\nThis should output :\n\n```json\n{ \"done\":true }\n```\n\n> Note : be very carefully with this POST command. If you send a wrong JSON, you risked to break your instance.\n\nThe second way is to send the same configuration but from a file. You can pass two kind of file : a `json` file or a `ndjson` file. Both files are available as export methods on the danger zone.\n\n```sh\n# the curl is run from a folder containing the initial-state.json file \ncurl -X POST \\\n-H \"X-Content-Type: application/json\" \\\n-d @./initial-state.json http://otoroshi-api.oto.tools:9999/api/otoroshi.json \\\n-u admin-api-apikey-id:admin-api-apikey-secret\n```\n\nThis should output :\n\n```json\n{ \"done\":true }\n```\n\n> Note: To send a ndjson file, you have to set the X-Content-Type header at `application/x-ndjson`"},{"name":"index.md","id":"/how-to-s/index.md","url":"/how-to-s/index.html","title":"","content":"\n# How to's\n\nin this section, we will explain some mainstream Otoroshi usage scenario's \n\n* @ref:[End-to-end mTLS](./end-to-end-mtls.md)\n* @ref:[Send alerts by emails](./export-alerts-using-mailgun.md)\n* @ref:[Export events to Elasticsearch](./export-events-to-elastic.md)\n* @ref:[Import/export Otoroshi datastore](./import-export-otoroshi-datastore.md)\n* @ref:[Secure an app with Auth0](./secure-app-with-auth0.md)\n* @ref:[Secure an app with Keycloak](./secure-app-with-keycloak.md)\n* @ref:[Secure an app with LDAP](./secure-app-with-ldap.md)\n* @ref:[Secure an api with apikeys](./secure-with-apikey.md)\n* @ref:[Secure an app with OAuth1](./secure-with-oauth1-client.md)\n* @ref:[Secure an api with OAuth2 client_credentials flow](./secure-with-oauth2-client-credentials.md)\n* @ref:[Setup an Otoroshi cluster](./setup-otoroshi-cluster.md)\n* @ref:[TLS termination using Let's Encrypt](./tls-using-lets-encrypt.md)\n* @ref:[Secure an app with jwt verifiers](./secure-an-app-with-jwt-verifiers.md)\n* @ref:[Secure the communication between a downstream app and Otoroshi](./secure-the-communication-between-a-downstream-app-and-otoroshi.md)\n\n@@@ index\n\n* [End-to-end mTLS](./end-to-end-mtls.md)\n* [Send alerts by emails](./export-alerts-using-mailgun.md)\n* [Export events to Elasticsearch](./export-events-to-elastic.md)\n* [Import/export Otoroshi datastore](./import-export-otoroshi-datastore.md)\n* [Secure an app with Auth0](./secure-app-with-auth0.md)\n* [Secure an app with Keycloak](./secure-app-with-keycloak.md)\n* [Secure an app with LDAP](./secure-app-with-ldap.md)\n* [Secure an api with apikeys](./secure-with-apikey.md)\n* [Secure an app with OAuth1](./secure-with-oauth1-client.md)\n* [Secure an api with OAuth2 client_credentials flow](./secure-with-oauth2-client-credentials.md)\n* [Setup an Otoroshi cluster](./setup-otoroshi-cluster.md)\n* [TLS termination using Let's Encrypt](./tls-using-lets-encrypt.md)\n* [Secure an app with jwt verifiers](./secure-an-app-with-jwt-verifiers.md)\n* [Secure the communication between a downstream app and Otoroshi](./secure-the-communication-between-a-downstream-app-and-otoroshi.md)\n\n@@@"},{"name":"secure-an-app-with-jwt-verifiers.md","id":"/how-to-s/secure-an-app-with-jwt-verifiers.md","url":"/how-to-s/secure-an-app-with-jwt-verifiers.html","title":"Secure an api with jwt verifiers","content":"# Secure an api with jwt verifiers\n\nA Jwt verifier is the guard which check the signature of tokens present in incoming requests on a service. It can be a simple verifier, a tokens generator, or extend to be a verifier and a tokens generator.\n\n### Cover by this tutorial\n\n- [Before you start](#before-you-start)\n- [Your first jwt verifier : a verifier of tokens](#your-first-jwt-verifier--a-verifier-of-tokens)\n- [Verify ang generate a new token](#verify-and-generate-a-new-token)\n\n@@@ warning\nTODO - schema\n@@@\n\n### Download Otoroshi\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n\n### Your first jwt verifier : a verifier of tokens\n\nLet's start by navigate the page of verifier creation (*http://otoroshi.oto.tools:9999/bo/dashboard/jwt-verifiers/add*). By default, the type of jwt verifier is a *Verify JWT token*.\n\nCreate the following verifier : \n* Set `simple-jwt-verifier` as `Name`\n* Set `My simple jwt verifier` as `Description`\n* We expect in entry a token in a specific header. Set `Authorization` as `Header name`\n* Select `Hmac + SHA` as `Algo` (for this example, we expect tokens with a symetric signature)\n* Set `otoroshi` as `Hmac secret`\n* Remove the default field in `Verify token fields` array\n* Create your verifier when clicking on `Create and stay on this Jwt verifier` button.\n\nOnce created, navigate to the simple service (created in [Before you start](#Before you start) section) and jump to the `JWT tokens verification` section.\n\nIn the verifiers list, choose the `simple-jwt-verifier` and `enabled` the section.\n\nSave your service and try to call the service.\n```sh\ncurl -X GET http://myservice.oto.tools:9999/ --include\n```\n\nThis should output : \n```json\n{\n    \"Otoroshi-Error\": \"error.expected.token.not.found\"\n}\n```\n\nA simple way to generate a token is to use *http://jwt.io*. Set `HS512` as `alg` in header section, and insert `otoroshi` as verify signature secret. Once created, paste the token on the Authorization header and call our service.\n\n```sh\n# replace xxxx by the generated token\ncurl -X GET \\\n-H \"Authorization: xxxx\" \\\nhttp://myservice.oto.tools:9999\n```\n\nThis should output a json with `authorization` in headers field. His value is exactly the same as the passed token.\n\n```json\n{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"headers\": {\n    \"host\": \"mirror.otoroshi.io\",\n    \"authorization\": \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.ipDFgkww51mSaSg_199BMRj4gK20LGz_czozu3u8rCFFO1X20MwcabSqEzUc0q4qQ4rjTxjoR4HeUDVcw8BxoQ\",\n    ...\n  }\n}\n```\n\n### Verify and generate a new token\n\nAn other feature is to verify the entry token and generate a new token, with a different signature and news claims. \n\nLet's start by extending the previous verifier (*http://otoroshi.oto.tools:9999/bo/dashboard/jwt-verifiers*).\n\n1. Jump to the `Verif Strategy` field and select `Verify and re-sign JWT token`. \n\n2. Edit the name with `jwt-verify-and-resign`\n3. Remove the default field in `Verify token fields` array\n4. Change the second `Hmac secret` in `Re-sign settings` section with `otoroshi-internal-secret`\n5. Save your verifier.\n\n> Note : the verifier name has changed and not the id. So you can just save your verifier without needs to change the verifier used in your service.  \n\n```sh\n# replace xxxx by the generated token\ncurl -X GET \\\n-H \"Authorization: xxxx\" \\\nhttp://myservice.oto.tools:9999\n```\n\nThis should output a json with `authorization` in headers field. This time, the value are different and you can check his signature on *jwt.io* (the expected secret of the generated token is *otoroshi-internal-secret*)\n\n<img src=\"../imgs/secure-an-app-with-jwt-verifiers-jwtio.png\" height=\"300px\">\n\n### Verify, transform and generate a new token\n\nThe most advanced verifier is able to do the same as the previous ones, with the ability to configure the toke generation (claims, output header name).\n\nLet's start by extending the previous verifier (*http://otoroshi.oto.tools:9999/bo/dashboard/jwt-verifiers*).\n\n1. Jump to the `Verif Strategy` field and select `Verify, transform and re-sign JWT token`. \n\n2. Edit the name with `jwt-verify-transform-and-resign`\n3. Remove the default field in `Verify token fields` array\n4. Change the second `Hmac secret` in `Re-sign settings` section with `otoroshi-internal-secret`\n5. Set `Internal-Authorization` as `Header name`\n6. Set `key` on first field of `Rename token fields` and `from-otoroshi-verifier` on second field\n7. Set `generated-key` and `generated-value` as `Set token fields`\n<<<<<<< HEAD\n8. Add `generated_at` and `${date}` a second field in `Set token fields` (some Otoroshi inputs supports an @ref[expression language](../topics/expression-language.md))\n=======\n8. Add `generated_at` and `${date}` a second field in `Set token fields` (some Otoroshi inputs supports an @ref:[expression language](../topics/expression-language.md))\n>>>>>>> master\n9. Save your verifier and try to call your service again.\n\nThis should output a json with `authorization` in headers field and our generate token in `Internal-Authorization`.\nOnce paste in jwt.io, you should have :\n\n<img src=\"../imgs/secure-an-app-with-jwt-verifiers-transform-jwtio.png\">\n\n"},{"name":"secure-app-with-auth0.md","id":"/how-to-s/secure-app-with-auth0.md","url":"/how-to-s/secure-app-with-auth0.html","title":"Secure an app with Auth0","content":"# Secure an app with Auth0\n\n### Cover by this tutorial\n- [Before you start](#before-you-start)\n- [Configure an Auth0 client](#configure-an-auth0-client)\n- [Create an Auth0 provider module](#create-an-auth0-provider-module)\n- [Connect to Otoroshi with Auth0 authentication](#connect-to-otoroshi-with-keycloak-authentication)\n- [Testing your configuration](#testing-your-configuration)\n- [Secure an app with Auth0 authentication](#secure-an-app-with-keycloak-authentication)\n\n@@@ warning\nTODO - schema\n@@@\n\n### Download Otoroshi\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n\n### Configure an Auth0 client\n\nThe first step of this tutorial is to setup an Auth0 application with the information of the instance of our Otoroshi.\n\nNavigate to *https://manage.auth0.com/* (create an account if it's not already done). \n\nLet's create an application when clicking on the `Applications` button on the sidebar. Then click on the `Create application` button on the right top.\n\n1. Choose `Regular Web Applications` as `Application type`\n2. Then set for example `otoroshi-client` as `Name`, and confirm the creation\n3. Jump to the `Settings` tab\n4. Scroll to the `Application URLs` section and add the following url as `Allowed Callback URLs` : `http://otoroshi.oto.tools:9999/backoffice/auth0/callback`\n5. Set `https://otoroshi.oto.tools:9999/` as `Allowed Logout URLs`\n6. Set `https://otoroshi.oto.tools:9999` as `Allowed Web Origins` \n7. Save changes at the bottom of the page.\n\nOnce done, we have a full setup, with a client ID and secret at the top of the page, which authorize our Otoroshi and redirect the user to the callback url when it will connect to Auth0.\n\n### Create an Auth0 provider module\n\nLet's back to Otoroshi to create an authentication module with `OAuth2 / OIDC provider` as `type`.\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `OAuth provider` in the type selector field\n3. Then click on `Get from OIDC config` and paste *https://<tenant-name>.<region>.auth0.com/.well-known/openid-configuration*. Replace the tenant name by the name of your tenant (displayed on the left top of auth0 page), and the region of the tenant (`eu` in my case).\n\nOnce done, set the `Client ID` and the `Client secret` from your auth0 application. End the configuration with `http://otoroshi.oto.tools:9999/backoffice/auth0/callback` as `Callback URL`.\n\nAt the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs).\n\n### Connect to Otoroshi with Auth0 authentication\n\nTo secure Otoroshi with your Auth0 configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n2. Scroll to the *BackOffice auth. settings*\n3. Select your last Authentication configuration (created in the previous section)\n4. Save the global configuration with the button on the top right\n\n#### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to *http://otoroshi.oto.tools:9999*)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the auth0 server login page\n4. Set your account credentials\n5. Good works! You're connected to Otoroshi with an Auth0 module.\n\n### Secure an app with Auth0 authentication\n\nWith the previous configuration, you can secure any of Otoroshi services with it. \n\nThe first step is to apply a little change on the previous configuration. \n\n1. Navigate to *http://otoroshi.oto.tools:9999/bo/dashboard/auth-configs*.\n2. Create a new auth module configuration with the same values.\n3. Replace the `Callback URL` field to `http://privateapps.oto.tools:9999/privateapps/generic/callback` (we changed this value because the redirection of a logged user by a third-party server is cover by an other route by Otoroshi).\n4. Disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n> Note : a Otoroshi service is call a private app when it is protected by an authentication module.\n\nWe can set the authentication module on the service.\n\n1. Navigate to any created service\n2. Scroll to `Authentication` section\n3. Enable `Enforce user authentication`\n4. Select your Authentication config inside the list\n5. Enable `Strict mode`\n6. Don't forget to save your configuration.\n7. Now you can try to call your defined service and see the Auth0 login page appears.\n\n\n"},{"name":"secure-app-with-keycloak.md","id":"/how-to-s/secure-app-with-keycloak.md","url":"/how-to-s/secure-app-with-keycloak.html","title":"Secure an app with Keycloak","content":"# Secure an app with Keycloak\n\n### Cover by this tutorial\n- [Before you start](#before-you-start)\n- [Running a keycloak instance with docker](#running-a-keycloak-instance-with-docker)\n- [Create a Keycloak provider module](#create-a-keycloak-provider-module)\n- [Connect to Otoroshi with Keycloak authentication](#connect-to-otoroshi-with-keycloak-authentication)\n- [Testing your configuration](#testing-your-configuration)\n- [Secure an app with Keycloak authentication](#secure-an-app-with-keycloak-authentication)\n\n@@@ warning\nTODO - schema\n@@@\n\n<<<<<<< HEAD\n### Before you start\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\n=======\n### Download Otoroshi\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\n>>>>>>> master\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n<<<<<<< HEAD\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n=======\n\n### Requisites\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref:[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n>>>>>>> master\n\n### Running a keycloak instance with docker\n\n```sh\ndocker run \\\n-p 8080:8080 \\\n-e KEYCLOAK_USER=admin \\\n-e KEYCLOAK_PASSWORD=admin \\\n--name keycloak-server \\\n--detach jboss/keycloak:15.0.1\n```\n\nThis should download the image of keycloak (if you haven't already it) and display the digest of the created container. This command mapped TCP port 8080 in the container to port 8080 of your laptop and created a server with `admin/admin` as admin credentials.\n\nOnce started, you can open a browser on `http://localhost:8080/` and click on `Administration Console`. Log to your instance with `admin/admin` as credentials.\n\nThe first step is to create a Keycloak client, an entity that can request Keycloak to authenticate a user. Click on the `clients` button on the sidebar, and then on `Create` button at the right top of the view.\n\nFill the client form with the following values.\n\n| Fields            | Value                             |\n| ----------------- | --------------------------------- |\n| `Client ID`       | `keycloak-otoroshi-backoffice`    |\n| `Client Protocol` | `openid-connect`                  |\n| `Root URL`        | `http://otoroshi.oto.tools:9999/` |\n\nEnd by create the client with the `Save` button.\n\nThe next step is to change the `Access Type` used by default. Jump to the `Access Type` field and select `confidential`. The confidential configuration force the client application to send at Keycloak a client ID and a client Secret. Scroll to the bottom of the page and save the configuration.\n\nNow scroll to the top of your page. Just at the right of the `Settings`\u001b tab, a new tab appeared : the `Credentials` page. Click on this tab, and make sure that `Client Id and Secret` is selected as `Client Authenticator` and copy the generated `Secret` to the next part.\n\n### Create a Keycloak provider module\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `OAuth2 / OIDC provider` in the type selector field\n3. Set a basic name and description\n\nA simple way to import a Keycloak client is to give the `URL of the OpenID Connect` Otoroshi. By default, keycloak used the next URL : `http://localhost:8080/auth/realms/master/.well-known/openid-configuration`. \n\nClick on the `Get from OIDC config` button and paste the previous link. Once it's done, scroll to the `URLs` section. All URLs has been fill with the values picked from the JSON object returns by the previous URL.\n\nThe only fields to change are : \n\n| Fields | Value |\n|---|---|\n| `Client ID` |`keycloak-otoroshi-backoffice` |\n| `Client Secret` | Paste the Secret from the Credentials Keycloak page. In my case, it's something like `90c9bf0b-2c0c-4eb0-aa02-72195beb9da7` |\n| `Callback URL`  | `http://otoroshi.oto.tools:9999/backoffice/auth0/callback`|\n\nAt the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs). Nothing else to change, just save the configuration.\n\n### Connect to Otoroshi with Keycloak authentication\n\nTo secure Otoroshi with your Keycloak configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n1. Scroll to the *BackOffice auth. settings*\n1. Select your last Authentication configuration (created in the previous section)\n1. Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to *http://otoroshi.oto.tools:9999*)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the keycloak login page\n4. Set `admin/admin` as user and trust the user by clicking on `yes` button.\n5. Good work! You're connected to Otoroshi with an Keycloak module.\n\n> A fallback solution is always available, by going to *http://otoroshi.oto.tools:9999/bo/simple/login*, for administrators in case your Authentication module is not well configured or not available\n\n### Visualize an admin user session or a private user session\n\nEach user, wheter connected user to the Otoroshi UI or at a private Otoroshi app, has an own session. As an administrator of Otoroshi, you can visualize via Otoroshi the list of the connected users and their profile.\n\nLet's start by navigate to the `Admin users sessions` page (just @link:[here](http://otoroshi.oto.tools:9999/bo/dashboard/sessions/admin) or when clicking on the cog, and on the `Admins sessions` button at the bottom of the list).\n\nThis page gives a complete view of the connected admins. For each admin, you have his connection date and his expiration date. You can also check the `Profile` and the `Rights` of the connected users.\n\nIf we check the profile and the rights of the previously logged user (from Keycloak in the previous part) we can retrieve the following information :\n```json\n{\n  \"sub\": \"4c8cd101-ca28-4611-80b9-efa504ac51fd\",\n  \"upn\": \"admin\",\n  \"email_verified\": false,\n  \"address\": {},\n  \"groups\": [\n    \"create-realm\",\n    \"default-roles-master\",\n    \"offline_access\",\n    \"admin\",\n    \"uma_authorization\"\n  ],\n  \"preferred_username\": \"admin\"\n}\n```\nand his default rights \n```sh\n[\n  {\n    \"tenant\": \"default:rw\",\n    \"teams\": [\n      \"default:rw\"\n    ]\n  }\n]\n```\n\nWe haven't create any specific groups in Keycloak or specify rights in Otoroshi for him. In this case, the use received the default Otoroshi rights at his connection. We can see that he can navigate on the default Organization and Teams (which are two resources created by Otoroshi at the boot) and that he have the full access (`r`: Read, `w`: Write, `*`: read/write) on its.\n\nIn the same way, you'll find all users connected to a private Otoroshi app when navigate on the @link:[`Private App View`](http://otoroshi.oto.tools:9999/bo/dashboard/sessions/private) or using the cog at the top of the page. \n\n### Configure the Keycloak module to force logged in users to be an Otoroshi admin with full access\n\nGo back to the Keycloak module in `Authentication configs` view. Turn on the `Supers admin only` button and save your configuration. Try again the connection to Otoroshi using Keycloak third-party server.\n\nOnce connected, click on the cog button, and check that you have access to the full features of Otoroshi (like Admin user sessions). Now, your rights should be : \n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\"\n    ]\n  }\n]\n```\n\n### Merge Id token content on user profile\n\nGo back to the Keycloak module in `Authentication confgis` view. Turn on the `Read profile` from token button and save your configuration. Try again the connection to Otoroshi using Keycloak third-party server.\n\nOnce connected, your profile should be contains all Keycloak id token : \n```json\n{\n    \"exp\": 1634286674,\n    \"iat\": 1634286614,\n    \"auth_time\": 1634286614,\n    \"jti\": \"eb368578-e886-4caa-a51b-c1d04973c80e\",\n    \"iss\": \"http://localhost:8080/auth/realms/master\",\n    \"aud\": [\n        \"master-realm\",\n        \"account\"\n    ],\n    \"sub\": \"4c8cd101-ca28-4611-80b9-efa504ac51fd\",\n    \"typ\": \"Bearer\",\n    \"azp\": \"keycloak-otoroshi-backoffice\",\n    \"session_state\": \"e44fe471-aa3b-477d-b792-4f7b4caea220\",\n    \"acr\": \"1\",\n    \"allowed-origins\": [\n        \"http://otoroshi.oto.tools:9999\"\n    ],\n    \"realm_access\": {\n        \"roles\": [\n        \"create-realm\",\n        \"default-roles-master\",\n        \"offline_access\",\n        \"admin\",\n        \"uma_authorization\"\n        ]\n    },\n    \"resource_access\": {\n        \"master-realm\": {\n        \"roles\": [\n            \"view-identity-providers\",\n            \"view-realm\",\n            \"manage-identity-providers\",\n            \"impersonation\",\n            \"create-client\",\n            \"manage-users\",\n            \"query-realms\",\n            \"view-authorization\",\n            \"query-clients\",\n            \"query-users\",\n            \"manage-events\",\n            \"manage-realm\",\n            \"view-events\",\n            \"view-users\",\n            \"view-clients\",\n            \"manage-authorization\",\n            \"manage-clients\",\n            \"query-groups\"\n        ]\n        },\n        \"account\": {\n        \"roles\": [\n            \"manage-account\",\n            \"manage-account-links\",\n            \"view-profile\"\n        ]\n        }\n    }\n    ...\n}\n```\n\n### Manage the Otoroshi user rights from keycloak\n\nOne powerful feature supports by Otoroshi, is to use the Keycloak groups attributes to set a list of rights for a Otoroshi user.\n\nIn the Keycloak module, you have a field, named `Otoroshi rights field name` with `otoroshi_rights` as default value. This field is used by Otoroshi to retrieve information from the Id token groups.\n\nLet's create a group in Keycloak, and set our default Admin user inside.\nIn Keycloak admin console :\n1. Navigate to the groups view, using the keycloak sidebar\n2. Create a new group with `my-group` as `Name`\n3. Then, on the `Attributes` tab, create an attribute with `otoroshi_rights` as `Key` and the following json array as `Value`\n```json\n[\n    {\n        \"tenant\": \"*:rw\",\n        \"teams\": [\n            \"*:rw\",\n            \"my-future-team:rw\"\n        ]\n    }\n]\n```\n\nWith this configuration, the user have a full access on all Otoroshi resources (my-future-team is not created in Otoroshi but it's not a problem, Otoroshi can handle it and use this rights only when the teams will be present)\n\nClick on the `Add` button and save the group. The last step is to assign our user to this group. Jump to `Users` view using the sidebar, click on `View all users`, edit the user and his group membership using the `Groups` tab (use `join` button the assign user in `my-group`).\n\nThe next step is to add a mapper in the Keycloak client. By default, Keycloak doesn't expose any users information (like group membership or users attribute). We need to ask to Keycloak to expose the user attribute `otoroshi_rights` set previously on group.\n\nNavigate to the `Keycloak-otoroshi-backoffice` client, and jump to `Mappers` tab. Create a new mapper with the following values: \n\n| Fields | Value |\n|---|---|\n| `Name`                        |`otoroshi_rights`|\n| `Mapper Type`                 |`User Attribute`|\n| `User Attribute`              |`otoroshi_rights`|\n| `Token Claim Name`            |`otoroshi_rights`|\n| `Claim JSON Type`             |`JSON`|\n|`Multivalued`                 |``|\n| `Aggregate attribute values`  |``|\n\nGo back to the Authentication Keycloak module inside Otoroshi UI, and turn off `Super admins only`. Save the configuration.\n\nOnce done, try again the connection to Otoroshi using Keycloak third-party server.\nNow, your rights should be : \n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\",\n      \"my-future-team:rw\"\n    ]\n  }\n]\n```\n\n### Secure an app with Keycloak authentication\n\nThe only change to apply on the previous authentication module, is on the callback URL. When you want secure a Otoroshi service, and transform it on `Private App`, you need to set the `Callback URL` at `http://privateapps.oto.tools:9999/privateapps/generic/callback`\n\n1 Go back to the authentication module\n1. Jump to the `Callback URL` field\n2. Paste this value `http://privateapps.oto.tools:9999/privateapps/generic/callback`\n3. Save your configuration\n4. Navigate to `http://myservice.oto.tools:9999`.\n5. You should redirect to the keycloak login page.\n6. Once logged in, you can check the content of the private app session created.\nThe rights should be : \n```json\n[\n  {\n    \"tenant\": \"*:rw\",\n    \"teams\": [\n      \"*:rw\",\n      \"my-future-team:rw\"\n    ]\n  }\n]\n```"},{"name":"secure-app-with-ldap.md","id":"/how-to-s/secure-app-with-ldap.md","url":"/how-to-s/secure-app-with-ldap.html","title":"Secure an app and/or your Otoroshi UI with LDAP","content":"# Secure an app and/or your Otoroshi UI with LDAP\n\n### Cover by this tutorial\n\n- [Secure an app and/or your Otoroshi UI with LDAP](#secure-an-app-andor-your-otoroshi-ui-with-ldap)\n- [Cover by this tutorial](#cover-by-this-tutorial)\n- [Download Otoroshi](#download-otoroshi)\n- [Create an Authentication configuration](#create-an-authentication-configuration)\n- [Connect to Otoroshi with LDAP authentication](#connect-to-otoroshi-with-ldap-authentication)\n- [Testing your configuration](#testing-your-configuration)\n- [Secure an app with LDAP authentication](#secure-an-app-with-ldap-authentication)\n- [Manage LDAP users rights on Otoroshi](#manage-ldap-users-rights-on-otoroshi)\n- [Advanced usage of LDAP Authentication](#advanced-usage-of-ldap-authentication)\n\n@@@ warning\nTODO - schema\n@@@\n\n### Download Otoroshi\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n\n#### Running an simple OpenLDAP server \n\nRun OpenLDAP docker image : \n```sh\ndocker run \\\n-p 389:389 \\\n-p 636:636  \\\n--env LDAP_ORGANISATION=\"Otoroshi company\" \\\n--env LDAP_DOMAIN=\"otoroshi.tools\" \\\n--env LDAP_ADMIN_PASSWORD=\"otoroshi\" \\\n--env LDAP_READONLY_USER=\"false\" \\\n--env LDAP_TLS\"false\" \\\n--env LDAP_TLS_ENFORCE\"false\" \\\n--name my-openldap-container \\\n--detach osixia/openldap:1.5.0\n```\n\nLet's make the first search in our LDAP container :\n```sh\ndocker exec my-openldap-container ldapsearch -x -H ldap://localhost -b dc=otoroshi,dc=tools -D \"cn=admin,dc=otoroshi,dc=tools\" -w otoroshi\n```\n\nThis should output :\n```sh\n# extended LDIF\n ...\n# otoroshi.tools\ndn: dc=otoroshi,dc=tools\nobjectClass: top\nobjectClass: dcObject\nobjectClass: organization\no: Otoroshi company\ndc: otoroshi\n\n# search result\nsearch: 2\nresult: 0 Success\n...\n```\n\nNow you can seed the open LDAP server with a few users. \n\nJoin your LDAP container.\n```sh\ndocker exec -it my-openldap-container \"/bin/bash\"\n```\n\nThe command `ldapadd` needs of a file to run.\n\nLaunch this command to create a `bootstrap.ldif` with one organization, one singers group with Johnny user and a last group with Einstein as scientist.\n```sh\necho -e \"\ndn: ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: organizationalUnit\nou: People\n\ndn: ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: organizationalUnit\nou: Role\n\ndn: uid=johnny,ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: johnny\ncn: Jhonny\nsn: Brown\nmail: johnny@otoroshi.tools\npostalCode: 88442\nuserPassword: password\n\ndn: uid=einstein,ou=People,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: einstein\ncn: Einstein\nsn: Wilson\nmail: einstein@otoroshi.tools\npostalCode: 88443\nuserPassword: password\n\ndn: cn=singers,ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: groupOfNames\ncn: singers\nmember: uid=johnny,ou=People,dc=otoroshi,dc=tools\n\ndn: cn=scientists,ou=Role,dc=otoroshi,dc=tools\nobjectclass: top\nobjectclass: groupOfNames\ncn: scientists\nmember: uid=einstein,ou=People,dc=otoroshi,dc=tools\n\" > bootstrap.ldif\n\nldapadd -x -w otoroshi -D \"cn=admin,dc=otoroshi,dc=tools\" -f bootstrap.ldif -v\n```\n\n### Create an Authentication configuration\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n1. Select the `Ldap auth. provider` in the type selector field\n1. Set a basic name and description\n1. Then set `ldap://localhost:389` as `LDAP Server URL`and `dc=otoroshi,dc=tools` as `Search Base`\n1. Create a group filter (in the next part, we'll change this filter to spread users in different groups with given rights) with \n\nobjectClass=groupOfNames as *Group filter* \\\nAll as *Tenant*\\\nAll as *Team*\\\nRead/Write as *Rights*\n\n9. Set the search filter as (uid=${username})`\n1. Set `cn=admin,dc=otoroshi,dc=tools` as *Admin username*\n1. Set `otoroshi` as *Admin password*\n2. At the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n\n At this point, your configuration should be similar to :\n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_09975547-a186-4a2d-a550-ca71a0a03c0c\n - wait 1000\n - screenshot-area generated-hows-to-ldap-auth-configs.png #app>div>div.container-fluid>div>div.col-sm-10.col-sm-offset-2.main\n-->\n<img src=\"../imgs/generated-hows-to-ldap-auth-configs.png\" />\n\n> Dont' forget to save on the bottom page your configuration before to quit the page.\n\n12. Test the connection when clicking on `Test admin connection` button\n\nThis should display a `It works!` message\n\n13. Finally, test the user connection button and set `johnny/password` or `einstein/password` as credentials.\n\nThis should display a `It works!` message\n\n> Dont' forget to save on the bottom page your configuration before to quit the page.\n\n### Connect to Otoroshi with LDAP authentication\n\nTo secure Otoroshi with your LDAP configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n1. Scroll to the *BackOffice auth. settings*\n1. Select your last Authentication configuration (created in the previous section)\n1. Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to *http://otoroshi.oto.tools:9999/backoffice/auth0/login*)\n1. Set `johnny/password` or `einstein/password` as credentials\n\n> A fallback solution is always available, by going to *http://otoroshi.oto.tools:9999/bo/simple/login*, for administrators in case your LDAP is not available\n\n\n#### Secure an app with LDAP authentication\n\nOnce the configuration is done, you can secure any of Otoroshi services with it. \n\n1. Navigate to any created service\n2. Jump to the `URL Patterns` section\n3. Enable your service as `Public UI`\n4. Then scroll to `Authentication` section\n5. Enable `Enforce user authentication`\n6. Select your Authentication config inside the list\n7. Enable `Strict mode`\n6. Don't forget to save your configuration\n\n<!-- oto-scenario\n - goto /bo/dashboard/lines/prod/services/service_mirror_otoroshi_fr\n - wait 2000\n - click div[data-screenshot=\"ldap-tutorial-authentication\"]>div:nth-child(2)>div\n - screenshot-area generated-hows-to-secure-an-app-with-ldap.png div[data-screenshot=\"ldap-tutorial-authentication\"]\n-->\n<img src=\"../imgs/generated-hows-to-secure-an-app-with-ldap.png\">\n\nNow you can try to call your defined service and see the login module appears.\n\n#### Manage LDAP users rights on Otoroshi\n\nFor each LDAP groups, you can affect a list of rights : \n\n- on an `Organization` : only resources of an organization\n- on a `Team` : only resources belonging to this team\n- and a level of rights : `Read`, `Write` or `Read/Write`\n\n\nStart by navigate to your authentication configuration (created in @ref:[previous](#create-an-authentication-configuration) step).\n\nThen, replace the values of the `Mapping group filter` field to match LDAP groups with Otoroshi rights.\n\n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_91bb8b38-620e-4c18-9bbc-7c8d1efd63cc\n - wait 1000\n - screenshot-area generated-hows-to-ldap-manage-users.png #app>div>div.container-fluid>div>div.col-sm-10.col-sm-offset-2.main>div>div> div.row>div>div>div>form>div>div:nth-child(3)>div:nth-child(11)\n-->\n<img src=\"../imgs/generated-hows-to-ldap-manage-users.png\" />\n\nWith this configuration, Einstein is an administrator of Otoroshi with full rights (read / write) on all organizations.\n\nConversely, Johnny can't see any configuration pages (like the danger zone) because he has only the read rights on Otoroshi.\n\nYou can easily test this behaviour by @ref:[testing](#testing-your-configuration) with both credentials.\n\n\n#### Advanced usage of LDAP Authentication\n\nIn the previous section, we have set rights for each LDAP groups. But in some case, we want to have a finer granularity like set rights for a specific user.\n\nThe last 4 fields of the authentication form cover this. \n\nEach field take the `Email field name` as keys, and a json value.\n\nLet's start by adding few properties for each connected users with `Extra metadata`.\n\n```json\n// Add this configuration in extra metadata part\n{\n  \"provider\": \"OpenLDAP\"\n}\n```\n\nThe next field `Data override` is merged with extra metadata when a user connects to a `private app` (Inside Otoroshi, private app is a service secure by any authentication module) or to the UI. The `Email field name` is configured to match with the `mail` field from LDAP user data.\n\n```json \n{\n  \"johnny@otoroshi.tools\": {\n    \"stage_name\": \"Jean-Philippe Smet\"\n  }\n}\n```\n\nIf you try to connect to an app with this configuration, the user result profile should be :\n```json\n{\n  ...,\n  \"metadata\": {\n    \"lastname\": \"Hallyday\",\n    \"stage_name\": \"Jean-Philippe Smet\"\n  }\n}\n```\n\nLet's try to increase the Johnny rights with the `Additional rights group`.\n\nThis field supports the creation of virtual groups. A virtual group is composed of a list of users and a list of rights for each teams/organizations.\n\n```json\n// increase_johnny_rights is a virtual group which adds full access rights at johnny \n{\n  \"increase_johnny_rights\": {\n    \"rights\": [\n      {\n        \"tenant\": \"*:rw\",\n        \"teams\": [\n          \"*:rw\"\n        ]\n      }\n    ],\n    \"users\": [\n      \"jhonny@otoroshi.tools\"\n    ]\n  }\n}\n```\n\nThe last field `Rights override` is useful when you want erase the rights of an user with only specific rights.\n\nThe rights override field is the last to be applied on the user rights. \n\nTo resume, when Johnny connects to Otoroshi, he receives the rights to read only on the default Organization (from `Mapping group filter`), then he is promote to administrator role (from `Additional rights group`) and finally his rights are reset with the last field `Rights override` to the read rights.\n\n```json \n{\n  \"jhonny@otoroshi.tools\": [\n    {\n      \"tenant\": \"*:r\",\n      \"teams\": [\n        \"*:r\"\n      ]\n    }\n  ]\n}\n```\n\n\n\n\n\n\n\n\n"},{"name":"secure-the-communication-between-a-downstream-app-and-otoroshi.md","id":"/how-to-s/secure-the-communication-between-a-downstream-app-and-otoroshi.md","url":"/how-to-s/secure-the-communication-between-a-downstream-app-and-otoroshi.html","title":"Secure the communication between a downstream app and Otoroshi","content":"# Secure the communication between a downstream app and Otoroshi\n\n### Cover by this tutorial\n- [Otoroshi exchange protocol](#otoroshi-exchange-protocol)\n- [Pratical case](#pratical-case)\n\n### Otoroshi exchange protocol\n\nThe exchange protocol secure the communication with an app. When it's enabled, Otoroshi will send for each request a value in pre-selected token header, and will check the same header in the return request.\n\n#### V1 challenge\n\nIf you enable secure communication for a given service with `V1 - simple values exchange` activated, you will have to add a filter on the target application that will take the `Otoroshi-State` header and return it in a header named `Otoroshi-State-Resp`. \n\n@@@ div { .centered-img }\n<img src=\"../imgs/exchange.png\" />\n@@@\n\n#### V2 challenge\n\nIf you enable secure communication for a given service with `V2 - signed JWT token exhange` activated, you will have to add a filter on the target application that will take the `Otoroshi-State` header value containing a JWT token, verify it's content signature then extract a claim named `state` and return a new JWT token in a header named `Otoroshi-State-Resp` with the `state` value in a claim named `state-resp`. By default, the signature algorithm is HMAC+SHA512 but can you can choose your own. The sent and returned JWT tokens have short TTL to avoid being replayed. You must be validate the tokens TTL. The audience of the response token must be `Otoroshi` and you have to specify `iat`, `nbf` and `exp`.\n\n@@@ div { .centered-img }\n<img src=\"../imgs/exchange-2.png\" />\n@@@\n\n### Pratical case\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\n1. Navigate to http://otoroshi.oto.tools:9999/bo/services and create a new service\n2. Jump to `Service exposition settings` and add *http://myservice.oto.tools* as `Exposed domain`\n3. Jump to `Service targets` and add *http://localhost:8080/* as `Target 1`\n4. Jump to the `URL Patterns` section\n5. Enable your service as `Public UI`\n\nWe need of a simple service which handle the exchange protocol. For this tutorial, we'll use the following application, developed in NodeJS, which supports both versions of the exchange protocol.\n\nClone this @link:[repository](https://github.com/MAIF/otoroshi/blob/master/demos/challenge)) and run the installation of the dependencies.\n\n```sh\ngit clone https://github.com/MAIF/otoroshi/blob/master/demos/challenge\ncd challenge\nyarn install # or npm install\nnode server.js\n```\n\nThe last command should return : \n\n```sh\nchallenge-verifier listening on http://0.0.0.0:8080\n```\n\nThis project runs an express client with one middleware. The middleware handles each request, and check if the header `State token header` is present in headers. By default, the incoming expected header is `Otoroshi-State` by the application and `Otoroshi-State-Resp` header in the headers of the return request. \n\nTry to call your service via *http://myservice.oto.tools:9999/*. This should return a successful response with all headers received by the downstream app. \n\nNow try to disable the middleware in the nodejs file. \n\n```js\n// comment this line \napp.use(OtoroshiMiddleware());\n```\n\nTry to call again your service. This time, Otoroshi breaks the return response from your downstream service, and returns.\n\n```sh\nDownstream microservice does not seems to be secured. Cancelling request !\n```"},{"name":"secure-with-apikey.md","id":"/how-to-s/secure-with-apikey.md","url":"/how-to-s/secure-with-apikey.html","title":"Secure an api with api keys","content":"# Secure an api with api keys\n\n### Cover by this tutorial\n- [Before you start](#before-you-start)\n- [About the downstream example service](#about-the-downstream-example-service)\n- [Create a simple service](#create-a-simple-service)\n- [Secure routes with api key](#secure-an-api-with-apikey)\n- [Generate an api key to request secure services](#generate-an-api-key-to-request-secure-services)\n- [Override defaults headers names for a service](#override-defaults-headers-names-for-a-service)\n- [Accept only api keys with expected values](#accept-only-api-keys-with-expected-values)\n\n@@@ warning\nTODO - schema\n@@@\n\n### Before you start\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n```\n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\n### About the downstream example service\n\nIn these tutorials, we will create a simple service which route to *https://mirror.otoroshi.io/*\n\nThis downstream service is a very good entry point to test the functionality of Otoroshi services, as it will return the content of all requests received (included headers, body, etc.).\n\n### Create a simple service \n\n1. Navigate to http://otoroshi.oto.tools:9999/bo/dashboard/lines/prod/services/service_596bb0d1-9eb5-40fe-b521-9d138fe9ec85\n2. Jump to `Service exposition settings` and add *http://myservice.oto.tools* as `Exposed domain`\n3. Jump to `Service targets` and add *https://mirror.otoroshi.io/* as `Target 1`\n4. Jump to the `URL Patterns` section\n5. Enable your service as `Public UI`\n6. Open a new tab and navigate to *http://myservice.oto.tools:9999/*\n\nWith this configuration, all routes are public, wihtout any authentication needed.\n\n### Secure routes with api key\n\nWith the previous configuration, all routes are public. \n\nIn our case, we want to secure all routes prefix with `/api`.\n\nLet's return to the `URL Patterns` section. Click on `Make service a private api`. This button automatically add `/api` as default in `Private patterns` array. (Note that the field supports regex like. In our case, `/api.*` covers all routes starting by */api*).\n\nSave your app and navigate to *http://myservice.oto.tools:9999/api/test* again. If the service is configured, you should have a `Service Not found error`, and a success call, in the case you navigate to any other routes which are not starting by `/api/*` like *http://myservice.oto.tools:9999/test/bar*\n\nThis expected error on the `/api/test`, throws by the URL Patterns, indicate to the client that an api key is required to access to the downstream service.\n\n### Generate an api key to request secure services\n\nNavigate to *http://otoroshi.oto.tools:9999/bo/dashboard/apikeys/add* or when clicking on the `Add apikey` button on the sidebar.\n\nThe only required fields of an Otoroshi api key are : \n* `ApiKey id`\n* `ApiKey Secret`\n* `ApiKey Name`\n\nThese fields are automatically generated by Otoroshi. However, you can override these values and indicate an additional description.\n\nTo simplify the rest of the tutorial, set the values:\n* `my-first-api-key-id` as `ApiKey Id`\n* `my-first-api-key-secret` as `ApiKey Secret`\n\n\nClick on `Create and stay on this ApiKey` button at the bottom of the page.\n\nNow you created the key, it's time to call our previous generated service with it.\n\nOtoroshi supports two methods to achieve that. \nOnce by passing Otoroshi api key in two headers : *Otoroshi-Client-Id* and *Otoroshi-Client-Secret* (these headers names can be override on each service).\nAnd the second by passing Otoroshi api key in the authentication Header (basically the *Authorization* header) as a basic encoded value.\n\nLet's ahead and call our service :\n```sh\ncurl -X GET \\\n-H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\nhttp://myservice.oto.tools:9999/api/test --include\n```\nAnd with the second method :\n\n```sh\ncurl -X GET \\\n-H 'Authorization: Basic bXktZmlyc3QtYXBpLWtleS1pZDpteS1maXJzdC1hcGkta2V5LXNlY3JldA==' \\\nhttp://myservice.oto.tools:9999/api/test --include\n```\n\n> Tips : To easily fill your headers, you can jump to the `Call examples` section in each api key view. In this section the header names are the default values and the service url is not set. You have to adapt these lines to your case. \n\n### Override defaults headers names for a service\n\nIn some case, we want to change the defaults headers names (and it's a quite good idea).\n\nLet's start by navigate to the `Api keys Constraints` section from the edit page of our sercice.\n\nThe first values to change are the headers names used to read the api key from client. Start by set :\n* `api-key-header-id` as `Custom client id header name`\n* `api-key-header-secret` as `Custom client secret header name`\n\nSave the service, and call the service again.\n\n```sh\ncurl -X GET \\\n-H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\nhttp://myservice.oto.tools:9999/api/test --include\n```\n\nThis should output an error because Otoroshi are expecting the api keys in other headers.\n\n```json\n{\n  \"Otoroshi-Error\": \"No ApiKey provided\"\n}\n```\n\nCall one again the service but with the changed headers names.\n\n```sh\ncurl -X GET \\\n-H 'api-key-header-id: my-first-api-key-id' \\\n-H 'api-key-header-secret: my-first-api-key-secret' \\\nhttp://myservice.oto.tools:9999/api/test --include\n```\n\nWith this configuration, all others default services will accept the api keys with the `Otoroshi-Client-Id` and `Otoroshi-Client-Secret` headers, while our service, will accept the `api-key-header-id` and `api-key-header-secret` headers.\n\n### Accept only api keys with expected values\n\nBy default, a secure service only accepts requests with api key. But all generated api keys are eligible to call our service and in some case, we want authorize only a couple of api keys.\n\nOne feature of Otoroshi is to restrict the list of accepted api keys by giving a list of `metadatas` or/and `tags`. Each api key has a list of `tags` and `metadatas`, which can be used by Otoroshi to forward or not a call with an api key. All api key metadatas/tags can be forward to your service (see `Otoroshi exchange protocol` section of a service to get more information about *Send info. token*).\n\nLet's starting by accept only the api keys which come with the tag of `otoroshi` as value.\n\nJump to the last part of the `Api Keys Constraints` section, call `Routing constraints` (these constraints are used to route a call to a service, only if all constraint are validated).\n\nIn our first case, set `otoroshi` in `One Tag in` array and save the service.\nThen call our service with :\n```sh\ncurl -X GET \\\n-H 'Otoroshi-Client-Id: my-first-api-key-id' \\\n-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \\\nhttp://myservice.oto.tools:9999/api/test --include\n```\n\nThis should output :\n```json\n// Error reason : Our api key doesn't contains the expected tag.\n{\n  \"Otoroshi-Error\": \"Bad API key\"\n}\n```\n\nNavigate to the edit page of our api key, and jump to the `Metadata and tags` section.\nIn this section, add `otoroshi` in `Tags` array, then save the api key. Call once again your call and you will normally get a successful response of our downstream service.\n\nIn this example, we have restricted our service to be callable only with keys that have `otoroshi` as a tag.\n\nBut Otoroshi provides others behaviours. For each behaviour, *Api key used should*:\n* `All Tags in` : have all of the following tags\n* `No Tags in` : not have one of the following tags\n* `One Tag in` : have at least one of the following tags\n---\n* `All Meta. in` : have all of the following metadata entries\n* `No Meta. in` : not have one of the following metadata entries\n* `One Meta. in` : have at least one of the following metadata entries\n----\n* `One Meta key in` : have at least one of the following key in metadata\n* `All Meta key in` : have all of the following keys in metadata\n* `No Meta key in` : not have one of the following keys in metadata"},{"name":"secure-with-oauth1-client.md","id":"/how-to-s/secure-with-oauth1-client.md","url":"/how-to-s/secure-with-oauth1-client.html","title":"Secure an app with OAuth1 client flow","content":"# Secure an app with OAuth1 client flow\n\n### Cover by this tutorial\n- [Before you start](#before-you-start)\n- [Running an simple OAuth 1 server](#running-an-simple-oauth-1-server)\n- [Create an OAuth 1 provider module](#create-an-oauth-1-provider-module)\n- [Connect to Otoroshi with OAuth1 authentication](#connect-to-otoroshi-with-oauth1-authentication)\n- [Testing your configuration](#testing-your-configuration)\n- [Secure an app with OAuth 1 authentication](#secure-an-app-with-oauth-1-authentication)\n\n@@@ warning\nTODO - schema\n@@@\n\n### Download Otoroshi\n\nLet's start by downloading the latest Otoroshi\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\n```\n\nBy default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`\n\nRun Otoroshi\n```sh\njava -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar \n\nLog to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`\n\nThen create a simple service (@ref[instructions are available here](./secure-with-apikey.md#about-the-downstream-example-service))\n\n### Running an simple OAuth 1 server\n\nIn this tutorial, we'll instanciate a oauth 1 server with docker. If you alredy have the necessary, skip this section @ref:[to](#create-an-oauth-1-provider-module).\n\nLet's start by running the server\n```sh\ndocker run -d --name oauth1-server --rm \\\n    -p 5000:5000 \\\n    -e OAUTH1_CLIENT_ID=2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET \\\n    -e OAUTH1_CLIENT_SECRET=wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp \\\n    -e OAUTH1_REDIRECT_URI=http://otoroshi.oto.tools:9999/backoffice/auth0/callback \\\n    ghcr.io/beryju/oauth1-test-server\n```\n\nWe created a oauth 1 server which accepts `http://otoroshi.oto.tools:9999/backoffice/auth0/callback` as `Redirect URI`. This URL is used by Otoroshi to retrieve a token and a profile at the end of an authentication process.\n\nAfter this command, the container logs should output :\n```sh \n127.0.0.1 - - [14/Oct/2021 12:10:49] \"HEAD /api/health HTTP/1.1\" 200 -\n```\n\n### Create an OAuth 1 provider module\n\n1. Go ahead, and navigate to http://otoroshi.oto.tools:9999\n1. Click on the cog icon on the top right\n1. Then `Authentication configs` button\n1. And add a new configuration when clicking on the `Add item` button\n2. Select the `Oauth1 provider` in the type selector field\n3. Set a basic name and description like `oauth1-provider`\n4. Set `2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET` as `Consumer key`\n5. Set `wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp` as `Consumer secret`\n6. Set `http://localhost:5000/oauth/request_token` as `Request Token URL`\n7. Set `http://localhost:5000/oauth/authorize` as `Authorize URL`\n8. Set `http://localhost:oauth/access_token` as `Access token URL`\n9. Set `http://localhost:5000/api/me` as `Profile URL`\n10. Set `http://otoroshi.oto.tools:9999/backoffice/auth0/callback` as `Callback URL`\n11. At the bottom of the page, disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n At this point, your configuration should be similar to :\n<!-- oto-scenario\n - goto /bo/dashboard/auth-configs/edit/auth_mod_oauth1.0_provider\n - wait 1000\n - screenshot generated-hows-to-secure-with-oauth1-provider.png\n-->\n<img src=\"../imgs/generated-hows-to-secure-with-oauth1-provider.png\" />\n\nWith this configuration, the connected user will receive default access on teams and organizations. If you want to change the access rights for a specific user, you can achieve it with the `Rights override` field and a configuration like :\n```json\n{\n  \"foo@example.com\": [\n    {\n      \"tenant\": \"*:rw\",\n      \"teams\": [\n        \"*:rw\"\n      ]\n    }\n  ]\n}\n```\n\nSave your configuration at the bottom of the page, then navigate to the `danger zone` to use your module as a third-party connection to the Otoroshi UI.\n\n### Connect to Otoroshi with OAuth1 authentication\n\nTo secure Otoroshi with your OAuth1 configuration, we have to register an Authentication configuration as a BackOffice Auth. configuration.\n\n1. Navigate to the *danger zone* (when clicking on the cog on the top right and selecting Danger zone)\n1. Scroll to the *BackOffice auth. settings*\n1. Select your last Authentication configuration (created in the previous section)\n1. Save the global configuration with the button on the top right\n\n### Testing your configuration\n\n1. Disconnect from your instance\n1. Then click on the *Login using third-party* button (or navigate to *http://otoroshi.oto.tools:9999*)\n2. Click on `Login using Third-party` button\n3. If all is configured, Otoroshi will redirect you to the oauth 1 server login page\n4. Set `example-user` as user and trust the user by clicking on `yes` button.\n5. Good work! You're connected to Otoroshi with an OAuth1 module.\n\n> A fallback solution is always available, by going to *http://otoroshi.oto.tools:9999/bo/simple/login*, for administrators in case your Authentication module is not available\n\n### Secure an app with OAuth 1 authentication\n\nWith the previous configuration, you can secure any of Otoroshi services with it. \n\nThe first step is to apply a little change on the previous configuration. \n\n1. Navigate to *http://otoroshi.oto.tools:9999/bo/dashboard/auth-configs*.\n2. Create a new auth module configuration with the same values.\n3. Replace the `Callback URL` field to `http://privateapps.oto.tools:9999/privateapps/generic/callback` (we changed this value because the redirection of a logged user by a third-party server is cover by an other route by Otoroshi).\n4. Disable the `secure` button (because we're using http and this configuration avoid to include cookie in an HTTP Request without secure channel, typically HTTPs)\n\n> Note : a Otoroshi service is call a private app when it is protected by an authentication module.\n\nOur example server supports only one redirect URI. We need to kill it, and to create a new container with `http://otoroshi.oto.tools:9999/privateapps/generic/callback` as `OAUTH1_REDIRECT_URI`\n```sh\ndocker rm -f oauth1-server\ndocker run -d --name oauth1-server --rm \\\n    -p 5000:5000 \\\n    -e OAUTH1_CLIENT_ID=2NVVBip7I5kfl0TwVmGzTphhC98kmXScpZaoz7ET \\\n    -e OAUTH1_CLIENT_SECRET=wXzb8tGqXNbBQ5juA0ZKuFAmSW7RwOw8uSbdE3MvbrI8wjcbGp \\\n    -e OAUTH1_REDIRECT_URI=http://privateapps.oto.tools:9999/privateapps/generic/callback \\\n    ghcr.io/beryju/oauth1-test-server\n```\n\nOnce the authentication module and the new container created, we can set the authentication module on the service.\n\n1. Navigate to any created service\n2. Scroll to `Authentication` section\n3. Enable `Enforce user authentication`\n4. Select your Authentication config inside the list\n5. Enable `Strict mode`\n6.  Don't forget to save your configuration.\n\nNow you can try to call your defined service and see the login module appears.\n\n> <img src=\"../imgs/hows-to-secure-app-with-oauth1-provider-input.png\">\n\nThe allow access to the user.\n\n> <img src=\"../imgs/hows-to-secure-app-with-oauth1-provider-trust.png\">\n\nIf you had any errors, make sure of :\n* check if you are on http or https, and if the *secure cookie option* is enabled or not on the authentication module\n* check if your oauth1 server has the REDIRECT_URI set on *privateapps/...*\n* Make sure your server supports POST or GET oauth1 flow set on authentication module\n\nOnce the configuration is working, you can check, when connecting with an Otoroshi admin user, the `Private App session` created (use the cog at the right top of the page, and select `Priv. app sesssions`, or navigate to *http://otoroshi.oto.tools:9999/bo/dashboard/sessions/private*).\n\nOne interesing feature is to check the profile of the connected user. In our case, when clicking on the `Profile` button of the right user, we should have : \n```json\n{\n  \"email\": \"foo@example.com\",\n  \"id\": 1,\n  \"name\": \"test name\",\n  \"screen_name\": \"example-user\"\n}\n```"},{"name":"secure-with-oauth2-client-credentials.md","id":"/how-to-s/secure-with-oauth2-client-credentials.md","url":"/how-to-s/secure-with-oauth2-client-credentials.html","title":"Secure an app with OAuth2 client_credential flow","content":"# Secure an app with OAuth2 client_credential flow\n\nOtoroshi makes it easy for your app to implement the Client Credentials Flow. Following successful authentication, the calling application will have access to an Access Token, which can be used to call your protected APIs.\n\n## Deployed the Client Credential Service\n\nThe Client Credential Service must be enabled as a global plugin on your instance. To achieve that, navigate to your otoroshi instance (in our case `http://otoroshi.oto.tools:9999`) on the danger zone (use the cog on the right top of the page).\n\nTo enable a plugin in global on Otoroshi, you must add it in the `Global Plugins` section.\n\nOpen the `Global Plugin` section, `enabled` it (if it not already done), and search the plugin named `Client Credential Service` of type `Sink`.\n\nTo show and add the default configuration on this plugin, click on the `show config. panel` an on the `Inject default config.` button. This button is available on each plugin and it's useful when you want to inject the default configuration.\n\nWhen you click on the `show config. panel`, you have the documentation of the plugin and its default configuration.\n\nThe client credential plugin has by default 4 parameters : \n| Field | Description | Default value |\n| ------------- | ----------------------- | --- |\n| `domain` | a regex used to exposed routes on each matching domain | * |\n| `expiration` | duration until the token expire (in ms) |3600000 |\n| `defaultKeyPair` | a key pair used to sign the jwt token. By default, Otoroshi is deployed with an otoroshi-jwt-signing that you can visualize on the jwt verifiers certificates | otoroshi-jwt-signing |\n| `secure` | if enabled, Otoroshi will expose routes only in the https requests case  |true |\n\nIn this tutorial, we will set the configuration as following : \n| Field | Value | \n| ------------- | ----------------------- |\n| `domain` | *.oto.tools |\n| `expiration` | 3600000 |\n| `defaultKeyPair` | otoroshi-jwt-signing |\n| `secure` | false |\n\nNow that the plugin is running, third routes are exposed on each matching domain of the regex.\n\n* [GET] - `/.well-known/otoroshi/oauth/jwks.json` : retrieve all public keys presents in Otoroshi\n* [POST] - `/.well-known/otoroshi/oauth/token/introspect` : validate and decode the token \n* [POST] - `/.well-known/otoroshi/oauth/token` : generate a token with the fields provided\n\nOnce the global configuration saved, we can deployed a simple service to test it.\n\nLet's navigate to the services page, and create a new service with : \n1. `http://foo.oto.tools:9999` as `Exposed domain` in `Service exposition settings` section\n2. `https://mirror.otoroshi.io` as `Target 1` in `Service targets` section\n3. `/.*` as `Private patterns` in `URL Patterns` section (and remove all public patterns)\n\nIn `Api Keys Constraints`, disabled `From basic auth.`, `Allow client id only usage` and `From custom headers` button then saved the service.\n\nLet's make a first call, to check if the jwks are already exposed :\n\n```sh\ncurl http://foo.oto.tools:9999/.well-known/otoroshi/oauth/jwks.json\n```\n\nThis should output a list of public keys : \n```sh\n{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"e\": \"AQAB\",\n      \"kid\": \"otoroshi-intermediate-ca\",\n      ...\n    }\n    ...\n  ]\n}\n``` \n\nLet's make a call on a route of this service. \n\n```sh\ncurl http://foo.oto.tools:9999/\n```\n\nThis should output the expected error: \n```json\n{\n  \"Otoroshi-Error\": \"No ApiKey provided\"\n}\n```\n\nThe first step is to generate an api key. Navigate to the api keys page, and create an item with the following values (it will be more easy to use them in the next step) :\n* `my-id` as `ApiKey Id`\n* `my-secret` as `ApiKey Secret`\n\nThe next step is to ask a token by calling the exposed route `/.well-known/otoroshi/oauth/jwks.json`. The required fields are the grand type, the client and the client secret corresponding to our generated api key.\n\n```sh\ncurl -X POST http://foo.oto.tools:9999/.well-known/otoroshi/oauth/token\\\n-H \"Content-Type: application/json\" \\\n-d '{\"grant_type\":\"client_credentials\", \"client_id\":\"my-id\", \"client_secret\":\"my-secret\"}'\n```\n\nWe have omit a parameter of the body which is named `scope`. This field can be used to set a bunch of scope on the generated access token.\n\nThe last command should output : \n```sh\n{\n  \"access_token\": \"generated-token-xxxxx\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600\n}\n```\n\nOnce generate, we can call our api again : \n```sh\ncurl http://foo.oto.tools:9999/ \\\n-H \"Authorization: Bearer generated-token-xxxxx\"\n```\n\nThis should output a list of headers with a field named `Authorization` containing the previous access token.\n\n\n## Other possible configuration\n\nBy default, Otoroshi generate the access token with the specified key pair in the configuration. But, in some case, you want a specific key pair by client_id/client_secret.\nYou can achieve it when setting a `jwt-sign-keypair` metadata on your desired api key with the id of the key pair as value. \n"},{"name":"setup-otoroshi-cluster.md","id":"/how-to-s/setup-otoroshi-cluster.md","url":"/how-to-s/setup-otoroshi-cluster.html","title":"Setup an Otoroshi cluster","content":"# Setup an Otoroshi cluster\n\n@@@ warning\nTODO\n@@@"},{"name":"tls-using-lets-encrypt.md","id":"/how-to-s/tls-using-lets-encrypt.md","url":"/how-to-s/tls-using-lets-encrypt.html","title":"TLS termination using Let's Encrypt","content":"# TLS termination using Let's Encrypt"},{"name":"index.md","id":"/index.md","url":"/index.html","title":"Otoroshi","content":"# Otoroshi\n\n**Otoroshi** is a layer of lightweight api management on top of a modern http reverse proxy written in <a href=\"https://www.scala-lang.org/\" target=\"_blank\">Scala</a> and developped by the <a href=\"https://maif.github.io\" target=\"_blank\">MAIF OSS</a> team that can handle all the calls to and between your microservices without service locator and let you change configuration dynamicaly at runtime.\n\n\n> *The <a href=\"https://en.wikipedia.org/wiki/Gazu_Hyakki_Yagy%C5%8D#/media/File:SekienOtoroshi.jpg\" target=\"blank\">Otoroshi</a> is a large hairy monster that tends to lurk on the top of the torii gate in front of Shinto shrines. It's a hostile creature, but also said to be the guardian of the shrine and is said to leap down from the top of the gate to devour those who approach the shrine for only self-serving purposes.*\n\n@@@ div { .centered-img }\n[![build](https://github.com/MAIF/otoroshi/actions/workflows/server_build_and_test.yaml/badge.svg)](https://github.com/MAIF/otoroshi/actions/workflows/server_build_and_test.yaml) [![Join the chat at https://gitter.im/MAIF/otoroshi](https://badges.gitter.im/MAIF/otoroshi.svg)](https://gitter.im/MAIF/otoroshi?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [ ![Download](https://img.shields.io/github/release/MAIF/otoroshi.svg) ](hhttps://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar)\n@@@\n\n@@@ div { .centered-img }\n<img src=\"https://github.com/MAIF/otoroshi/raw/master/resources/otoroshi-logo.png\" width=\"300\"></img>\n@@@\n\n## Installation\n\nYou can download the latest build of Otoroshi as a [fat jar](https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar), as a [zip package](https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi-dist.zip) or as a [docker image](#).\n\nYou can install and run Otoroshi with this little bash snippet\n\n```sh\ncurl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'\njava -jar otoroshi.jar\n```\n\nor using docker\n\n```sh\ndocker run -p \"8080:8080\" maif/otoroshi:1.5.0-dev\n```\n\nnow open your browser to <a href=\"http://otoroshi.oto.tools:8080/\" target=\"_blank\">http://otoroshi.oto.tools:8080/</a>, **log in with the credential generated in the logs** and explore by yourself, if you want better instructions, just go to the [Quick Start](#) or directly to the [installation instructions](#)\n\n## Documentation\n\n* @ref:[About Otoroshi](./about.md)\n* @ref:[Architecture](./architecture.md)\n* @ref:[Features](./features.md)\n* @ref:[Getting started](./getting-started.md)\n* @ref:[Install Otoroshi](./install/index.md)\n* @ref:[Main entities](./entities/index.md)\n* @ref:[Detailed topics](./topics/index.md)\n* @ref:[How to's](./how-to-s/index.md)\n* @ref:[Plugins](./plugins/index.md)\n* @ref:[Admin REST API](./api.md)\n* @ref:[Deploy to production](./deploy/index.md)\n* @ref:[Developing Otoroshi](./dev.md)\n\n## Discussion\n\nJoin the [Otoroshi](https://gitter.im/MAIF/otoroshi) channel on the [MAIF Gitter](https://gitter.im/MAIF)\n\n## Sources\n\nThe sources of Otoroshi are available on [Github](https://github.com/MAIF/otoroshi).\n\n## Logo\n\nYou can find the official Otoroshi logo [on GitHub](https://github.com/MAIF/otoroshi/blob/master/resources/otoroshi-logo.png). The Otoroshi logo has been created by Franois Galioto ([@fgalioto](https://twitter.com/fgalioto))\n\n## Changelog\n\nEvery release, along with the migration instructions, is documented on the [Github Releases](https://github.com/MAIF/otoroshi/releases) page. A condensed version of the changelog is available on [github]((https://github.com/MAIF/otoroshi/CHANGELOG.md)\n\n## Patrons\n\nThe work on Otoroshi was funded by <a href=\"https://www.maif.fr/\" target=\"_blank\">MAIF</a> with the help of the community.\n\n## Licence\n\nOtoroshi is Open Source and available under the [Apache 2 License](https://opensource.org/licenses/Apache-2.0) \n\n@@@ index\n\n* [About Otoroshi](./about.md)\n* [Architecture](./architecture.md)\n* [Features](./features.md)\n* [Getting started](./getting-started.md)\n* [Install Otoroshi](./install/index.md)\n* [Main entities](./entities/index.md)\n* [Detailed topics](./topics/index.md)\n* [How to's](./how-to-s/index.md)\n* [Plugins](./plugins/index.md)\n* [Admin REST API](./api.md)\n* [Deploy to production](./deploy/index.md)\n* [Developing Otoroshi](./dev.md)\n\n@@@\n\n\n@@@ div { .centered-img }\n<!-- oto-scenario\n - goto /bo/dashboard\n - wait 1000\n - screenshot generated-index-md-home.png\n-->\n<img src=\"../imgs/generated-index-md-home.png\" />\n@@@\n"},{"name":"get-otoroshi.md","id":"/install/get-otoroshi.md","url":"/install/get-otoroshi.html","title":"Get Otoroshi","content":"# Get Otoroshi\n\n## From zip\n\n## From jar file\n\n## From Docker\n\n## From Sources\n\n@@@ warning\nTODO\n@@@"},{"name":"index.md","id":"/install/index.md","url":"/install/index.html","title":"Install","content":"# Install\n\nIn this sections, you will find informations about how to install and run Otoroshi\n\n* @ref:[Get Otoroshi](./get-otoroshi.md)\n* @ref:[Setup Otoroshi](./setup-otoroshi.md)\n\n@@@ index\n\n* [Get Otoroshi](./get-otoroshi.md)\n* [Setup Otoroshi](./setup-otoroshi.md)\n\n@@@\n"},{"name":"setup-otoroshi.md","id":"/install/setup-otoroshi.md","url":"/install/setup-otoroshi.html","title":"Setup Otoroshi","content":"# Setup Otoroshi\n\n## Environnement variables\n\n@@@ warning\nTODO\n@@@"},{"name":"built-in-plugins.md","id":"/plugins/built-in-plugins.md","url":"/plugins/built-in-plugins.html","title":"Otoroshi built-in plugins","content":"# Otoroshi built-in plugins\n\nOtoroshi provides some plugins out of the box. Here is the available plugins with their documentation and reference configuration\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Access log (CLF)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `AccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged in CLF format.\n\nLog format is the following:\n\n`\"$service\" $clientAddress - \"$userId\" [$timestamp] \"$host $method $path $protocol\" \"$status $statusTxt\" $size $snowflake \"$to\" \"$referer\" \"$userAgent\" $http $duration $errorMsg`\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"AccessLog\": {\n    \"enabled\": true,\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"AccessLog\" : {\n    \"enabled\" : true,\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Access log (JSON)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `AccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged in json format.\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"AccessLog\": {\n    \"enabled\": true,\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"AccessLog\" : {\n    \"enabled\" : true,\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Kafka access log\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `KafkaAccessLog`\n\n### Description\n\nWith this plugin, any access to a service will be logged as an event in a kafka topic.\n\nThe plugin accepts the following configuration\n\n```json\n{\n  \"KafkaAccessLog\": {\n    \"enabled\": true,\n    \"topic\": \"otoroshi-access-log\",\n    \"statuses\": [], // list of status to enable logs, if none, log everything\n    \"paths\": [], // list of paths to enable logs, if none, log everything\n    \"methods\": [], // list of http methods to enable logs, if none, log everything\n    \"identities\": [] // list of identities to enable logs, if none, log everything\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KafkaAccessLog\" : {\n    \"enabled\" : true,\n    \"topic\" : \"otoroshi-access-log\",\n    \"statuses\" : [ ],\n    \"paths\" : [ ],\n    \"methods\" : [ ],\n    \"identities\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Basic Auth. caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `BasicAuthCaller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using basic auth.\n\nThis plugin accepts the following configuration\n\n{\n  \"username\" : \"the_username\",\n  \"password\" : \"the_password\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Basic %s\"\n}\n\n\n\n### Default configuration\n\n```json\n{\n  \"username\" : \"the_username\",\n  \"password\" : \"the_password\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Basic %s\"\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OAuth2 caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OAuth2Caller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using OAuth2 client_credential/password flow.\nDo not forget to enable client retry to handle token generation on expire.\n\nThis plugin accepts the following configuration\n\n{\n  \"kind\" : \"the oauth2 flow, can be 'client_credentials' or 'password'\",\n  \"url\" : \"https://127.0.0.1:8080/oauth/token\",\n  \"method\" : \"POST\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Bearer %s\",\n  \"jsonPayload\" : false,\n  \"clientId\" : \"the client_id\",\n  \"clientSecret\" : \"the client_secret\",\n  \"scope\" : \"an optional scope\",\n  \"audience\" : \"an optional audience\",\n  \"user\" : \"an optional username if using password flow\",\n  \"password\" : \"an optional password if using password flow\",\n  \"cacheTokenSeconds\" : \"the number of second to wait before asking for a new token\",\n  \"tlsConfig\" : \"an optional TLS settings object\"\n}\n\n\n\n### Default configuration\n\n```json\n{\n  \"kind\" : \"the oauth2 flow, can be 'client_credentials' or 'password'\",\n  \"url\" : \"https://127.0.0.1:8080/oauth/token\",\n  \"method\" : \"POST\",\n  \"headerName\" : \"Authorization\",\n  \"headerValueFormat\" : \"Bearer %s\",\n  \"jsonPayload\" : false,\n  \"clientId\" : \"the client_id\",\n  \"clientSecret\" : \"the client_secret\",\n  \"scope\" : \"an optional scope\",\n  \"audience\" : \"an optional audience\",\n  \"user\" : \"an optional username if using password flow\",\n  \"password\" : \"an optional password if using password flow\",\n  \"cacheTokenSeconds\" : \"the number of second to wait before asking for a new token\",\n  \"tlsConfig\" : \"an optional TLS settings object\"\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Response Cache\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ResponseCache`\n\n### Description\n\nThis plugin can cache responses from target services in the otoroshi datasstore\nIt also provides a debug UI at `/.well-known/otoroshi/bodylogger`.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ResponseCache\": {\n    \"enabled\": true, // enabled cache\n    \"ttl\": 300000,  // store it for some times (5 minutes by default)\n    \"maxSize\": 5242880, // max body size (body will be cut after that)\n    \"autoClean\": true, // cleanup older keys when all bigger than maxSize\n    \"filter\": { // cache only for some status, method and paths\n      \"statuses\": [],\n      \"methods\": [],\n      \"paths\": [],\n      \"not\": {\n        \"statuses\": [],\n        \"methods\": [],\n        \"paths\": []\n      }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ResponseCache\" : {\n    \"enabled\" : true,\n    \"ttl\" : 3600000,\n    \"maxSize\" : 52428800,\n    \"autoClean\" : true,\n    \"filter\" : {\n      \"statuses\" : [ ],\n      \"methods\" : [ ],\n      \"paths\" : [ ],\n      \"not\" : {\n        \"statuses\" : [ ],\n        \"methods\" : [ ],\n        \"paths\" : [ ]\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Client certificate header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ClientCertChain`\n\n### Description\n\nThis plugin pass client certificate informations to the target in headers.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ClientCertChain\": {\n    \"pem\": { // send client cert as PEM format in a header\n      \"send\": false,\n      \"header\": \"X-Client-Cert-Pem\"\n    },\n    \"dns\": { // send JSON array of DNs in a header\n      \"send\": false,\n      \"header\": \"X-Client-Cert-DNs\"\n    },\n    \"chain\": { // send JSON representation of client cert chain in a header\n      \"send\": true,\n      \"header\": \"X-Client-Cert-Chain\"\n    },\n    \"claims\": { // pass JSON representation of client cert chain in the otoroshi JWT token\n      \"send\": false,\n      \"name\": \"clientCertChain\"\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ClientCertChain\" : {\n    \"pem\" : {\n      \"send\" : false,\n      \"header\" : \"X-Client-Cert-Pem\"\n    },\n    \"dns\" : {\n      \"send\" : false,\n      \"header\" : \"X-Client-Cert-DNs\"\n    },\n    \"chain\" : {\n      \"send\" : true,\n      \"header\" : \"X-Client-Cert-Chain\"\n    },\n    \"claims\" : {\n      \"send\" : false,\n      \"name\" : \"clientCertChain\"\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Defer Responses\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `DeferPlugin`\n\n### Description\n\nThis plugin will expect a `X-Defer` header or a `defer` query param and defer the response according to the value in milliseconds.\nThis plugin is some kind of inside joke as one a our customer ask us to make slower apis.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"DeferPlugin\": {\n    \"defaultDefer\": 0 // default defer in millis\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"DeferPlugin\" : {\n    \"defaultDefer\" : 0\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Self registration endpoints (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin add support for self registration endpoint on a specific service.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Envoy Control Plane (experimental)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `EnvoyControlPlane`\n\n### Description\n\nThis plugin will expose the otoroshi state to envoy instances using the xDS V3 API`.\n\nRight now, all the features of otoroshi cannot be exposed as is through Envoy.\n\n\n\n### Default configuration\n\n```json\n{\n  \"EnvoyControlPlane\" : {\n    \"enabled\" : true\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Geolocation endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: ``none``\n\n### Description\n\nThis plugin will expose current geolocation informations on the following endpoint.\n\n`/.well-known/otoroshi/plugins/geolocation`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Geolocation header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `GeolocationInfoHeader`\n\n### Description\n\nThis plugin will send informations extracted by the Geolocation details extractor to the target service in a header.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfoHeader\": {\n    \"headerName\": \"X-Geolocation-Info\" // header in which info will be sent\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfoHeader\" : {\n    \"headerName\" : \"X-Geolocation-Info\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## HMAC caller plugin\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `HMACCallerPlugin`\n\n### Description\n\nThis plugin can be used to call a \"protected\" api by an HMAC signature. It will adds a signature with the secret configured on the plugin.\n The signature string will always the content of the header list listed in the plugin configuration.\n\n\n\n### Default configuration\n\n```json\n{\n  \"HMACCallerPlugin\" : {\n    \"secret\" : \"my-defaut-secret\",\n    \"algo\" : \"HMAC-SHA512\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Izanami Canary Campaign\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `IzanamiCanary`\n\n### Description\n\nThis plugin allow you to perform canary testing based on an izanami experiment campaign (A/B test).\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"IzanamiCanary\" : {\n    \"experimentId\" : \"foo:bar:qix\",\n    \"configId\" : \"foo:bar:qix:config\",\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000,\n    \"mtls\" : {\n      \"certs\" : [ ],\n      \"trustedCerts\" : [ ],\n      \"mtls\" : false,\n      \"loose\" : false,\n      \"trustAll\" : false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"IzanamiCanary\" : {\n    \"experimentId\" : \"foo:bar:qix\",\n    \"configId\" : \"foo:bar:qix:config\",\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000,\n    \"mtls\" : {\n      \"certs\" : [ ],\n      \"trustedCerts\" : [ ],\n      \"mtls\" : false,\n      \"loose\" : false,\n      \"trustAll\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Izanami APIs Proxy\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `IzanamiProxy`\n\n### Description\n\nThis plugin exposes routes to proxy Izanami configuration and features tree APIs.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"IzanamiProxy\" : {\n    \"path\" : \"/api/izanami\",\n    \"featurePattern\" : \"*\",\n    \"configPattern\" : \"*\",\n    \"autoContext\" : false,\n    \"featuresEnabled\" : true,\n    \"featuresWithContextEnabled\" : true,\n    \"configurationEnabled\" : false,\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"IzanamiProxy\" : {\n    \"path\" : \"/api/izanami\",\n    \"featurePattern\" : \"*\",\n    \"configPattern\" : \"*\",\n    \"autoContext\" : false,\n    \"featuresEnabled\" : true,\n    \"featuresWithContextEnabled\" : true,\n    \"configurationEnabled\" : false,\n    \"izanamiUrl\" : \"https://izanami.foo.bar\",\n    \"izanamiClientId\" : \"client\",\n    \"izanamiClientSecret\" : \"secret\",\n    \"timeout\" : 5000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Html Patcher\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `HtmlPatcher`\n\n### Description\n\nThis plugin can inject elements in html pages (in the body or in the head) returned by the service\n\n\n\n### Default configuration\n\n```json\n{\n  \"HtmlPatcher\" : {\n    \"appendHead\" : [ ],\n    \"appendBody\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Body logger\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `BodyLogger`\n\n### Description\n\nThis plugin can log body present in request and response. It can just logs it, store in in the redis store with a ttl and send it to analytics.\nIt also provides a debug UI at `/.well-known/otoroshi/bodylogger`.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"BodyLogger\": {\n    \"enabled\": true, // enabled logging\n    \"log\": true, // just log it\n    \"store\": false, // store bodies in datastore\n    \"ttl\": 300000,  // store it for some times (5 minutes by default)\n    \"sendToAnalytics\": false, // send bodies to analytics\n    \"maxSize\": 5242880, // max body size (body will be cut after that)\n    \"password\": \"password\", // password for the ui, if none, it's public\n    \"filter\": { // log only for some status, method and paths\n      \"statuses\": [],\n      \"methods\": [],\n      \"paths\": [],\n      \"not\": {\n        \"statuses\": [],\n        \"methods\": [],\n        \"paths\": []\n      }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"BodyLogger\" : {\n    \"enabled\" : true,\n    \"log\" : true,\n    \"store\" : false,\n    \"ttl\" : 300000,\n    \"sendToAnalytics\" : false,\n    \"maxSize\" : 5242880,\n    \"password\" : \"password\",\n    \"filter\" : {\n      \"statuses\" : [ ],\n      \"methods\" : [ ],\n      \"paths\" : [ ],\n      \"not\" : {\n        \"statuses\" : [ ],\n        \"methods\" : [ ],\n        \"paths\" : [ ]\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Prometheus Service Metrics\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `PrometheusServiceMetrics`\n\n### Description\n\nThis plugin collects service metrics and can be used with the `Prometheus Endpoint` (in the Danger Zone) plugin to expose those metrics\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"PrometheusServiceMetrics\": {\n    \"includeUri\": false // include http uri in metrics. WARNING this could impliess performance issues, use at your own risks\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"PrometheusServiceMetrics\" : {\n    \"includeUri\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Service Metrics\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `ServiceMetrics`\n\n### Description\n\nThis plugin expose service metrics in Otoroshi global metrics or on a special URL of the service `/.well-known/otoroshi/metrics`.\nMetrics are exposed in json or prometheus format depending on the accept header. You can protect it with an access key defined in the configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ServiceMetrics\": {\n    \"accessKeyValue\": \"secret\", // if not defined, public access. Can be ${config.app.health.accessKey}\n    \"accessKeyQuery\": \"access_key\"\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ServiceMetrics\" : {\n    \"accessKeyValue\" : \"${config.app.health.accessKey}\",\n    \"accessKeyQuery\" : \"access_key\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Mirroring plugin\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `MirroringPlugin`\n\n### Description\n\nThis plugin will mirror every request to other targets\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"MirroringPlugin\": {\n    \"enabled\": true, // enabled mirroring\n    \"to\": \"https://foo.bar.dev\", // the url of the service to mirror\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"MirroringPlugin\" : {\n    \"enabled\" : true,\n    \"to\" : \"https://foo.bar.dev\",\n    \"captureResponse\" : false,\n    \"generateEvents\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OAuth1 caller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OAuth1Caller`\n\n### Description\n\nThis plugin can be used to call api that are authenticated using OAuth1.\n Consumer key, secret, and OAuth token et OAuth token secret can be pass through the metadata of an api key\n or via the configuration of this plugin.\n\n\n\n### Default configuration\n\n```json\n{\n  \"OAuth1Caller\" : {\n    \"algo\" : \"HmacSHA512\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## OIDC headers\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `OIDCHeaders`\n\n### Description\n\nThis plugin injects headers containing tokens and profile from current OIDC provider.\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCHeaders\" : {\n    \"profile\" : {\n      \"send\" : true,\n      \"headerName\" : \"X-OIDC-User\"\n    },\n    \"idtoken\" : {\n      \"send\" : false,\n      \"name\" : \"id_token\",\n      \"headerName\" : \"X-OIDC-Id-Token\",\n      \"jwt\" : true\n    },\n    \"accesstoken\" : {\n      \"send\" : false,\n      \"name\" : \"access_token\",\n      \"headerName\" : \"X-OIDC-Access-Token\",\n      \"jwt\" : true\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Security Txt\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `SecurityTxt`\n\n### Description\n\nThis plugin exposes a special route `/.well-known/security.txt` as proposed at [https://securitytxt.org/](https://securitytxt.org/).\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"SecurityTxt\": {\n    \"Contact\": \"contact@foo.bar\", // mandatory, a link or e-mail address for people to contact you about security issues\n    \"Encryption\": \"http://url-to-public-key\", // optional, a link to a key which security researchers should use to securely talk to you\n    \"Acknowledgments\": \"http://url\", // optional, a link to a web page where you say thank you to security researchers who have helped you\n    \"Preferred-Languages\": \"en, fr, es\", // optional\n    \"Policy\": \"http://url\", // optional, a link to a policy detailing what security researchers should do when searching for or reporting security issues\n    \"Hiring\": \"http://url\", // optional, a link to any security-related job openings in your organisation\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"SecurityTxt\" : {\n    \"Contact\" : \"contact@foo.bar\",\n    \"Encryption\" : \"https://...\",\n    \"Acknowledgments\" : \"https://...\",\n    \"Preferred-Languages\" : \"en, fr\",\n    \"Policy\" : \"https://...\",\n    \"Hiring\" : \"https://...\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Static Response\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `StaticResponse`\n\n### Description\n\nThis plugin returns a static response for any request\n\n\n\n### Default configuration\n\n```json\n{\n  \"StaticResponse\" : {\n    \"status\" : 200,\n    \"headers\" : {\n      \"Content-Type\" : \"application/json\"\n    },\n    \"body\" : \"{\\\"message\\\":\\\"hello world!\\\"}\",\n    \"bodyBase64\" : null\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## User-Agent endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: ``none``\n\n### Description\n\nThis plugin will expose current user-agent informations on the following endpoint.\n\n`/.well-known/otoroshi/plugins/user-agent`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## User-Agent header\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `UserAgentInfoHeader`\n\n### Description\n\nThis plugin will sent informations extracted by the User-Agent details extractor to the target service in a header.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"UserAgentInfoHeader\": {\n    \"headerName\": \"X-User-Agent-Info\" // header in which info will be sent\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"UserAgentInfoHeader\" : {\n    \"headerName\" : \"X-User-Agent-Info\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-transformer }\n\n## Workflow endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `transformer`\n* configuration root: `WorkflowEndpoint`\n\n### Description\n\nThis plugin runs a workflow and return the response\n\n\n\n### Default configuration\n\n```json\n{\n  \"WorkflowEndpoint\" : {\n    \"workflow\" : { }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Biscuit token validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nThis plugin validates a Biscuit token.\n\n\n\n### Default configuration\n\n```json\n{\n  \"publicKey\" : \"xxxxxx\",\n  \"secret\" : \"secret\",\n  \"checks\" : [ ],\n  \"facts\" : [ ],\n  \"resources\" : [ ],\n  \"rules\" : [ ],\n  \"revocation_ids\" : [ ],\n  \"enforce\" : false,\n  \"sealed\" : false,\n  \"extractor\" : {\n    \"type\" : \"header\",\n    \"name\" : \"Authorization\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client Certificate + Api Key only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nCheck if a client certificate is present in the request and that the apikey used matches the client certificate.\nYou can set the client cert. DN in an apikey metadata named `allowed-client-cert-dn`\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client certificate matching (over http)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasClientCertMatchingHttpValidator`\n\n### Description\n\nCheck if client certificate matches the following configuration\n\nexpected response from http service is\n\n```json\n{\n  \"serialNumbers\": [],   // allowed certificated serial numbers\n  \"subjectDNs\": [],      // allowed certificated DNs\n  \"issuerDNs\": [],       // allowed certificated issuer DNs\n  \"regexSubjectDNs\": [], // allowed certificated DNs matching regex\n  \"regexIssuerDNs\": [],  // allowed certificated issuer DNs matching regex\n}\n```\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\": {\n    \"url\": \"...\",   // url for the call\n    \"headers\": {},  // http header for the call\n    \"ttl\": 600000,  // cache ttl,\n    \"mtlsConfig\": {\n      \"certId\": \"xxxxx\",\n       \"mtls\": false,\n       \"loose\": false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasClientCertMatchingHttpValidator\" : {\n    \"url\" : \"http://foo.bar\",\n    \"ttl\" : 600000,\n    \"headers\" : { },\n    \"mtlsConfig\" : {\n      \"certId\" : \"...\",\n      \"mtls\" : false,\n      \"loose\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client certificate matching\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasClientCertMatchingValidator`\n\n### Description\n\nCheck if client certificate matches the following configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\": {\n    \"serialNumbers\": [],   // allowed certificated serial numbers\n    \"subjectDNs\": [],      // allowed certificated DNs\n    \"issuerDNs\": [],       // allowed certificated issuer DNs\n    \"regexSubjectDNs\": [], // allowed certificated DNs matching regex\n    \"regexIssuerDNs\": [],  // allowed certificated issuer DNs matching regex\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasClientCertMatchingValidator\" : {\n    \"serialNumbers\" : [ ],\n    \"subjectDNs\" : [ ],\n    \"issuerDNs\" : [ ],\n    \"regexSubjectDNs\" : [ ],\n    \"regexIssuerDNs\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Client Certificate Only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: ``none``\n\n### Description\n\nCheck if a client certificate is present in the request\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## External Http Validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `ExternalHttpValidator`\n\n### Description\n\nCalls an external http service to know if a user has access or not. Uses cache for performances.\n\nThe sent payload is the following:\n\n```json\n{\n  \"apikey\": {...},\n  \"user\": {...},\n  \"service\": : {...},\n  \"chain\": \"...\",  // PEM cert chain\n  \"fingerprints\": [...]\n}\n```\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"ExternalHttpValidator\": {\n    \"url\": \"...\",                      // url for the http call\n    \"host\": \"...\",                     // value of the host header for the call. default is host of the url\n    \"goodTtl\": 600000,                 // ttl in ms for a validated call\n    \"badTtl\": 60000,                   // ttl in ms for a not validated call\n    \"method\": \"POST\",                  // http methode\n    \"path\": \"/certificates/_validate\", // http uri path\n    \"timeout\": 10000,                  // http call timeout\n    \"noCache\": false,                  // use cache or not\n    \"allowNoClientCert\": false,        //\n    \"headers\": {},                      // headers for the http call if needed\n    \"mtlsConfig\": {\n      \"certId\": \"xxxxx\",\n       \"mtls\": false,\n       \"loose\": false\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ExternalHttpValidator\" : {\n    \"url\" : \"http://foo.bar\",\n    \"host\" : \"api.foo.bar\",\n    \"goodTtl\" : 600000,\n    \"badTtl\" : 60000,\n    \"method\" : \"POST\",\n    \"path\" : \"/certificates/_validate\",\n    \"timeout\" : 10000,\n    \"noCache\" : false,\n    \"allowNoClientCert\" : false,\n    \"headers\" : { },\n    \"mtlsConfig\" : {\n      \"certId\" : \"...\",\n      \"mtls\" : false,\n      \"loose\" : false\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## HMAC access validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HMACAccessValidator`\n\n### Description\n\nThis plugin can be used to check if a HMAC signature is present and valid in Authorization header.\n\n\n\n### Default configuration\n\n```json\n{\n  \"HMACAccessValidator\" : {\n    \"secret\" : \"\"\n  }\n}\n```\n\n\n\n### Documentation\n\n\n The HMAC signature needs to be set on the `Authorization` or `Proxy-Authorization` header.\n The format of this header should be : `hmac algorithm=\"<ALGORITHM>\", headers=\"<HEADER>\", signature=\"<SIGNATURE>\"`\n As example, a simple nodeJS call with the expected header\n ```js\n const crypto = require('crypto');\n const fetch = require('node-fetch');\n\n const date = new Date()\n const secret = \"my-secret\" // equal to the api key secret by default\n\n const algo = \"sha512\"\n const signature = crypto.createHmac(algo, secret)\n    .update(date.getTime().toString())\n    .digest('base64');\n\n fetch('http://myservice.oto.tools:9999/api/test', {\n    headers: {\n        \"Otoroshi-Client-Id\": \"my-id\",\n        \"Otoroshi-Client-Secret\": \"my-secret\",\n        \"Date\": date.getTime().toString(),\n        \"Authorization\": `hmac algorithm=\"hmac-${algo}\", headers=\"Date\", signature=\"${signature}\"`,\n        \"Accept\": \"application/json\"\n    }\n })\n    .then(r => r.json())\n    .then(console.log)\n ```\n In this example, we have an Otoroshi service deployed on http://myservice.oto.tools:9999/api/test, protected by api keys.\n The secret used is the secret of the api key (by default, but you can change it and define a secret on the plugin configuration).\n We send the base64 encoded date of the day, signed by the secret, in the Authorization header. We specify the headers signed and the type of algorithm used.\n You can sign more than one header but you have to list them in the headers fields (each one separate by a space, example : headers=\"Date KeyId\").\n The algorithm used can be HMAC-SHA1, HMAC-SHA256, HMAC-SHA384 or HMAC-SHA512.\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## OIDC access_token validator\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `OIDCAccessTokenValidator`\n\n### Description\n\nThis plugin will use the third party apikey configuration and apply it while keeping the apikey mecanism of otoroshi.\nUse it to combine apikey validation and OIDC access_token validation.\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\": {\n    \"enabled\": true,\n    \"atLeastOne\": false,\n    // config is optional and can be either an object config or an array of objects\n    \"config\": {\n  \"enabled\" : true,\n  \"quotasEnabled\" : true,\n  \"uniqueApiKey\" : false,\n  \"type\" : \"OIDC\",\n  \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n  \"localVerificationOnly\" : false,\n  \"mode\" : \"Tmp\",\n  \"ttl\" : 0,\n  \"headerName\" : \"Authorization\",\n  \"throttlingQuota\" : 100,\n  \"dailyQuota\" : 10000000,\n  \"monthlyQuota\" : 10000000,\n  \"excludedPatterns\" : [ ],\n  \"scopes\" : [ ],\n  \"rolesPath\" : [ ],\n  \"roles\" : [ ]\n}\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\" : {\n    \"enabled\" : true,\n    \"atLeastOne\" : false,\n    \"config\" : {\n      \"enabled\" : true,\n      \"quotasEnabled\" : true,\n      \"uniqueApiKey\" : false,\n      \"type\" : \"OIDC\",\n      \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n      \"localVerificationOnly\" : false,\n      \"mode\" : \"Tmp\",\n      \"ttl\" : 0,\n      \"headerName\" : \"Authorization\",\n      \"throttlingQuota\" : 100,\n      \"dailyQuota\" : 10000000,\n      \"monthlyQuota\" : 10000000,\n      \"excludedPatterns\" : [ ],\n      \"scopes\" : [ ],\n      \"rolesPath\" : [ ],\n      \"roles\" : [ ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Instance quotas\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `InstanceQuotas`\n\n### Description\n\nThis plugin will enforce global quotas on the current instance\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"InstanceQuotas\": {\n    \"callsPerDay\": -1,     // max allowed api calls per day\n    \"callsPerMonth\": -1,   // max allowed api calls per month\n    \"maxDescriptors\": -1,  // max allowed service descriptors\n    \"maxApiKeys\": -1,      // max allowed apikeys\n    \"maxGroups\": -1,       // max allowed service groups\n    \"maxScripts\": -1,      // max allowed apikeys\n    \"maxCertificates\": -1, // max allowed certificates\n    \"maxVerifiers\": -1,    // max allowed jwt verifiers\n    \"maxAuthModules\": -1,  // max allowed auth modules\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"InstanceQuotas\" : {\n    \"callsPerDay\" : -1,\n    \"callsPerMonth\" : -1,\n    \"maxDescriptors\" : -1,\n    \"maxApiKeys\" : -1,\n    \"maxGroups\" : -1,\n    \"maxScripts\" : -1,\n    \"maxCertificates\" : -1,\n    \"maxVerifiers\" : -1,\n    \"maxAuthModules\" : -1\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Public quotas\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `ServiceQuotas`\n\n### Description\n\nThis plugin will enforce public quotas on the current service\n\n\n\n\n\n\n\n### Default configuration\n\n```json\n{\n  \"ServiceQuotas\" : {\n    \"throttlingQuota\" : 100,\n    \"dailyQuota\" : 10000000,\n    \"monthlyQuota\" : 10000000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-validator }\n\n## Allowed users only\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `validator`\n* configuration root: `HasAllowedUsersValidator`\n\n### Description\n\nThis plugin only let allowed users pass\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"HasAllowedUsersValidator\": {\n    \"usernames\": [],   // allowed usernames\n    \"emails\": [],      // allowed user email addresses\n    \"emailDomains\": [], // allowed user email domains\n    \"metadataMatch\": [], // json path expressions to match against user metadata. passes if one match\n    \"metadataNotMatch\": [], // json path expressions to match against user metadata. passes if none match\n    \"profileMatch\": [], // json path expressions to match against user profile. passes if one match\n    \"profileNotMatch\": [], // json path expressions to match against user profile. passes if none match\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"HasAllowedUsersValidator\" : {\n    \"usernames\" : [ ],\n    \"emails\" : [ ],\n    \"emailDomains\" : [ ],\n    \"metadataMatch\" : [ ],\n    \"metadataNotMatch\" : [ ],\n    \"profileMatch\" : [ ],\n    \"profileNotMatch\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Apikey auth module\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `ApikeyAuthModule`\n\n### Description\n\nThis plugin adds basic auth on service where credentials are valid apikeys on the current service.\n\n\n\n### Default configuration\n\n```json\n{\n  \"ApikeyAuthModule\" : {\n    \"realm\" : \"apikey-auth-module-realm\",\n    \"noneTagIn\" : [ ],\n    \"oneTagIn\" : [ ],\n    \"allTagsIn\" : [ ],\n    \"noneMetaIn\" : [ ],\n    \"oneMetaIn\" : [ ],\n    \"allMetaIn\" : [ ],\n    \"noneMetaKeysIn\" : [ ],\n    \"oneMetaKeyIn\" : [ ],\n    \"allMetaKeysIn\" : [ ]\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Client certificate as apikey\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `CertificateAsApikey`\n\n### Description\n\nThis plugin uses client certificate as an apikey. The apikey will be stored for classic apikey usage\n\n\n\n### Default configuration\n\n```json\n{\n  \"CertificateAsApikey\" : {\n    \"readOnly\" : false,\n    \"allowClientIdOnly\" : false,\n    \"throttlingQuota\" : 100,\n    \"dailyQuota\" : 10000000,\n    \"monthlyQuota\" : 10000000,\n    \"constrainedServicesOnly\" : false,\n    \"tags\" : [ ],\n    \"metadata\" : { }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Client Credential Flow ApiKey extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: ``none``\n\n### Description\n\nThis plugin can extract an apikey from an opaque access_token generate by the `ClientCredentialFlow` plugin\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Apikey from Biscuit token extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: ``none``\n\n### Description\n\nThis plugin extract an from a Biscuit token where the biscuit has an #authority fact 'client_id' containing\napikey client_id and an #authority fact 'client_sign' that is the HMAC256 signature of the apikey client_id with the apikey client_secret\n\n\n\n### Default configuration\n\n```json\n{\n  \"publicKey\" : \"xxxxxx\",\n  \"secret\" : \"secret\",\n  \"checks\" : [ ],\n  \"facts\" : [ ],\n  \"resources\" : [ ],\n  \"rules\" : [ ],\n  \"revocation_ids\" : [ ],\n  \"enforce\" : false,\n  \"sealed\" : false,\n  \"extractor\" : {\n    \"type\" : \"header\",\n    \"name\" : \"Authorization\"\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Service discovery target selector (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin select a target in the pool of discovered targets for this service.\nUse in combination with either `DiscoverySelfRegistrationSink` or `DiscoverySelfRegistrationTransformer` to make it work using the `self registration` pattern.\nOr use an implementation of `DiscoveryJob` for the `third party registration pattern`.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Geolocation details extractor (using IpStack api)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `GeolocationInfo`\n\n### Description\n\nThis plugin extract geolocation informations from ip address using the [IpStack dbs](https://ipstack.com/).\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfo\": {\n    \"apikey\": \"xxxxxxx\",\n    \"timeout\": 2000, // timeout in ms\n    \"log\": false // will log geolocation details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfo\" : {\n    \"apikey\" : \"xxxxxxx\",\n    \"timeout\" : 2000,\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Geolocation details extractor (using Maxmind db)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `GeolocationInfo`\n\n### Description\n\nThis plugin extract geolocation informations from ip address using the [Maxmind dbs](https://www.maxmind.com/en/geoip2-databases).\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"GeolocationInfo\": {\n    \"path\": \"/foo/bar/cities.mmdb\", // file path, can be \"global\"\n    \"log\": false // will log geolocation details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"GeolocationInfo\" : {\n    \"path\" : \"global\",\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## Jwt user extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `JwtUserExtractor`\n\n### Description\n\nThis plugin extract a user from a JWT token\n\n\n\n### Default configuration\n\n```json\n{\n  \"JwtUserExtractor\" : {\n    \"verifier\" : \"\",\n    \"strict\" : true,\n    \"namePath\" : \"name\",\n    \"emailPath\" : \"email\",\n    \"metaPath\" : null\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## OIDC access_token as apikey\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `OIDCAccessTokenAsApikey`\n\n### Description\n\nThis plugin will use the third party apikey configuration to generate an apikey\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"OIDCAccessTokenValidator\": {\n    \"enabled\": true,\n    \"atLeastOne\": false,\n    // config is optional and can be either an object config or an array of objects\n    \"config\": {\n  \"enabled\" : true,\n  \"quotasEnabled\" : true,\n  \"uniqueApiKey\" : false,\n  \"type\" : \"OIDC\",\n  \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n  \"localVerificationOnly\" : false,\n  \"mode\" : \"Tmp\",\n  \"ttl\" : 0,\n  \"headerName\" : \"Authorization\",\n  \"throttlingQuota\" : 100,\n  \"dailyQuota\" : 10000000,\n  \"monthlyQuota\" : 10000000,\n  \"excludedPatterns\" : [ ],\n  \"scopes\" : [ ],\n  \"rolesPath\" : [ ],\n  \"roles\" : [ ]\n}\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"OIDCAccessTokenAsApikey\" : {\n    \"enabled\" : true,\n    \"atLeastOne\" : false,\n    \"config\" : {\n      \"enabled\" : true,\n      \"quotasEnabled\" : true,\n      \"uniqueApiKey\" : false,\n      \"type\" : \"OIDC\",\n      \"oidcConfigRef\" : \"some-oidc-auth-module-id\",\n      \"localVerificationOnly\" : false,\n      \"mode\" : \"Tmp\",\n      \"ttl\" : 0,\n      \"headerName\" : \"Authorization\",\n      \"throttlingQuota\" : 100,\n      \"dailyQuota\" : 10000000,\n      \"monthlyQuota\" : 10000000,\n      \"excludedPatterns\" : [ ],\n      \"scopes\" : [ ],\n      \"rolesPath\" : [ ],\n      \"roles\" : [ ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-preroute }\n\n## User-Agent details extractor\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `preroute`\n* configuration root: `UserAgentInfo`\n\n### Description\n\nThis plugin extract informations from User-Agent header such as browsser version, OS version, etc.\nThe informations are store in plugins attrs for other plugins to use\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"UserAgentInfo\": {\n    \"log\": false // will log user-agent details\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"UserAgentInfo\" : {\n    \"log\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Client Credential Service\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `ClientCredentialService`\n\n### Description\n\nThis plugin add an an oauth client credentials service (`https://unhandleddomain/.well-known/otoroshi/oauth/token`) to create an access_token given a client id and secret.\n\n```json\n{\n  \"ClientCredentialService\" : {\n    \"domain\" : \"*\",\n    \"expiration\" : 3600000,\n    \"defaultKeyPair\" : \"otoroshi-jwt-signing\",\n    \"secure\" : true\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"ClientCredentialService\" : {\n    \"domain\" : \"*\",\n    \"expiration\" : 3600000,\n    \"defaultKeyPair\" : \"otoroshi-jwt-signing\",\n    \"secure\" : true\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Global self registration endpoints (service discovery)\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `DiscoverySelfRegistration`\n\n### Description\n\nThis plugin add support for self registration endpoint on specific hostnames.\n\nThis plugin accepts the following configuration:\n\n\n\n### Default configuration\n\n```json\n{\n  \"DiscoverySelfRegistration\" : {\n    \"hosts\" : [ ],\n    \"targetTemplate\" : { },\n    \"registrationTtl\" : 60000\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Kubernetes admission validator webhook\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: ``none``\n\n### Description\n\nThis plugin exposes a webhook to kubernetes to handle manifests validation\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Kubernetes sidecar injector webhook\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: ``none``\n\n### Description\n\nThis plugin exposes a webhook to kubernetes to inject otoroshi-sidecar in pods\n\n\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-sink }\n\n## Prometheus Endpoint\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `sink`\n* configuration root: `PrometheusEndpoint`\n\n### Description\n\nThis plugin exposes metrics collected by `Prometheus Service Metrics` on a `/prometheus` endpoint.\nYou can protect it with an access key defined in the configuration\n\nThis plugin can accept the following configuration\n\n```json\n{\n  \"PrometheusEndpoint\": {\n    \"accessKeyValue\": \"secret\", // if not defined, public access. Can be ${config.app.health.accessKey}\n    \"accessKeyQuery\": \"access_key\",\n    \"includeMetrics\": false\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"PrometheusEndpoint\" : {\n    \"accessKeyValue\" : \"${config.app.health.accessKey}\",\n    \"accessKeyQuery\" : \"access_key\",\n    \"includeMetrics\" : false\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes Ingress Controller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin enables Otoroshi as an Ingress Controller\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes Otoroshi CRDs Controller\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin enables Otoroshi CRDs Controller\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Kubernetes to Otoroshi certs. synchronizer\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin syncs. TLS secrets from Kubernetes to Otoroshi\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Otoroshi certs. to Kubernetes secrets synchronizer\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `KubernetesConfig`\n\n### Description\n\nThis plugin syncs. Otoroshi certs to Kubernetes TLS secrets\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n### Default configuration\n\n```json\n{\n  \"KubernetesConfig\" : {\n    \"endpoint\" : \"https://kube.cluster.dev\",\n    \"token\" : \"xxx\",\n    \"userPassword\" : \"user:password\",\n    \"caCert\" : \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\",\n    \"trust\" : false,\n    \"namespaces\" : [ \"*\" ],\n    \"labels\" : { },\n    \"namespacesLabels\" : { },\n    \"ingressClasses\" : [ \"otoroshi\" ],\n    \"defaultGroup\" : \"default\",\n    \"ingresses\" : true,\n    \"crds\" : true,\n    \"coreDnsIntegration\" : false,\n    \"coreDnsIntegrationDryRun\" : false,\n    \"kubeLeader\" : false,\n    \"restartDependantDeployments\" : true,\n    \"watch\" : true,\n    \"syncDaikokuApikeysOnly\" : false,\n    \"kubeSystemNamespace\" : \"kube-system\",\n    \"coreDnsConfigMapName\" : \"coredns\",\n    \"coreDnsDeploymentName\" : \"coredns\",\n    \"corednsPort\" : 53,\n    \"otoroshiServiceName\" : \"otoroshi-service\",\n    \"otoroshiNamespace\" : \"otoroshi\",\n    \"clusterDomain\" : \"cluster.local\",\n    \"syncIntervalSeconds\" : 60,\n    \"coreDnsEnv\" : null,\n    \"watchTimeoutSeconds\" : 60,\n    \"watchGracePeriodSeconds\" : 5,\n    \"mutatingWebhookName\" : \"otoroshi-admission-webhook-injector\",\n    \"validatingWebhookName\" : \"otoroshi-admission-webhook-validation\",\n    \"meshDomain\" : \"otoroshi.mesh\",\n    \"openshiftDnsOperatorIntegration\" : false,\n    \"openshiftDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"openshiftDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"openshiftDnsOperatorCoreDnsPort\" : 5353,\n    \"kubeDnsOperatorIntegration\" : false,\n    \"kubeDnsOperatorCoreDnsNamespace\" : \"otoroshi\",\n    \"kubeDnsOperatorCoreDnsName\" : \"otoroshi-dns\",\n    \"kubeDnsOperatorCoreDnsPort\" : 5353,\n    \"templates\" : {\n      \"service-group\" : { },\n      \"service-descriptor\" : { },\n      \"apikeys\" : { },\n      \"global-config\" : { },\n      \"jwt-verifier\" : { },\n      \"tcp-service\" : { },\n      \"certificate\" : { },\n      \"auth-module\" : { },\n      \"script\" : { },\n      \"data-exporters\" : { },\n      \"organizations\" : { },\n      \"teams\" : { },\n      \"admins\" : { },\n      \"webhooks\" : { }\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n@@@ div { .plugin .plugin-hidden .plugin-kind-job }\n\n## Workflow job\n\n<img class=\"plugin-logo plugin-hidden\" src=\"\"></img>\n\n### Infos\n\n* plugin type: `job`\n* configuration root: `WorkflowJob`\n\n### Description\n\nPeriodically run a custom workflow\n\n\n\n### Default configuration\n\n```json\n{\n  \"WorkflowJob\" : {\n    \"input\" : {\n      \"namespace\" : \"otoroshi\",\n      \"service\" : \"otoroshi-dns\"\n    },\n    \"intervalMillis\" : \"60000\",\n    \"workflow\" : {\n      \"name\" : \"some-workflow\",\n      \"description\" : \"a nice workflow\",\n      \"tasks\" : [ {\n        \"name\" : \"call-dns\",\n        \"type\" : \"http\",\n        \"request\" : {\n          \"method\" : \"PATCH\",\n          \"url\" : \"http://${env.KUBERNETES_SERVICE_HOST}:${env.KUBERNETES_SERVICE_PORT}/apis/v1/namespaces/${input.namespace}/services/${input.service}\",\n          \"headers\" : {\n            \"accept\" : \"application/json\",\n            \"content-type\" : \"application/json\",\n            \"authorization\" : \"Bearer ${file:///var/run/secrets/kubernetes.io/serviceaccount/token}\"\n          },\n          \"tls\" : {\n            \"mtls\" : true,\n            \"trustAll\" : true\n          },\n          \"body\" : [ {\n            \"op\" : \"replace\",\n            \"path\" : \"/spec/selector\",\n            \"value\" : {\n              \"app\" : \"otoroshi\",\n              \"component\" : \"dns\"\n            }\n          } ]\n        },\n        \"success\" : {\n          \"statuses\" : [ 200 ]\n        }\n      } ]\n    }\n  }\n}\n```\n\n\n\n\n\n@@@\n\n\n\n\n"},{"name":"create-plugins.md","id":"/plugins/create-plugins.md","url":"/plugins/create-plugins.html","title":"Create plugins","content":"# Create plugins\n\n@@@ warning\nTODO\n@@@"},{"name":"index.md","id":"/plugins/index.md","url":"/plugins/index.html","title":"Otoroshi plugins","content":"# Otoroshi plugins\n\nIn this sections, you will find informations about Otoroshi plugins system\n\n* @ref:[Plugins system](./plugins.md)\n* @ref:[Create plugins](./create-plugins.md)\n* @ref:[Built in plugins](./built-in-plugins.md)\n\n@@@ index\n\n* [Plugins system](./plugins.md)\n* [Create plugins](./create-plugins.md)\n* [Built in plugins](./built-in-plugins.md)\n\n@@@\n"},{"name":"plugins.md","id":"/plugins/plugins.md","url":"/plugins/plugins.html","title":"Otoroshi plugins system","content":"# Otoroshi plugins system\n\n@@@ warning\nTODO\n@@@"},{"name":"chaos-engineering.md","id":"/topics/chaos-engineering.md","url":"/topics/chaos-engineering.html","title":"Chaos engineering","content":"# Chaos engineering\n\n@@@ warning\nTODO\n@@@"},{"name":"dev-portal.md","id":"/topics/dev-portal.md","url":"/topics/dev-portal.html","title":"Developer portal with Daikoku","content":"# Developer portal with Daikoku\n\n@@@ warning\nTODO\n@@@"},{"name":"events-and-analytics.md","id":"/topics/events-and-analytics.md","url":"/topics/events-and-analytics.html","title":"Events and analytics","content":"# Events and analytics\n\n@@@ warning\nTODO\n@@@"},{"name":"expression-language.md","id":"/topics/expression-language.md","url":"/topics/expression-language.html","title":"Expression language","content":"# Expression language\n\n@@@ warning\nTODO\n@@@"},{"name":"index.md","id":"/topics/index.md","url":"/topics/index.html","title":"Detailed topics","content":"# Detailed topics\n\nIn this sections, you will find informations about various Otoroshi topics  \n\n* @ref:[Chaos engineering](./chaos-engineering.md)\n* @ref:[Otoroshi's PKI](./pki.md)\n* @ref:[Input TLS](./input-tls.md)\n* @ref:[Output TLS](./output-tls.md)\n* @ref:[Monitoring](./monitoring.md)\n* @ref:[Events and analytics](./events-and-analytics.md)\n* @ref:[Developer portal with Daikoku](./dev-portal.md)\n* @ref:[Sessions management](./sessions-mgmt.md)\n* @ref:[The Otoroshi communication protocol](./otoroshi-protocol.md)\n* @ref:[Expression language](./expression-language.md)\n\n@@@ index\n\n* [Chaos engineering](./chaos-engineering.md)\n* [Otoroshi's PKI](./pki.md)\n* [Input TLS](./input-tls.md)\n* [Output TLS](./output-tls.md)\n* [Monitoring](./monitoring.md)\n* [Events and analytics](./events-and-analytics.md)\n* [Developer portal with Daikoku](./dev-portal.md)\n* [Sessions management](./sessions-mgmt.md)\n* [The Otoroshi communication protocol](./otoroshi-protocol.md)\n* [Expression language](./expression-language.md)\n  \n@@@\n"},{"name":"input-tls.md","id":"/topics/input-tls.md","url":"/topics/input-tls.html","title":"Input TLS","content":"# Input TLS\n\n@@@ warning\nTODO\n@@@"},{"name":"monitoring.md","id":"/topics/monitoring.md","url":"/topics/monitoring.html","title":"Monitoring","content":"# Monitoring\n\n@@@ warning\nTODO\n@@@"},{"name":"otoroshi-protocol.md","id":"/topics/otoroshi-protocol.md","url":"/topics/otoroshi-protocol.html","title":"The Otoroshi communication protocol","content":"# The Otoroshi communication protocol\n\n@@@ warning\nTODO\n@@@"},{"name":"output-tls.md","id":"/topics/output-tls.md","url":"/topics/output-tls.html","title":"Ouput TLS","content":"# Ouput TLS\n\n@@@ warning\nTODO\n@@@"},{"name":"pki.md","id":"/topics/pki.md","url":"/topics/pki.html","title":"Otoroshi's PKI","content":"# Otoroshi's PKI\n\n@@@ warning\nTODO\n@@@"},{"name":"sessions-mgmt.md","id":"/topics/sessions-mgmt.md","url":"/topics/sessions-mgmt.html","title":"Sessions management","content":"# Sessions management"}]